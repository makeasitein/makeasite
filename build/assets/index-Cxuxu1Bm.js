function I0(t, r) { for (var i = 0; i < r.length; i++) { const s = r[i]; if (typeof s != "string" && !Array.isArray(s)) { for (const l in s) if (l !== "default" && !(l in t)) { const c = Object.getOwnPropertyDescriptor(s, l); c && Object.defineProperty(t, l, c.get ? c : { enumerable: !0, get: () => s[l] }) } } } return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })) } (function () { const r = document.createElement("link").relList; if (r && r.supports && r.supports("modulepreload")) return; for (const l of document.querySelectorAll('link[rel="modulepreload"]')) s(l); new MutationObserver(l => { for (const c of l) if (c.type === "childList") for (const u of c.addedNodes) u.tagName === "LINK" && u.rel === "modulepreload" && s(u) }).observe(document, { childList: !0, subtree: !0 }); function i(l) { const c = {}; return l.integrity && (c.integrity = l.integrity), l.referrerPolicy && (c.referrerPolicy = l.referrerPolicy), l.crossOrigin === "use-credentials" ? c.credentials = "include" : l.crossOrigin === "anonymous" ? c.credentials = "omit" : c.credentials = "same-origin", c } function s(l) { if (l.ep) return; l.ep = !0; const c = i(l); fetch(l.href, c) } })(); function _0(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var nu = { exports: {} }, no = {}, ru = { exports: {} }, we = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ph; function O0() { if (Ph) return we; Ph = 1; var t = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), c = Symbol.for("react.provider"), u = Symbol.for("react.context"), d = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), m = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), v = Symbol.iterator; function w(j) { return j === null || typeof j != "object" ? null : (j = v && j[v] || j["@@iterator"], typeof j == "function" ? j : null) } var k = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, E = Object.assign, N = {}; function C(j, _, ne) { this.props = j, this.context = _, this.refs = N, this.updater = ne || k } C.prototype.isReactComponent = {}, C.prototype.setState = function (j, _) { if (typeof j != "object" && typeof j != "function" && j != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, j, _, "setState") }, C.prototype.forceUpdate = function (j) { this.updater.enqueueForceUpdate(this, j, "forceUpdate") }; function P() { } P.prototype = C.prototype; function A(j, _, ne) { this.props = j, this.context = _, this.refs = N, this.updater = ne || k } var L = A.prototype = new P; L.constructor = A, E(L, C.prototype), L.isPureReactComponent = !0; var U = Array.isArray, O = Object.prototype.hasOwnProperty, H = { current: null }, K = { key: !0, ref: !0, __self: !0, __source: !0 }; function I(j, _, ne) { var ie, me = {}, ge = null, se = null; if (_ != null) for (ie in _.ref !== void 0 && (se = _.ref), _.key !== void 0 && (ge = "" + _.key), _) O.call(_, ie) && !K.hasOwnProperty(ie) && (me[ie] = _[ie]); var fe = arguments.length - 2; if (fe === 1) me.children = ne; else if (1 < fe) { for (var ve = Array(fe), Ne = 0; Ne < fe; Ne++)ve[Ne] = arguments[Ne + 2]; me.children = ve } if (j && j.defaultProps) for (ie in fe = j.defaultProps, fe) me[ie] === void 0 && (me[ie] = fe[ie]); return { $$typeof: t, type: j, key: ge, ref: se, props: me, _owner: H.current } } function Q(j, _) { return { $$typeof: t, type: j.type, key: _, ref: j.ref, props: j.props, _owner: j._owner } } function le(j) { return typeof j == "object" && j !== null && j.$$typeof === t } function pe(j) { var _ = { "=": "=0", ":": "=2" }; return "$" + j.replace(/[=:]/g, function (ne) { return _[ne] }) } var Se = /\/+/g; function Re(j, _) { return typeof j == "object" && j !== null && j.key != null ? pe("" + j.key) : _.toString(36) } function je(j, _, ne, ie, me) { var ge = typeof j; (ge === "undefined" || ge === "boolean") && (j = null); var se = !1; if (j === null) se = !0; else switch (ge) { case "string": case "number": se = !0; break; case "object": switch (j.$$typeof) { case t: case r: se = !0 } }if (se) return se = j, me = me(se), j = ie === "" ? "." + Re(se, 0) : ie, U(me) ? (ne = "", j != null && (ne = j.replace(Se, "$&/") + "/"), je(me, _, ne, "", function (Ne) { return Ne })) : me != null && (le(me) && (me = Q(me, ne + (!me.key || se && se.key === me.key ? "" : ("" + me.key).replace(Se, "$&/") + "/") + j)), _.push(me)), 1; if (se = 0, ie = ie === "" ? "." : ie + ":", U(j)) for (var fe = 0; fe < j.length; fe++) { ge = j[fe]; var ve = ie + Re(ge, fe); se += je(ge, _, ne, ve, me) } else if (ve = w(j), typeof ve == "function") for (j = ve.call(j), fe = 0; !(ge = j.next()).done;)ge = ge.value, ve = ie + Re(ge, fe++), se += je(ge, _, ne, ve, me); else if (ge === "object") throw _ = String(j), Error("Objects are not valid as a React child (found: " + (_ === "[object Object]" ? "object with keys {" + Object.keys(j).join(", ") + "}" : _) + "). If you meant to render a collection of children, use an array instead."); return se } function Te(j, _, ne) { if (j == null) return j; var ie = [], me = 0; return je(j, ie, "", "", function (ge) { return _.call(ne, ge, me++) }), ie } function ke(j) { if (j._status === -1) { var _ = j._result; _ = _(), _.then(function (ne) { (j._status === 0 || j._status === -1) && (j._status = 1, j._result = ne) }, function (ne) { (j._status === 0 || j._status === -1) && (j._status = 2, j._result = ne) }), j._status === -1 && (j._status = 0, j._result = _) } if (j._status === 1) return j._result.default; throw j._result } var ae = { current: null }, V = { transition: null }, Y = { ReactCurrentDispatcher: ae, ReactCurrentBatchConfig: V, ReactCurrentOwner: H }; function G() { throw Error("act(...) is not supported in production builds of React.") } return we.Children = { map: Te, forEach: function (j, _, ne) { Te(j, function () { _.apply(this, arguments) }, ne) }, count: function (j) { var _ = 0; return Te(j, function () { _++ }), _ }, toArray: function (j) { return Te(j, function (_) { return _ }) || [] }, only: function (j) { if (!le(j)) throw Error("React.Children.only expected to receive a single React element child."); return j } }, we.Component = C, we.Fragment = i, we.Profiler = l, we.PureComponent = A, we.StrictMode = s, we.Suspense = h, we.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y, we.act = G, we.cloneElement = function (j, _, ne) { if (j == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + j + "."); var ie = E({}, j.props), me = j.key, ge = j.ref, se = j._owner; if (_ != null) { if (_.ref !== void 0 && (ge = _.ref, se = H.current), _.key !== void 0 && (me = "" + _.key), j.type && j.type.defaultProps) var fe = j.type.defaultProps; for (ve in _) O.call(_, ve) && !K.hasOwnProperty(ve) && (ie[ve] = _[ve] === void 0 && fe !== void 0 ? fe[ve] : _[ve]) } var ve = arguments.length - 2; if (ve === 1) ie.children = ne; else if (1 < ve) { fe = Array(ve); for (var Ne = 0; Ne < ve; Ne++)fe[Ne] = arguments[Ne + 2]; ie.children = fe } return { $$typeof: t, type: j.type, key: me, ref: ge, props: ie, _owner: se } }, we.createContext = function (j) { return j = { $$typeof: u, _currentValue: j, _currentValue2: j, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, j.Provider = { $$typeof: c, _context: j }, j.Consumer = j }, we.createElement = I, we.createFactory = function (j) { var _ = I.bind(null, j); return _.type = j, _ }, we.createRef = function () { return { current: null } }, we.forwardRef = function (j) { return { $$typeof: d, render: j } }, we.isValidElement = le, we.lazy = function (j) { return { $$typeof: g, _payload: { _status: -1, _result: j }, _init: ke } }, we.memo = function (j, _) { return { $$typeof: m, type: j, compare: _ === void 0 ? null : _ } }, we.startTransition = function (j) { var _ = V.transition; V.transition = {}; try { j() } finally { V.transition = _ } }, we.unstable_act = G, we.useCallback = function (j, _) { return ae.current.useCallback(j, _) }, we.useContext = function (j) { return ae.current.useContext(j) }, we.useDebugValue = function () { }, we.useDeferredValue = function (j) { return ae.current.useDeferredValue(j) }, we.useEffect = function (j, _) { return ae.current.useEffect(j, _) }, we.useId = function () { return ae.current.useId() }, we.useImperativeHandle = function (j, _, ne) { return ae.current.useImperativeHandle(j, _, ne) }, we.useInsertionEffect = function (j, _) { return ae.current.useInsertionEffect(j, _) }, we.useLayoutEffect = function (j, _) { return ae.current.useLayoutEffect(j, _) }, we.useMemo = function (j, _) { return ae.current.useMemo(j, _) }, we.useReducer = function (j, _, ne) { return ae.current.useReducer(j, _, ne) }, we.useRef = function (j) { return ae.current.useRef(j) }, we.useState = function (j) { return ae.current.useState(j) }, we.useSyncExternalStore = function (j, _, ne) { return ae.current.useSyncExternalStore(j, _, ne) }, we.useTransition = function () { return ae.current.useTransition() }, we.version = "18.3.1", we } var Th; function tc() { return Th || (Th = 1, ru.exports = O0()), ru.exports }/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Nh; function z0() { if (Nh) return no; Nh = 1; var t = tc(), r = Symbol.for("react.element"), i = Symbol.for("react.fragment"), s = Object.prototype.hasOwnProperty, l = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, c = { key: !0, ref: !0, __self: !0, __source: !0 }; function u(d, h, m) { var g, v = {}, w = null, k = null; m !== void 0 && (w = "" + m), h.key !== void 0 && (w = "" + h.key), h.ref !== void 0 && (k = h.ref); for (g in h) s.call(h, g) && !c.hasOwnProperty(g) && (v[g] = h[g]); if (d && d.defaultProps) for (g in h = d.defaultProps, h) v[g] === void 0 && (v[g] = h[g]); return { $$typeof: r, type: d, key: w, ref: k, props: v, _owner: l.current } } return no.Fragment = i, no.jsx = u, no.jsxs = u, no } var bh; function B0() { return bh || (bh = 1, nu.exports = z0()), nu.exports } var x = B0(), Us = {}, iu = { exports: {} }, wt = {}, ou = { exports: {} }, su = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Rh; function U0() { return Rh || (Rh = 1, (function (t) { function r(V, Y) { var G = V.length; V.push(Y); e: for (; 0 < G;) { var j = G - 1 >>> 1, _ = V[j]; if (0 < l(_, Y)) V[j] = Y, V[G] = _, G = j; else break e } } function i(V) { return V.length === 0 ? null : V[0] } function s(V) { if (V.length === 0) return null; var Y = V[0], G = V.pop(); if (G !== Y) { V[0] = G; e: for (var j = 0, _ = V.length, ne = _ >>> 1; j < ne;) { var ie = 2 * (j + 1) - 1, me = V[ie], ge = ie + 1, se = V[ge]; if (0 > l(me, G)) ge < _ && 0 > l(se, me) ? (V[j] = se, V[ge] = G, j = ge) : (V[j] = me, V[ie] = G, j = ie); else if (ge < _ && 0 > l(se, G)) V[j] = se, V[ge] = G, j = ge; else break e } } return Y } function l(V, Y) { var G = V.sortIndex - Y.sortIndex; return G !== 0 ? G : V.id - Y.id } if (typeof performance == "object" && typeof performance.now == "function") { var c = performance; t.unstable_now = function () { return c.now() } } else { var u = Date, d = u.now(); t.unstable_now = function () { return u.now() - d } } var h = [], m = [], g = 1, v = null, w = 3, k = !1, E = !1, N = !1, C = typeof setTimeout == "function" ? setTimeout : null, P = typeof clearTimeout == "function" ? clearTimeout : null, A = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function L(V) { for (var Y = i(m); Y !== null;) { if (Y.callback === null) s(m); else if (Y.startTime <= V) s(m), Y.sortIndex = Y.expirationTime, r(h, Y); else break; Y = i(m) } } function U(V) { if (N = !1, L(V), !E) if (i(h) !== null) E = !0, ke(O); else { var Y = i(m); Y !== null && ae(U, Y.startTime - V) } } function O(V, Y) { E = !1, N && (N = !1, P(I), I = -1), k = !0; var G = w; try { for (L(Y), v = i(h); v !== null && (!(v.expirationTime > Y) || V && !pe());) { var j = v.callback; if (typeof j == "function") { v.callback = null, w = v.priorityLevel; var _ = j(v.expirationTime <= Y); Y = t.unstable_now(), typeof _ == "function" ? v.callback = _ : v === i(h) && s(h), L(Y) } else s(h); v = i(h) } if (v !== null) var ne = !0; else { var ie = i(m); ie !== null && ae(U, ie.startTime - Y), ne = !1 } return ne } finally { v = null, w = G, k = !1 } } var H = !1, K = null, I = -1, Q = 5, le = -1; function pe() { return !(t.unstable_now() - le < Q) } function Se() { if (K !== null) { var V = t.unstable_now(); le = V; var Y = !0; try { Y = K(!0, V) } finally { Y ? Re() : (H = !1, K = null) } } else H = !1 } var Re; if (typeof A == "function") Re = function () { A(Se) }; else if (typeof MessageChannel < "u") { var je = new MessageChannel, Te = je.port2; je.port1.onmessage = Se, Re = function () { Te.postMessage(null) } } else Re = function () { C(Se, 0) }; function ke(V) { K = V, H || (H = !0, Re()) } function ae(V, Y) { I = C(function () { V(t.unstable_now()) }, Y) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (V) { V.callback = null }, t.unstable_continueExecution = function () { E || k || (E = !0, ke(O)) }, t.unstable_forceFrameRate = function (V) { 0 > V || 125 < V ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Q = 0 < V ? Math.floor(1e3 / V) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return w }, t.unstable_getFirstCallbackNode = function () { return i(h) }, t.unstable_next = function (V) { switch (w) { case 1: case 2: case 3: var Y = 3; break; default: Y = w }var G = w; w = Y; try { return V() } finally { w = G } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (V, Y) { switch (V) { case 1: case 2: case 3: case 4: case 5: break; default: V = 3 }var G = w; w = V; try { return Y() } finally { w = G } }, t.unstable_scheduleCallback = function (V, Y, G) { var j = t.unstable_now(); switch (typeof G == "object" && G !== null ? (G = G.delay, G = typeof G == "number" && 0 < G ? j + G : j) : G = j, V) { case 1: var _ = -1; break; case 2: _ = 250; break; case 5: _ = 1073741823; break; case 4: _ = 1e4; break; default: _ = 5e3 }return _ = G + _, V = { id: g++, callback: Y, priorityLevel: V, startTime: G, expirationTime: _, sortIndex: -1 }, G > j ? (V.sortIndex = G, r(m, V), i(h) === null && V === i(m) && (N ? (P(I), I = -1) : N = !0, ae(U, G - j))) : (V.sortIndex = _, r(h, V), E || k || (E = !0, ke(O))), V }, t.unstable_shouldYield = pe, t.unstable_wrapCallback = function (V) { var Y = w; return function () { var G = w; w = Y; try { return V.apply(this, arguments) } finally { w = G } } } })(su)), su } var jh; function $0() { return jh || (jh = 1, ou.exports = U0()), ou.exports }/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ah; function W0() {
  if (Ah) return wt; Ah = 1; var t = tc(), r = $0(); function i(e) { for (var n = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, o = 1; o < arguments.length; o++)n += "&args[]=" + encodeURIComponent(arguments[o]); return "Minified React error #" + e + "; visit " + n + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var s = new Set, l = {}; function c(e, n) { u(e, n), u(e + "Capture", n) } function u(e, n) { for (l[e] = n, e = 0; e < n.length; e++)s.add(n[e]) } var d = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), h = Object.prototype.hasOwnProperty, m = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, g = {}, v = {}; function w(e) { return h.call(v, e) ? !0 : h.call(g, e) ? !1 : m.test(e) ? v[e] = !0 : (g[e] = !0, !1) } function k(e, n, o, a) { if (o !== null && o.type === 0) return !1; switch (typeof n) { case "function": case "symbol": return !0; case "boolean": return a ? !1 : o !== null ? !o.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function E(e, n, o, a) { if (n === null || typeof n > "u" || k(e, n, o, a)) return !0; if (a) return !1; if (o !== null) switch (o.type) { case 3: return !n; case 4: return n === !1; case 5: return isNaN(n); case 6: return isNaN(n) || 1 > n }return !1 } function N(e, n, o, a, f, p, y) { this.acceptsBooleans = n === 2 || n === 3 || n === 4, this.attributeName = a, this.attributeNamespace = f, this.mustUseProperty = o, this.propertyName = e, this.type = n, this.sanitizeURL = p, this.removeEmptyString = y } var C = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { C[e] = new N(e, 0, !1, e, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var n = e[0]; C[n] = new N(n, 1, !1, e[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { C[e] = new N(e, 2, !1, e.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { C[e] = new N(e, 2, !1, e, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { C[e] = new N(e, 3, !1, e.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (e) { C[e] = new N(e, 3, !0, e, null, !1, !1) }), ["capture", "download"].forEach(function (e) { C[e] = new N(e, 4, !1, e, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (e) { C[e] = new N(e, 6, !1, e, null, !1, !1) }), ["rowSpan", "start"].forEach(function (e) { C[e] = new N(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var P = /[\-:]([a-z])/g; function A(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var n = e.replace(P, A); C[n] = new N(n, 1, !1, e, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var n = e.replace(P, A); C[n] = new N(n, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var n = e.replace(P, A); C[n] = new N(n, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (e) { C[e] = new N(e, 1, !1, e.toLowerCase(), null, !1, !1) }), C.xlinkHref = new N("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (e) { C[e] = new N(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function L(e, n, o, a) { var f = C.hasOwnProperty(n) ? C[n] : null; (f !== null ? f.type !== 0 : a || !(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N") && (E(n, o, f, a) && (o = null), a || f === null ? w(n) && (o === null ? e.removeAttribute(n) : e.setAttribute(n, "" + o)) : f.mustUseProperty ? e[f.propertyName] = o === null ? f.type === 3 ? !1 : "" : o : (n = f.attributeName, a = f.attributeNamespace, o === null ? e.removeAttribute(n) : (f = f.type, o = f === 3 || f === 4 && o === !0 ? "" : "" + o, a ? e.setAttributeNS(a, n, o) : e.setAttribute(n, o)))) } var U = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, O = Symbol.for("react.element"), H = Symbol.for("react.portal"), K = Symbol.for("react.fragment"), I = Symbol.for("react.strict_mode"), Q = Symbol.for("react.profiler"), le = Symbol.for("react.provider"), pe = Symbol.for("react.context"), Se = Symbol.for("react.forward_ref"), Re = Symbol.for("react.suspense"), je = Symbol.for("react.suspense_list"), Te = Symbol.for("react.memo"), ke = Symbol.for("react.lazy"), ae = Symbol.for("react.offscreen"), V = Symbol.iterator; function Y(e) { return e === null || typeof e != "object" ? null : (e = V && e[V] || e["@@iterator"], typeof e == "function" ? e : null) } var G = Object.assign, j; function _(e) {
    if (j === void 0) try { throw Error() } catch (o) { var n = o.stack.trim().match(/\n( *(at )?)/); j = n && n[1] || "" } return `
`+ j + e
  } var ne = !1; function ie(e, n) {
    if (!e || ne) return ""; ne = !0; var o = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (n) if (n = function () { throw Error() }, Object.defineProperty(n.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(n, []) } catch (F) { var a = F } Reflect.construct(e, [], n) } else { try { n.call() } catch (F) { a = F } e.call(n.prototype) } else { try { throw Error() } catch (F) { a = F } e() } } catch (F) {
      if (F && a && typeof F.stack == "string") {
        for (var f = F.stack.split(`
`), p = a.stack.split(`
`), y = f.length - 1, S = p.length - 1; 1 <= y && 0 <= S && f[y] !== p[S];)S--; for (; 1 <= y && 0 <= S; y--, S--)if (f[y] !== p[S]) {
          if (y !== 1 || S !== 1) do if (y--, S--, 0 > S || f[y] !== p[S]) {
            var T = `
`+ f[y].replace(" at new ", " at "); return e.displayName && T.includes("<anonymous>") && (T = T.replace("<anonymous>", e.displayName)), T
          } while (1 <= y && 0 <= S); break
        }
      }
    } finally { ne = !1, Error.prepareStackTrace = o } return (e = e ? e.displayName || e.name : "") ? _(e) : ""
  } function me(e) { switch (e.tag) { case 5: return _(e.type); case 16: return _("Lazy"); case 13: return _("Suspense"); case 19: return _("SuspenseList"); case 0: case 2: case 15: return e = ie(e.type, !1), e; case 11: return e = ie(e.type.render, !1), e; case 1: return e = ie(e.type, !0), e; default: return "" } } function ge(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case K: return "Fragment"; case H: return "Portal"; case Q: return "Profiler"; case I: return "StrictMode"; case Re: return "Suspense"; case je: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case pe: return (e.displayName || "Context") + ".Consumer"; case le: return (e._context.displayName || "Context") + ".Provider"; case Se: var n = e.render; return e = e.displayName, e || (e = n.displayName || n.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case Te: return n = e.displayName || null, n !== null ? n : ge(e.type) || "Memo"; case ke: n = e._payload, e = e._init; try { return ge(e(n)) } catch { } }return null } function se(e) { var n = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (n.displayName || "Context") + ".Consumer"; case 10: return (n._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = n.render, e = e.displayName || e.name || "", n.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return n; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return ge(n); case 8: return n === I ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof n == "function") return n.displayName || n.name || null; if (typeof n == "string") return n }return null } function fe(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function ve(e) { var n = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (n === "checkbox" || n === "radio") } function Ne(e) { var n = ve(e) ? "checked" : "value", o = Object.getOwnPropertyDescriptor(e.constructor.prototype, n), a = "" + e[n]; if (!e.hasOwnProperty(n) && typeof o < "u" && typeof o.get == "function" && typeof o.set == "function") { var f = o.get, p = o.set; return Object.defineProperty(e, n, { configurable: !0, get: function () { return f.call(this) }, set: function (y) { a = "" + y, p.call(this, y) } }), Object.defineProperty(e, n, { enumerable: o.enumerable }), { getValue: function () { return a }, setValue: function (y) { a = "" + y }, stopTracking: function () { e._valueTracker = null, delete e[n] } } } } function Ce(e) { e._valueTracker || (e._valueTracker = Ne(e)) } function Z(e) { if (!e) return !1; var n = e._valueTracker; if (!n) return !0; var o = n.getValue(), a = ""; return e && (a = ve(e) ? e.checked ? "true" : "false" : e.value), e = a, e !== o ? (n.setValue(e), !0) : !1 } function be(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Fe(e, n) { var o = n.checked; return G({}, n, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: o ?? e._wrapperState.initialChecked }) } function et(e, n) { var o = n.defaultValue == null ? "" : n.defaultValue, a = n.checked != null ? n.checked : n.defaultChecked; o = fe(n.value != null ? n.value : o), e._wrapperState = { initialChecked: a, initialValue: o, controlled: n.type === "checkbox" || n.type === "radio" ? n.checked != null : n.value != null } } function kt(e, n) { n = n.checked, n != null && L(e, "checked", n, !1) } function Et(e, n) { kt(e, n); var o = fe(n.value), a = n.type; if (o != null) a === "number" ? (o === 0 && e.value === "" || e.value != o) && (e.value = "" + o) : e.value !== "" + o && (e.value = "" + o); else if (a === "submit" || a === "reset") { e.removeAttribute("value"); return } n.hasOwnProperty("value") ? Rt(e, n.type, o) : n.hasOwnProperty("defaultValue") && Rt(e, n.type, fe(n.defaultValue)), n.checked == null && n.defaultChecked != null && (e.defaultChecked = !!n.defaultChecked) } function en(e, n, o) { if (n.hasOwnProperty("value") || n.hasOwnProperty("defaultValue")) { var a = n.type; if (!(a !== "submit" && a !== "reset" || n.value !== void 0 && n.value !== null)) return; n = "" + e._wrapperState.initialValue, o || n === e.value || (e.value = n), e.defaultValue = n } o = e.name, o !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, o !== "" && (e.name = o) } function Rt(e, n, o) { (n !== "number" || be(e.ownerDocument) !== e) && (o == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + o && (e.defaultValue = "" + o)) } var Ct = Array.isArray; function jt(e, n, o, a) { if (e = e.options, n) { n = {}; for (var f = 0; f < o.length; f++)n["$" + o[f]] = !0; for (o = 0; o < e.length; o++)f = n.hasOwnProperty("$" + e[o].value), e[o].selected !== f && (e[o].selected = f), f && a && (e[o].defaultSelected = !0) } else { for (o = "" + fe(o), n = null, f = 0; f < e.length; f++) { if (e[f].value === o) { e[f].selected = !0, a && (e[f].defaultSelected = !0); return } n !== null || e[f].disabled || (n = e[f]) } n !== null && (n.selected = !0) } } function qn(e, n) { if (n.dangerouslySetInnerHTML != null) throw Error(i(91)); return G({}, n, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function Sr(e, n) { var o = n.value; if (o == null) { if (o = n.children, n = n.defaultValue, o != null) { if (n != null) throw Error(i(92)); if (Ct(o)) { if (1 < o.length) throw Error(i(93)); o = o[0] } n = o } n == null && (n = ""), o = n } e._wrapperState = { initialValue: fe(o) } } function ci(e, n) { var o = fe(n.value), a = fe(n.defaultValue); o != null && (o = "" + o, o !== e.value && (e.value = o), n.defaultValue == null && e.defaultValue !== o && (e.defaultValue = o)), a != null && (e.defaultValue = "" + a) } function fi(e) { var n = e.textContent; n === e._wrapperState.initialValue && n !== "" && n !== null && (e.value = n) } function Ao(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function kr(e, n) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Ao(n) : e === "http://www.w3.org/2000/svg" && n === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var Er, Cr = (function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (n, o, a, f) { MSApp.execUnsafeLocalFunction(function () { return e(n, o, a, f) }) } : e })(function (e, n) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = n; else { for (Er = Er || document.createElement("div"), Er.innerHTML = "<svg>" + n.valueOf().toString() + "</svg>", n = Er.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; n.firstChild;)e.appendChild(n.firstChild) } }); function At(e, n) { if (n) { var o = e.firstChild; if (o && o === e.lastChild && o.nodeType === 3) { o.nodeValue = n; return } } e.textContent = n } var cn = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, di = ["Webkit", "ms", "Moz", "O"]; Object.keys(cn).forEach(function (e) { di.forEach(function (n) { n = n + e.charAt(0).toUpperCase() + e.substring(1), cn[n] = cn[e] }) }); function Zn(e, n, o) { return n == null || typeof n == "boolean" || n === "" ? "" : o || typeof n != "number" || n === 0 || cn.hasOwnProperty(e) && cn[e] ? ("" + n).trim() : n + "px" } function Mo(e, n) { e = e.style; for (var o in n) if (n.hasOwnProperty(o)) { var a = o.indexOf("--") === 0, f = Zn(o, n[o], a); o === "float" && (o = "cssFloat"), a ? e.setProperty(o, f) : e[o] = f } } var va = G({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function hi(e, n) { if (n) { if (va[e] && (n.children != null || n.dangerouslySetInnerHTML != null)) throw Error(i(137, e)); if (n.dangerouslySetInnerHTML != null) { if (n.children != null) throw Error(i(60)); if (typeof n.dangerouslySetInnerHTML != "object" || !("__html" in n.dangerouslySetInnerHTML)) throw Error(i(61)) } if (n.style != null && typeof n.style != "object") throw Error(i(62)) } } function pi(e, n) { if (e.indexOf("-") === -1) return typeof n.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var mi = null; function Pr(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var gi = null, fn = null, dn = null; function yi(e) { if (e = Bi(e)) { if (typeof gi != "function") throw Error(i(280)); var n = e.stateNode; n && (n = rs(n), gi(e.stateNode, e.type, n)) } } function Lo(e) { fn ? dn ? dn.push(e) : dn = [e] : fn = e } function vi() { if (fn) { var e = fn, n = dn; if (dn = fn = null, yi(e), n) for (e = 0; e < n.length; e++)yi(n[e]) } } function xi(e, n) { return e(n) } function Do() { } var xa = !1; function Kc(e, n, o) { if (xa) return e(n, o); xa = !0; try { return xi(e, n, o) } finally { xa = !1, (fn !== null || dn !== null) && (Do(), vi()) } } function wi(e, n) { var o = e.stateNode; if (o === null) return null; var a = rs(o); if (a === null) return null; o = a[n]; e: switch (n) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (a = !a.disabled) || (e = e.type, a = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !a; break e; default: e = !1 }if (e) return null; if (o && typeof o != "function") throw Error(i(231, n, typeof o)); return o } var wa = !1; if (d) try { var Si = {}; Object.defineProperty(Si, "passive", { get: function () { wa = !0 } }), window.addEventListener("test", Si, Si), window.removeEventListener("test", Si, Si) } catch { wa = !1 } function $y(e, n, o, a, f, p, y, S, T) { var F = Array.prototype.slice.call(arguments, 3); try { n.apply(o, F) } catch (B) { this.onError(B) } } var ki = !1, Fo = null, Vo = !1, Sa = null, Wy = { onError: function (e) { ki = !0, Fo = e } }; function Hy(e, n, o, a, f, p, y, S, T) { ki = !1, Fo = null, $y.apply(Wy, arguments) } function Ky(e, n, o, a, f, p, y, S, T) { if (Hy.apply(this, arguments), ki) { if (ki) { var F = Fo; ki = !1, Fo = null } else throw Error(i(198)); Vo || (Vo = !0, Sa = F) } } function Jn(e) { var n = e, o = e; if (e.alternate) for (; n.return;)n = n.return; else { e = n; do n = e, (n.flags & 4098) !== 0 && (o = n.return), e = n.return; while (e) } return n.tag === 3 ? o : null } function Gc(e) { if (e.tag === 13) { var n = e.memoizedState; if (n === null && (e = e.alternate, e !== null && (n = e.memoizedState)), n !== null) return n.dehydrated } return null } function Yc(e) { if (Jn(e) !== e) throw Error(i(188)) } function Gy(e) { var n = e.alternate; if (!n) { if (n = Jn(e), n === null) throw Error(i(188)); return n !== e ? null : e } for (var o = e, a = n; ;) { var f = o.return; if (f === null) break; var p = f.alternate; if (p === null) { if (a = f.return, a !== null) { o = a; continue } break } if (f.child === p.child) { for (p = f.child; p;) { if (p === o) return Yc(f), e; if (p === a) return Yc(f), n; p = p.sibling } throw Error(i(188)) } if (o.return !== a.return) o = f, a = p; else { for (var y = !1, S = f.child; S;) { if (S === o) { y = !0, o = f, a = p; break } if (S === a) { y = !0, a = f, o = p; break } S = S.sibling } if (!y) { for (S = p.child; S;) { if (S === o) { y = !0, o = p, a = f; break } if (S === a) { y = !0, a = p, o = f; break } S = S.sibling } if (!y) throw Error(i(189)) } } if (o.alternate !== a) throw Error(i(190)) } if (o.tag !== 3) throw Error(i(188)); return o.stateNode.current === o ? e : n } function Xc(e) { return e = Gy(e), e !== null ? Qc(e) : null } function Qc(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var n = Qc(e); if (n !== null) return n; e = e.sibling } return null } var qc = r.unstable_scheduleCallback, Zc = r.unstable_cancelCallback, Yy = r.unstable_shouldYield, Xy = r.unstable_requestPaint, He = r.unstable_now, Qy = r.unstable_getCurrentPriorityLevel, ka = r.unstable_ImmediatePriority, Jc = r.unstable_UserBlockingPriority, Io = r.unstable_NormalPriority, qy = r.unstable_LowPriority, ef = r.unstable_IdlePriority, _o = null, tn = null; function Zy(e) { if (tn && typeof tn.onCommitFiberRoot == "function") try { tn.onCommitFiberRoot(_o, e, void 0, (e.current.flags & 128) === 128) } catch { } } var Ut = Math.clz32 ? Math.clz32 : tv, Jy = Math.log, ev = Math.LN2; function tv(e) { return e >>>= 0, e === 0 ? 32 : 31 - (Jy(e) / ev | 0) | 0 } var Oo = 64, zo = 4194304; function Ei(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Bo(e, n) { var o = e.pendingLanes; if (o === 0) return 0; var a = 0, f = e.suspendedLanes, p = e.pingedLanes, y = o & 268435455; if (y !== 0) { var S = y & ~f; S !== 0 ? a = Ei(S) : (p &= y, p !== 0 && (a = Ei(p))) } else y = o & ~f, y !== 0 ? a = Ei(y) : p !== 0 && (a = Ei(p)); if (a === 0) return 0; if (n !== 0 && n !== a && (n & f) === 0 && (f = a & -a, p = n & -n, f >= p || f === 16 && (p & 4194240) !== 0)) return n; if ((a & 4) !== 0 && (a |= o & 16), n = e.entangledLanes, n !== 0) for (e = e.entanglements, n &= a; 0 < n;)o = 31 - Ut(n), f = 1 << o, a |= e[o], n &= ~f; return a } function nv(e, n) { switch (e) { case 1: case 2: case 4: return n + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return n + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function rv(e, n) { for (var o = e.suspendedLanes, a = e.pingedLanes, f = e.expirationTimes, p = e.pendingLanes; 0 < p;) { var y = 31 - Ut(p), S = 1 << y, T = f[y]; T === -1 ? ((S & o) === 0 || (S & a) !== 0) && (f[y] = nv(S, n)) : T <= n && (e.expiredLanes |= S), p &= ~S } } function Ea(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function tf() { var e = Oo; return Oo <<= 1, (Oo & 4194240) === 0 && (Oo = 64), e } function Ca(e) { for (var n = [], o = 0; 31 > o; o++)n.push(e); return n } function Ci(e, n, o) { e.pendingLanes |= n, n !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, n = 31 - Ut(n), e[n] = o } function iv(e, n) { var o = e.pendingLanes & ~n; e.pendingLanes = n, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= n, e.mutableReadLanes &= n, e.entangledLanes &= n, n = e.entanglements; var a = e.eventTimes; for (e = e.expirationTimes; 0 < o;) { var f = 31 - Ut(o), p = 1 << f; n[f] = 0, a[f] = -1, e[f] = -1, o &= ~p } } function Pa(e, n) { var o = e.entangledLanes |= n; for (e = e.entanglements; o;) { var a = 31 - Ut(o), f = 1 << a; f & n | e[a] & n && (e[a] |= n), o &= ~f } } var Ae = 0; function nf(e) { return e &= -e, 1 < e ? 4 < e ? (e & 268435455) !== 0 ? 16 : 536870912 : 4 : 1 } var rf, Ta, of, sf, af, Na = !1, Uo = [], Nn = null, bn = null, Rn = null, Pi = new Map, Ti = new Map, jn = [], ov = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function lf(e, n) { switch (e) { case "focusin": case "focusout": Nn = null; break; case "dragenter": case "dragleave": bn = null; break; case "mouseover": case "mouseout": Rn = null; break; case "pointerover": case "pointerout": Pi.delete(n.pointerId); break; case "gotpointercapture": case "lostpointercapture": Ti.delete(n.pointerId) } } function Ni(e, n, o, a, f, p) { return e === null || e.nativeEvent !== p ? (e = { blockedOn: n, domEventName: o, eventSystemFlags: a, nativeEvent: p, targetContainers: [f] }, n !== null && (n = Bi(n), n !== null && Ta(n)), e) : (e.eventSystemFlags |= a, n = e.targetContainers, f !== null && n.indexOf(f) === -1 && n.push(f), e) } function sv(e, n, o, a, f) { switch (n) { case "focusin": return Nn = Ni(Nn, e, n, o, a, f), !0; case "dragenter": return bn = Ni(bn, e, n, o, a, f), !0; case "mouseover": return Rn = Ni(Rn, e, n, o, a, f), !0; case "pointerover": var p = f.pointerId; return Pi.set(p, Ni(Pi.get(p) || null, e, n, o, a, f)), !0; case "gotpointercapture": return p = f.pointerId, Ti.set(p, Ni(Ti.get(p) || null, e, n, o, a, f)), !0 }return !1 } function uf(e) { var n = er(e.target); if (n !== null) { var o = Jn(n); if (o !== null) { if (n = o.tag, n === 13) { if (n = Gc(o), n !== null) { e.blockedOn = n, af(e.priority, function () { of(o) }); return } } else if (n === 3 && o.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = o.tag === 3 ? o.stateNode.containerInfo : null; return } } } e.blockedOn = null } function $o(e) { if (e.blockedOn !== null) return !1; for (var n = e.targetContainers; 0 < n.length;) { var o = Ra(e.domEventName, e.eventSystemFlags, n[0], e.nativeEvent); if (o === null) { o = e.nativeEvent; var a = new o.constructor(o.type, o); mi = a, o.target.dispatchEvent(a), mi = null } else return n = Bi(o), n !== null && Ta(n), e.blockedOn = o, !1; n.shift() } return !0 } function cf(e, n, o) { $o(e) && o.delete(n) } function av() { Na = !1, Nn !== null && $o(Nn) && (Nn = null), bn !== null && $o(bn) && (bn = null), Rn !== null && $o(Rn) && (Rn = null), Pi.forEach(cf), Ti.forEach(cf) } function bi(e, n) { e.blockedOn === n && (e.blockedOn = null, Na || (Na = !0, r.unstable_scheduleCallback(r.unstable_NormalPriority, av))) } function Ri(e) { function n(f) { return bi(f, e) } if (0 < Uo.length) { bi(Uo[0], e); for (var o = 1; o < Uo.length; o++) { var a = Uo[o]; a.blockedOn === e && (a.blockedOn = null) } } for (Nn !== null && bi(Nn, e), bn !== null && bi(bn, e), Rn !== null && bi(Rn, e), Pi.forEach(n), Ti.forEach(n), o = 0; o < jn.length; o++)a = jn[o], a.blockedOn === e && (a.blockedOn = null); for (; 0 < jn.length && (o = jn[0], o.blockedOn === null);)uf(o), o.blockedOn === null && jn.shift() } var Tr = U.ReactCurrentBatchConfig, Wo = !0; function lv(e, n, o, a) { var f = Ae, p = Tr.transition; Tr.transition = null; try { Ae = 1, ba(e, n, o, a) } finally { Ae = f, Tr.transition = p } } function uv(e, n, o, a) { var f = Ae, p = Tr.transition; Tr.transition = null; try { Ae = 4, ba(e, n, o, a) } finally { Ae = f, Tr.transition = p } } function ba(e, n, o, a) { if (Wo) { var f = Ra(e, n, o, a); if (f === null) Ka(e, n, a, Ho, o), lf(e, a); else if (sv(f, e, n, o, a)) a.stopPropagation(); else if (lf(e, a), n & 4 && -1 < ov.indexOf(e)) { for (; f !== null;) { var p = Bi(f); if (p !== null && rf(p), p = Ra(e, n, o, a), p === null && Ka(e, n, a, Ho, o), p === f) break; f = p } f !== null && a.stopPropagation() } else Ka(e, n, a, null, o) } } var Ho = null; function Ra(e, n, o, a) { if (Ho = null, e = Pr(a), e = er(e), e !== null) if (n = Jn(e), n === null) e = null; else if (o = n.tag, o === 13) { if (e = Gc(n), e !== null) return e; e = null } else if (o === 3) { if (n.stateNode.current.memoizedState.isDehydrated) return n.tag === 3 ? n.stateNode.containerInfo : null; e = null } else n !== e && (e = null); return Ho = e, null } function ff(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Qy()) { case ka: return 1; case Jc: return 4; case Io: case qy: return 16; case ef: return 536870912; default: return 16 }default: return 16 } } var An = null, ja = null, Ko = null; function df() { if (Ko) return Ko; var e, n = ja, o = n.length, a, f = "value" in An ? An.value : An.textContent, p = f.length; for (e = 0; e < o && n[e] === f[e]; e++); var y = o - e; for (a = 1; a <= y && n[o - a] === f[p - a]; a++); return Ko = f.slice(e, 1 < a ? 1 - a : void 0) } function Go(e) { var n = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && n === 13 && (e = 13)) : e = n, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function Yo() { return !0 } function hf() { return !1 } function Pt(e) { function n(o, a, f, p, y) { this._reactName = o, this._targetInst = f, this.type = a, this.nativeEvent = p, this.target = y, this.currentTarget = null; for (var S in e) e.hasOwnProperty(S) && (o = e[S], this[S] = o ? o(p) : p[S]); return this.isDefaultPrevented = (p.defaultPrevented != null ? p.defaultPrevented : p.returnValue === !1) ? Yo : hf, this.isPropagationStopped = hf, this } return G(n.prototype, { preventDefault: function () { this.defaultPrevented = !0; var o = this.nativeEvent; o && (o.preventDefault ? o.preventDefault() : typeof o.returnValue != "unknown" && (o.returnValue = !1), this.isDefaultPrevented = Yo) }, stopPropagation: function () { var o = this.nativeEvent; o && (o.stopPropagation ? o.stopPropagation() : typeof o.cancelBubble != "unknown" && (o.cancelBubble = !0), this.isPropagationStopped = Yo) }, persist: function () { }, isPersistent: Yo }), n } var Nr = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Aa = Pt(Nr), ji = G({}, Nr, { view: 0, detail: 0 }), cv = Pt(ji), Ma, La, Ai, Xo = G({}, ji, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Fa, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Ai && (Ai && e.type === "mousemove" ? (Ma = e.screenX - Ai.screenX, La = e.screenY - Ai.screenY) : La = Ma = 0, Ai = e), Ma) }, movementY: function (e) { return "movementY" in e ? e.movementY : La } }), pf = Pt(Xo), fv = G({}, Xo, { dataTransfer: 0 }), dv = Pt(fv), hv = G({}, ji, { relatedTarget: 0 }), Da = Pt(hv), pv = G({}, Nr, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), mv = Pt(pv), gv = G({}, Nr, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), yv = Pt(gv), vv = G({}, Nr, { data: 0 }), mf = Pt(vv), xv = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, wv = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Sv = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function kv(e) { var n = this.nativeEvent; return n.getModifierState ? n.getModifierState(e) : (e = Sv[e]) ? !!n[e] : !1 } function Fa() { return kv } var Ev = G({}, ji, { key: function (e) { if (e.key) { var n = xv[e.key] || e.key; if (n !== "Unidentified") return n } return e.type === "keypress" ? (e = Go(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? wv[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Fa, charCode: function (e) { return e.type === "keypress" ? Go(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? Go(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Cv = Pt(Ev), Pv = G({}, Xo, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), gf = Pt(Pv), Tv = G({}, ji, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Fa }), Nv = Pt(Tv), bv = G({}, Nr, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Rv = Pt(bv), jv = G({}, Xo, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Av = Pt(jv), Mv = [9, 13, 27, 32], Va = d && "CompositionEvent" in window, Mi = null; d && "documentMode" in document && (Mi = document.documentMode); var Lv = d && "TextEvent" in window && !Mi, yf = d && (!Va || Mi && 8 < Mi && 11 >= Mi), vf = " ", xf = !1; function wf(e, n) { switch (e) { case "keyup": return Mv.indexOf(n.keyCode) !== -1; case "keydown": return n.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Sf(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var br = !1; function Dv(e, n) { switch (e) { case "compositionend": return Sf(n); case "keypress": return n.which !== 32 ? null : (xf = !0, vf); case "textInput": return e = n.data, e === vf && xf ? null : e; default: return null } } function Fv(e, n) { if (br) return e === "compositionend" || !Va && wf(e, n) ? (e = df(), Ko = ja = An = null, br = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(n.ctrlKey || n.altKey || n.metaKey) || n.ctrlKey && n.altKey) { if (n.char && 1 < n.char.length) return n.char; if (n.which) return String.fromCharCode(n.which) } return null; case "compositionend": return yf && n.locale !== "ko" ? null : n.data; default: return null } } var Vv = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function kf(e) { var n = e && e.nodeName && e.nodeName.toLowerCase(); return n === "input" ? !!Vv[e.type] : n === "textarea" } function Ef(e, n, o, a) { Lo(a), n = es(n, "onChange"), 0 < n.length && (o = new Aa("onChange", "change", null, o, a), e.push({ event: o, listeners: n })) } var Li = null, Di = null; function Iv(e) { Bf(e, 0) } function Qo(e) { var n = Lr(e); if (Z(n)) return e } function _v(e, n) { if (e === "change") return n } var Cf = !1; if (d) { var Ia; if (d) { var _a = "oninput" in document; if (!_a) { var Pf = document.createElement("div"); Pf.setAttribute("oninput", "return;"), _a = typeof Pf.oninput == "function" } Ia = _a } else Ia = !1; Cf = Ia && (!document.documentMode || 9 < document.documentMode) } function Tf() { Li && (Li.detachEvent("onpropertychange", Nf), Di = Li = null) } function Nf(e) { if (e.propertyName === "value" && Qo(Di)) { var n = []; Ef(n, Di, e, Pr(e)), Kc(Iv, n) } } function Ov(e, n, o) { e === "focusin" ? (Tf(), Li = n, Di = o, Li.attachEvent("onpropertychange", Nf)) : e === "focusout" && Tf() } function zv(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return Qo(Di) } function Bv(e, n) { if (e === "click") return Qo(n) } function Uv(e, n) { if (e === "input" || e === "change") return Qo(n) } function $v(e, n) { return e === n && (e !== 0 || 1 / e === 1 / n) || e !== e && n !== n } var $t = typeof Object.is == "function" ? Object.is : $v; function Fi(e, n) { if ($t(e, n)) return !0; if (typeof e != "object" || e === null || typeof n != "object" || n === null) return !1; var o = Object.keys(e), a = Object.keys(n); if (o.length !== a.length) return !1; for (a = 0; a < o.length; a++) { var f = o[a]; if (!h.call(n, f) || !$t(e[f], n[f])) return !1 } return !0 } function bf(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function Rf(e, n) { var o = bf(e); e = 0; for (var a; o;) { if (o.nodeType === 3) { if (a = e + o.textContent.length, e <= n && a >= n) return { node: o, offset: n - e }; e = a } e: { for (; o;) { if (o.nextSibling) { o = o.nextSibling; break e } o = o.parentNode } o = void 0 } o = bf(o) } } function jf(e, n) { return e && n ? e === n ? !0 : e && e.nodeType === 3 ? !1 : n && n.nodeType === 3 ? jf(e, n.parentNode) : "contains" in e ? e.contains(n) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(n) & 16) : !1 : !1 } function Af() { for (var e = window, n = be(); n instanceof e.HTMLIFrameElement;) { try { var o = typeof n.contentWindow.location.href == "string" } catch { o = !1 } if (o) e = n.contentWindow; else break; n = be(e.document) } return n } function Oa(e) { var n = e && e.nodeName && e.nodeName.toLowerCase(); return n && (n === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || n === "textarea" || e.contentEditable === "true") } function Wv(e) { var n = Af(), o = e.focusedElem, a = e.selectionRange; if (n !== o && o && o.ownerDocument && jf(o.ownerDocument.documentElement, o)) { if (a !== null && Oa(o)) { if (n = a.start, e = a.end, e === void 0 && (e = n), "selectionStart" in o) o.selectionStart = n, o.selectionEnd = Math.min(e, o.value.length); else if (e = (n = o.ownerDocument || document) && n.defaultView || window, e.getSelection) { e = e.getSelection(); var f = o.textContent.length, p = Math.min(a.start, f); a = a.end === void 0 ? p : Math.min(a.end, f), !e.extend && p > a && (f = a, a = p, p = f), f = Rf(o, p); var y = Rf(o, a); f && y && (e.rangeCount !== 1 || e.anchorNode !== f.node || e.anchorOffset !== f.offset || e.focusNode !== y.node || e.focusOffset !== y.offset) && (n = n.createRange(), n.setStart(f.node, f.offset), e.removeAllRanges(), p > a ? (e.addRange(n), e.extend(y.node, y.offset)) : (n.setEnd(y.node, y.offset), e.addRange(n))) } } for (n = [], e = o; e = e.parentNode;)e.nodeType === 1 && n.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof o.focus == "function" && o.focus(), o = 0; o < n.length; o++)e = n[o], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var Hv = d && "documentMode" in document && 11 >= document.documentMode, Rr = null, za = null, Vi = null, Ba = !1; function Mf(e, n, o) { var a = o.window === o ? o.document : o.nodeType === 9 ? o : o.ownerDocument; Ba || Rr == null || Rr !== be(a) || (a = Rr, "selectionStart" in a && Oa(a) ? a = { start: a.selectionStart, end: a.selectionEnd } : (a = (a.ownerDocument && a.ownerDocument.defaultView || window).getSelection(), a = { anchorNode: a.anchorNode, anchorOffset: a.anchorOffset, focusNode: a.focusNode, focusOffset: a.focusOffset }), Vi && Fi(Vi, a) || (Vi = a, a = es(za, "onSelect"), 0 < a.length && (n = new Aa("onSelect", "select", null, n, o), e.push({ event: n, listeners: a }), n.target = Rr))) } function qo(e, n) { var o = {}; return o[e.toLowerCase()] = n.toLowerCase(), o["Webkit" + e] = "webkit" + n, o["Moz" + e] = "moz" + n, o } var jr = { animationend: qo("Animation", "AnimationEnd"), animationiteration: qo("Animation", "AnimationIteration"), animationstart: qo("Animation", "AnimationStart"), transitionend: qo("Transition", "TransitionEnd") }, Ua = {}, Lf = {}; d && (Lf = document.createElement("div").style, "AnimationEvent" in window || (delete jr.animationend.animation, delete jr.animationiteration.animation, delete jr.animationstart.animation), "TransitionEvent" in window || delete jr.transitionend.transition); function Zo(e) { if (Ua[e]) return Ua[e]; if (!jr[e]) return e; var n = jr[e], o; for (o in n) if (n.hasOwnProperty(o) && o in Lf) return Ua[e] = n[o]; return e } var Df = Zo("animationend"), Ff = Zo("animationiteration"), Vf = Zo("animationstart"), If = Zo("transitionend"), _f = new Map, Of = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Mn(e, n) { _f.set(e, n), c(n, [e]) } for (var $a = 0; $a < Of.length; $a++) { var Wa = Of[$a], Kv = Wa.toLowerCase(), Gv = Wa[0].toUpperCase() + Wa.slice(1); Mn(Kv, "on" + Gv) } Mn(Df, "onAnimationEnd"), Mn(Ff, "onAnimationIteration"), Mn(Vf, "onAnimationStart"), Mn("dblclick", "onDoubleClick"), Mn("focusin", "onFocus"), Mn("focusout", "onBlur"), Mn(If, "onTransitionEnd"), u("onMouseEnter", ["mouseout", "mouseover"]), u("onMouseLeave", ["mouseout", "mouseover"]), u("onPointerEnter", ["pointerout", "pointerover"]), u("onPointerLeave", ["pointerout", "pointerover"]), c("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), c("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), c("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), c("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), c("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), c("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Ii = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Yv = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ii)); function zf(e, n, o) { var a = e.type || "unknown-event"; e.currentTarget = o, Ky(a, n, void 0, e), e.currentTarget = null } function Bf(e, n) { n = (n & 4) !== 0; for (var o = 0; o < e.length; o++) { var a = e[o], f = a.event; a = a.listeners; e: { var p = void 0; if (n) for (var y = a.length - 1; 0 <= y; y--) { var S = a[y], T = S.instance, F = S.currentTarget; if (S = S.listener, T !== p && f.isPropagationStopped()) break e; zf(f, S, F), p = T } else for (y = 0; y < a.length; y++) { if (S = a[y], T = S.instance, F = S.currentTarget, S = S.listener, T !== p && f.isPropagationStopped()) break e; zf(f, S, F), p = T } } } if (Vo) throw e = Sa, Vo = !1, Sa = null, e } function Le(e, n) { var o = n[Za]; o === void 0 && (o = n[Za] = new Set); var a = e + "__bubble"; o.has(a) || (Uf(n, e, 2, !1), o.add(a)) } function Ha(e, n, o) { var a = 0; n && (a |= 4), Uf(o, e, a, n) } var Jo = "_reactListening" + Math.random().toString(36).slice(2); function _i(e) { if (!e[Jo]) { e[Jo] = !0, s.forEach(function (o) { o !== "selectionchange" && (Yv.has(o) || Ha(o, !1, e), Ha(o, !0, e)) }); var n = e.nodeType === 9 ? e : e.ownerDocument; n === null || n[Jo] || (n[Jo] = !0, Ha("selectionchange", !1, n)) } } function Uf(e, n, o, a) { switch (ff(n)) { case 1: var f = lv; break; case 4: f = uv; break; default: f = ba }o = f.bind(null, n, o, e), f = void 0, !wa || n !== "touchstart" && n !== "touchmove" && n !== "wheel" || (f = !0), a ? f !== void 0 ? e.addEventListener(n, o, { capture: !0, passive: f }) : e.addEventListener(n, o, !0) : f !== void 0 ? e.addEventListener(n, o, { passive: f }) : e.addEventListener(n, o, !1) } function Ka(e, n, o, a, f) { var p = a; if ((n & 1) === 0 && (n & 2) === 0 && a !== null) e: for (; ;) { if (a === null) return; var y = a.tag; if (y === 3 || y === 4) { var S = a.stateNode.containerInfo; if (S === f || S.nodeType === 8 && S.parentNode === f) break; if (y === 4) for (y = a.return; y !== null;) { var T = y.tag; if ((T === 3 || T === 4) && (T = y.stateNode.containerInfo, T === f || T.nodeType === 8 && T.parentNode === f)) return; y = y.return } for (; S !== null;) { if (y = er(S), y === null) return; if (T = y.tag, T === 5 || T === 6) { a = p = y; continue e } S = S.parentNode } } a = a.return } Kc(function () { var F = p, B = Pr(o), $ = []; e: { var z = _f.get(e); if (z !== void 0) { var X = Aa, J = e; switch (e) { case "keypress": if (Go(o) === 0) break e; case "keydown": case "keyup": X = Cv; break; case "focusin": J = "focus", X = Da; break; case "focusout": J = "blur", X = Da; break; case "beforeblur": case "afterblur": X = Da; break; case "click": if (o.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": X = pf; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": X = dv; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": X = Nv; break; case Df: case Ff: case Vf: X = mv; break; case If: X = Rv; break; case "scroll": X = cv; break; case "wheel": X = Av; break; case "copy": case "cut": case "paste": X = yv; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": X = gf }var re = (n & 4) !== 0, Ke = !re && e === "scroll", M = re ? z !== null ? z + "Capture" : null : z; re = []; for (var R = F, D; R !== null;) { D = R; var W = D.stateNode; if (D.tag === 5 && W !== null && (D = W, M !== null && (W = wi(R, M), W != null && re.push(Oi(R, W, D)))), Ke) break; R = R.return } 0 < re.length && (z = new X(z, J, null, o, B), $.push({ event: z, listeners: re })) } } if ((n & 7) === 0) { e: { if (z = e === "mouseover" || e === "pointerover", X = e === "mouseout" || e === "pointerout", z && o !== mi && (J = o.relatedTarget || o.fromElement) && (er(J) || J[hn])) break e; if ((X || z) && (z = B.window === B ? B : (z = B.ownerDocument) ? z.defaultView || z.parentWindow : window, X ? (J = o.relatedTarget || o.toElement, X = F, J = J ? er(J) : null, J !== null && (Ke = Jn(J), J !== Ke || J.tag !== 5 && J.tag !== 6) && (J = null)) : (X = null, J = F), X !== J)) { if (re = pf, W = "onMouseLeave", M = "onMouseEnter", R = "mouse", (e === "pointerout" || e === "pointerover") && (re = gf, W = "onPointerLeave", M = "onPointerEnter", R = "pointer"), Ke = X == null ? z : Lr(X), D = J == null ? z : Lr(J), z = new re(W, R + "leave", X, o, B), z.target = Ke, z.relatedTarget = D, W = null, er(B) === F && (re = new re(M, R + "enter", J, o, B), re.target = D, re.relatedTarget = Ke, W = re), Ke = W, X && J) t: { for (re = X, M = J, R = 0, D = re; D; D = Ar(D))R++; for (D = 0, W = M; W; W = Ar(W))D++; for (; 0 < R - D;)re = Ar(re), R--; for (; 0 < D - R;)M = Ar(M), D--; for (; R--;) { if (re === M || M !== null && re === M.alternate) break t; re = Ar(re), M = Ar(M) } re = null } else re = null; X !== null && $f($, z, X, re, !1), J !== null && Ke !== null && $f($, Ke, J, re, !0) } } e: { if (z = F ? Lr(F) : window, X = z.nodeName && z.nodeName.toLowerCase(), X === "select" || X === "input" && z.type === "file") var oe = _v; else if (kf(z)) if (Cf) oe = Uv; else { oe = zv; var ue = Ov } else (X = z.nodeName) && X.toLowerCase() === "input" && (z.type === "checkbox" || z.type === "radio") && (oe = Bv); if (oe && (oe = oe(e, F))) { Ef($, oe, o, B); break e } ue && ue(e, z, F), e === "focusout" && (ue = z._wrapperState) && ue.controlled && z.type === "number" && Rt(z, "number", z.value) } switch (ue = F ? Lr(F) : window, e) { case "focusin": (kf(ue) || ue.contentEditable === "true") && (Rr = ue, za = F, Vi = null); break; case "focusout": Vi = za = Rr = null; break; case "mousedown": Ba = !0; break; case "contextmenu": case "mouseup": case "dragend": Ba = !1, Mf($, o, B); break; case "selectionchange": if (Hv) break; case "keydown": case "keyup": Mf($, o, B) }var ce; if (Va) e: { switch (e) { case "compositionstart": var he = "onCompositionStart"; break e; case "compositionend": he = "onCompositionEnd"; break e; case "compositionupdate": he = "onCompositionUpdate"; break e }he = void 0 } else br ? wf(e, o) && (he = "onCompositionEnd") : e === "keydown" && o.keyCode === 229 && (he = "onCompositionStart"); he && (yf && o.locale !== "ko" && (br || he !== "onCompositionStart" ? he === "onCompositionEnd" && br && (ce = df()) : (An = B, ja = "value" in An ? An.value : An.textContent, br = !0)), ue = es(F, he), 0 < ue.length && (he = new mf(he, e, null, o, B), $.push({ event: he, listeners: ue }), ce ? he.data = ce : (ce = Sf(o), ce !== null && (he.data = ce)))), (ce = Lv ? Dv(e, o) : Fv(e, o)) && (F = es(F, "onBeforeInput"), 0 < F.length && (B = new mf("onBeforeInput", "beforeinput", null, o, B), $.push({ event: B, listeners: F }), B.data = ce)) } Bf($, n) }) } function Oi(e, n, o) { return { instance: e, listener: n, currentTarget: o } } function es(e, n) { for (var o = n + "Capture", a = []; e !== null;) { var f = e, p = f.stateNode; f.tag === 5 && p !== null && (f = p, p = wi(e, o), p != null && a.unshift(Oi(e, p, f)), p = wi(e, n), p != null && a.push(Oi(e, p, f))), e = e.return } return a } function Ar(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function $f(e, n, o, a, f) { for (var p = n._reactName, y = []; o !== null && o !== a;) { var S = o, T = S.alternate, F = S.stateNode; if (T !== null && T === a) break; S.tag === 5 && F !== null && (S = F, f ? (T = wi(o, p), T != null && y.unshift(Oi(o, T, S))) : f || (T = wi(o, p), T != null && y.push(Oi(o, T, S)))), o = o.return } y.length !== 0 && e.push({ event: n, listeners: y }) } var Xv = /\r\n?/g, Qv = /\u0000|\uFFFD/g; function Wf(e) {
    return (typeof e == "string" ? e : "" + e).replace(Xv, `
`).replace(Qv, "")
  } function ts(e, n, o) { if (n = Wf(n), Wf(e) !== n && o) throw Error(i(425)) } function ns() { } var Ga = null, Ya = null; function Xa(e, n) { return e === "textarea" || e === "noscript" || typeof n.children == "string" || typeof n.children == "number" || typeof n.dangerouslySetInnerHTML == "object" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null } var Qa = typeof setTimeout == "function" ? setTimeout : void 0, qv = typeof clearTimeout == "function" ? clearTimeout : void 0, Hf = typeof Promise == "function" ? Promise : void 0, Zv = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function (e) { return Hf.resolve(null).then(e).catch(Jv) } : Qa; function Jv(e) { setTimeout(function () { throw e }) } function qa(e, n) { var o = n, a = 0; do { var f = o.nextSibling; if (e.removeChild(o), f && f.nodeType === 8) if (o = f.data, o === "/$") { if (a === 0) { e.removeChild(f), Ri(n); return } a-- } else o !== "$" && o !== "$?" && o !== "$!" || a++; o = f } while (o); Ri(n) } function Ln(e) { for (; e != null; e = e.nextSibling) { var n = e.nodeType; if (n === 1 || n === 3) break; if (n === 8) { if (n = e.data, n === "$" || n === "$!" || n === "$?") break; if (n === "/$") return null } } return e } function Kf(e) { e = e.previousSibling; for (var n = 0; e;) { if (e.nodeType === 8) { var o = e.data; if (o === "$" || o === "$!" || o === "$?") { if (n === 0) return e; n-- } else o === "/$" && n++ } e = e.previousSibling } return null } var Mr = Math.random().toString(36).slice(2), nn = "__reactFiber$" + Mr, zi = "__reactProps$" + Mr, hn = "__reactContainer$" + Mr, Za = "__reactEvents$" + Mr, e0 = "__reactListeners$" + Mr, t0 = "__reactHandles$" + Mr; function er(e) { var n = e[nn]; if (n) return n; for (var o = e.parentNode; o;) { if (n = o[hn] || o[nn]) { if (o = n.alternate, n.child !== null || o !== null && o.child !== null) for (e = Kf(e); e !== null;) { if (o = e[nn]) return o; e = Kf(e) } return n } e = o, o = e.parentNode } return null } function Bi(e) { return e = e[nn] || e[hn], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function Lr(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(i(33)) } function rs(e) { return e[zi] || null } var Ja = [], Dr = -1; function Dn(e) { return { current: e } } function De(e) { 0 > Dr || (e.current = Ja[Dr], Ja[Dr] = null, Dr--) } function Me(e, n) { Dr++, Ja[Dr] = e.current, e.current = n } var Fn = {}, at = Dn(Fn), mt = Dn(!1), tr = Fn; function Fr(e, n) { var o = e.type.contextTypes; if (!o) return Fn; var a = e.stateNode; if (a && a.__reactInternalMemoizedUnmaskedChildContext === n) return a.__reactInternalMemoizedMaskedChildContext; var f = {}, p; for (p in o) f[p] = n[p]; return a && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = n, e.__reactInternalMemoizedMaskedChildContext = f), f } function gt(e) { return e = e.childContextTypes, e != null } function is() { De(mt), De(at) } function Gf(e, n, o) { if (at.current !== Fn) throw Error(i(168)); Me(at, n), Me(mt, o) } function Yf(e, n, o) { var a = e.stateNode; if (n = n.childContextTypes, typeof a.getChildContext != "function") return o; a = a.getChildContext(); for (var f in a) if (!(f in n)) throw Error(i(108, se(e) || "Unknown", f)); return G({}, o, a) } function os(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Fn, tr = at.current, Me(at, e), Me(mt, mt.current), !0 } function Xf(e, n, o) { var a = e.stateNode; if (!a) throw Error(i(169)); o ? (e = Yf(e, n, tr), a.__reactInternalMemoizedMergedChildContext = e, De(mt), De(at), Me(at, e)) : De(mt), Me(mt, o) } var pn = null, ss = !1, el = !1; function Qf(e) { pn === null ? pn = [e] : pn.push(e) } function n0(e) { ss = !0, Qf(e) } function Vn() { if (!el && pn !== null) { el = !0; var e = 0, n = Ae; try { var o = pn; for (Ae = 1; e < o.length; e++) { var a = o[e]; do a = a(!0); while (a !== null) } pn = null, ss = !1 } catch (f) { throw pn !== null && (pn = pn.slice(e + 1)), qc(ka, Vn), f } finally { Ae = n, el = !1 } } return null } var Vr = [], Ir = 0, as = null, ls = 0, Mt = [], Lt = 0, nr = null, mn = 1, gn = ""; function rr(e, n) { Vr[Ir++] = ls, Vr[Ir++] = as, as = e, ls = n } function qf(e, n, o) { Mt[Lt++] = mn, Mt[Lt++] = gn, Mt[Lt++] = nr, nr = e; var a = mn; e = gn; var f = 32 - Ut(a) - 1; a &= ~(1 << f), o += 1; var p = 32 - Ut(n) + f; if (30 < p) { var y = f - f % 5; p = (a & (1 << y) - 1).toString(32), a >>= y, f -= y, mn = 1 << 32 - Ut(n) + f | o << f | a, gn = p + e } else mn = 1 << p | o << f | a, gn = e } function tl(e) { e.return !== null && (rr(e, 1), qf(e, 1, 0)) } function nl(e) { for (; e === as;)as = Vr[--Ir], Vr[Ir] = null, ls = Vr[--Ir], Vr[Ir] = null; for (; e === nr;)nr = Mt[--Lt], Mt[Lt] = null, gn = Mt[--Lt], Mt[Lt] = null, mn = Mt[--Lt], Mt[Lt] = null } var Tt = null, Nt = null, Ve = !1, Wt = null; function Zf(e, n) { var o = It(5, null, null, 0); o.elementType = "DELETED", o.stateNode = n, o.return = e, n = e.deletions, n === null ? (e.deletions = [o], e.flags |= 16) : n.push(o) } function Jf(e, n) { switch (e.tag) { case 5: var o = e.type; return n = n.nodeType !== 1 || o.toLowerCase() !== n.nodeName.toLowerCase() ? null : n, n !== null ? (e.stateNode = n, Tt = e, Nt = Ln(n.firstChild), !0) : !1; case 6: return n = e.pendingProps === "" || n.nodeType !== 3 ? null : n, n !== null ? (e.stateNode = n, Tt = e, Nt = null, !0) : !1; case 13: return n = n.nodeType !== 8 ? null : n, n !== null ? (o = nr !== null ? { id: mn, overflow: gn } : null, e.memoizedState = { dehydrated: n, treeContext: o, retryLane: 1073741824 }, o = It(18, null, null, 0), o.stateNode = n, o.return = e, e.child = o, Tt = e, Nt = null, !0) : !1; default: return !1 } } function rl(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function il(e) { if (Ve) { var n = Nt; if (n) { var o = n; if (!Jf(e, n)) { if (rl(e)) throw Error(i(418)); n = Ln(o.nextSibling); var a = Tt; n && Jf(e, n) ? Zf(a, o) : (e.flags = e.flags & -4097 | 2, Ve = !1, Tt = e) } } else { if (rl(e)) throw Error(i(418)); e.flags = e.flags & -4097 | 2, Ve = !1, Tt = e } } } function ed(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; Tt = e } function us(e) { if (e !== Tt) return !1; if (!Ve) return ed(e), Ve = !0, !1; var n; if ((n = e.tag !== 3) && !(n = e.tag !== 5) && (n = e.type, n = n !== "head" && n !== "body" && !Xa(e.type, e.memoizedProps)), n && (n = Nt)) { if (rl(e)) throw td(), Error(i(418)); for (; n;)Zf(e, n), n = Ln(n.nextSibling) } if (ed(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(i(317)); e: { for (e = e.nextSibling, n = 0; e;) { if (e.nodeType === 8) { var o = e.data; if (o === "/$") { if (n === 0) { Nt = Ln(e.nextSibling); break e } n-- } else o !== "$" && o !== "$!" && o !== "$?" || n++ } e = e.nextSibling } Nt = null } } else Nt = Tt ? Ln(e.stateNode.nextSibling) : null; return !0 } function td() { for (var e = Nt; e;)e = Ln(e.nextSibling) } function _r() { Nt = Tt = null, Ve = !1 } function ol(e) { Wt === null ? Wt = [e] : Wt.push(e) } var r0 = U.ReactCurrentBatchConfig; function Ui(e, n, o) { if (e = o.ref, e !== null && typeof e != "function" && typeof e != "object") { if (o._owner) { if (o = o._owner, o) { if (o.tag !== 1) throw Error(i(309)); var a = o.stateNode } if (!a) throw Error(i(147, e)); var f = a, p = "" + e; return n !== null && n.ref !== null && typeof n.ref == "function" && n.ref._stringRef === p ? n.ref : (n = function (y) { var S = f.refs; y === null ? delete S[p] : S[p] = y }, n._stringRef = p, n) } if (typeof e != "string") throw Error(i(284)); if (!o._owner) throw Error(i(290, e)) } return e } function cs(e, n) { throw e = Object.prototype.toString.call(n), Error(i(31, e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e)) } function nd(e) { var n = e._init; return n(e._payload) } function rd(e) { function n(M, R) { if (e) { var D = M.deletions; D === null ? (M.deletions = [R], M.flags |= 16) : D.push(R) } } function o(M, R) { if (!e) return null; for (; R !== null;)n(M, R), R = R.sibling; return null } function a(M, R) { for (M = new Map; R !== null;)R.key !== null ? M.set(R.key, R) : M.set(R.index, R), R = R.sibling; return M } function f(M, R) { return M = Wn(M, R), M.index = 0, M.sibling = null, M } function p(M, R, D) { return M.index = D, e ? (D = M.alternate, D !== null ? (D = D.index, D < R ? (M.flags |= 2, R) : D) : (M.flags |= 2, R)) : (M.flags |= 1048576, R) } function y(M) { return e && M.alternate === null && (M.flags |= 2), M } function S(M, R, D, W) { return R === null || R.tag !== 6 ? (R = Ql(D, M.mode, W), R.return = M, R) : (R = f(R, D), R.return = M, R) } function T(M, R, D, W) { var oe = D.type; return oe === K ? B(M, R, D.props.children, W, D.key) : R !== null && (R.elementType === oe || typeof oe == "object" && oe !== null && oe.$$typeof === ke && nd(oe) === R.type) ? (W = f(R, D.props), W.ref = Ui(M, R, D), W.return = M, W) : (W = Ds(D.type, D.key, D.props, null, M.mode, W), W.ref = Ui(M, R, D), W.return = M, W) } function F(M, R, D, W) { return R === null || R.tag !== 4 || R.stateNode.containerInfo !== D.containerInfo || R.stateNode.implementation !== D.implementation ? (R = ql(D, M.mode, W), R.return = M, R) : (R = f(R, D.children || []), R.return = M, R) } function B(M, R, D, W, oe) { return R === null || R.tag !== 7 ? (R = fr(D, M.mode, W, oe), R.return = M, R) : (R = f(R, D), R.return = M, R) } function $(M, R, D) { if (typeof R == "string" && R !== "" || typeof R == "number") return R = Ql("" + R, M.mode, D), R.return = M, R; if (typeof R == "object" && R !== null) { switch (R.$$typeof) { case O: return D = Ds(R.type, R.key, R.props, null, M.mode, D), D.ref = Ui(M, null, R), D.return = M, D; case H: return R = ql(R, M.mode, D), R.return = M, R; case ke: var W = R._init; return $(M, W(R._payload), D) }if (Ct(R) || Y(R)) return R = fr(R, M.mode, D, null), R.return = M, R; cs(M, R) } return null } function z(M, R, D, W) { var oe = R !== null ? R.key : null; if (typeof D == "string" && D !== "" || typeof D == "number") return oe !== null ? null : S(M, R, "" + D, W); if (typeof D == "object" && D !== null) { switch (D.$$typeof) { case O: return D.key === oe ? T(M, R, D, W) : null; case H: return D.key === oe ? F(M, R, D, W) : null; case ke: return oe = D._init, z(M, R, oe(D._payload), W) }if (Ct(D) || Y(D)) return oe !== null ? null : B(M, R, D, W, null); cs(M, D) } return null } function X(M, R, D, W, oe) { if (typeof W == "string" && W !== "" || typeof W == "number") return M = M.get(D) || null, S(R, M, "" + W, oe); if (typeof W == "object" && W !== null) { switch (W.$$typeof) { case O: return M = M.get(W.key === null ? D : W.key) || null, T(R, M, W, oe); case H: return M = M.get(W.key === null ? D : W.key) || null, F(R, M, W, oe); case ke: var ue = W._init; return X(M, R, D, ue(W._payload), oe) }if (Ct(W) || Y(W)) return M = M.get(D) || null, B(R, M, W, oe, null); cs(R, W) } return null } function J(M, R, D, W) { for (var oe = null, ue = null, ce = R, he = R = 0, rt = null; ce !== null && he < D.length; he++) { ce.index > he ? (rt = ce, ce = null) : rt = ce.sibling; var Pe = z(M, ce, D[he], W); if (Pe === null) { ce === null && (ce = rt); break } e && ce && Pe.alternate === null && n(M, ce), R = p(Pe, R, he), ue === null ? oe = Pe : ue.sibling = Pe, ue = Pe, ce = rt } if (he === D.length) return o(M, ce), Ve && rr(M, he), oe; if (ce === null) { for (; he < D.length; he++)ce = $(M, D[he], W), ce !== null && (R = p(ce, R, he), ue === null ? oe = ce : ue.sibling = ce, ue = ce); return Ve && rr(M, he), oe } for (ce = a(M, ce); he < D.length; he++)rt = X(ce, M, he, D[he], W), rt !== null && (e && rt.alternate !== null && ce.delete(rt.key === null ? he : rt.key), R = p(rt, R, he), ue === null ? oe = rt : ue.sibling = rt, ue = rt); return e && ce.forEach(function (Hn) { return n(M, Hn) }), Ve && rr(M, he), oe } function re(M, R, D, W) { var oe = Y(D); if (typeof oe != "function") throw Error(i(150)); if (D = oe.call(D), D == null) throw Error(i(151)); for (var ue = oe = null, ce = R, he = R = 0, rt = null, Pe = D.next(); ce !== null && !Pe.done; he++, Pe = D.next()) { ce.index > he ? (rt = ce, ce = null) : rt = ce.sibling; var Hn = z(M, ce, Pe.value, W); if (Hn === null) { ce === null && (ce = rt); break } e && ce && Hn.alternate === null && n(M, ce), R = p(Hn, R, he), ue === null ? oe = Hn : ue.sibling = Hn, ue = Hn, ce = rt } if (Pe.done) return o(M, ce), Ve && rr(M, he), oe; if (ce === null) { for (; !Pe.done; he++, Pe = D.next())Pe = $(M, Pe.value, W), Pe !== null && (R = p(Pe, R, he), ue === null ? oe = Pe : ue.sibling = Pe, ue = Pe); return Ve && rr(M, he), oe } for (ce = a(M, ce); !Pe.done; he++, Pe = D.next())Pe = X(ce, M, he, Pe.value, W), Pe !== null && (e && Pe.alternate !== null && ce.delete(Pe.key === null ? he : Pe.key), R = p(Pe, R, he), ue === null ? oe = Pe : ue.sibling = Pe, ue = Pe); return e && ce.forEach(function (V0) { return n(M, V0) }), Ve && rr(M, he), oe } function Ke(M, R, D, W) { if (typeof D == "object" && D !== null && D.type === K && D.key === null && (D = D.props.children), typeof D == "object" && D !== null) { switch (D.$$typeof) { case O: e: { for (var oe = D.key, ue = R; ue !== null;) { if (ue.key === oe) { if (oe = D.type, oe === K) { if (ue.tag === 7) { o(M, ue.sibling), R = f(ue, D.props.children), R.return = M, M = R; break e } } else if (ue.elementType === oe || typeof oe == "object" && oe !== null && oe.$$typeof === ke && nd(oe) === ue.type) { o(M, ue.sibling), R = f(ue, D.props), R.ref = Ui(M, ue, D), R.return = M, M = R; break e } o(M, ue); break } else n(M, ue); ue = ue.sibling } D.type === K ? (R = fr(D.props.children, M.mode, W, D.key), R.return = M, M = R) : (W = Ds(D.type, D.key, D.props, null, M.mode, W), W.ref = Ui(M, R, D), W.return = M, M = W) } return y(M); case H: e: { for (ue = D.key; R !== null;) { if (R.key === ue) if (R.tag === 4 && R.stateNode.containerInfo === D.containerInfo && R.stateNode.implementation === D.implementation) { o(M, R.sibling), R = f(R, D.children || []), R.return = M, M = R; break e } else { o(M, R); break } else n(M, R); R = R.sibling } R = ql(D, M.mode, W), R.return = M, M = R } return y(M); case ke: return ue = D._init, Ke(M, R, ue(D._payload), W) }if (Ct(D)) return J(M, R, D, W); if (Y(D)) return re(M, R, D, W); cs(M, D) } return typeof D == "string" && D !== "" || typeof D == "number" ? (D = "" + D, R !== null && R.tag === 6 ? (o(M, R.sibling), R = f(R, D), R.return = M, M = R) : (o(M, R), R = Ql(D, M.mode, W), R.return = M, M = R), y(M)) : o(M, R) } return Ke } var Or = rd(!0), id = rd(!1), fs = Dn(null), ds = null, zr = null, sl = null; function al() { sl = zr = ds = null } function ll(e) { var n = fs.current; De(fs), e._currentValue = n } function ul(e, n, o) { for (; e !== null;) { var a = e.alternate; if ((e.childLanes & n) !== n ? (e.childLanes |= n, a !== null && (a.childLanes |= n)) : a !== null && (a.childLanes & n) !== n && (a.childLanes |= n), e === o) break; e = e.return } } function Br(e, n) { ds = e, sl = zr = null, e = e.dependencies, e !== null && e.firstContext !== null && ((e.lanes & n) !== 0 && (yt = !0), e.firstContext = null) } function Dt(e) { var n = e._currentValue; if (sl !== e) if (e = { context: e, memoizedValue: n, next: null }, zr === null) { if (ds === null) throw Error(i(308)); zr = e, ds.dependencies = { lanes: 0, firstContext: e } } else zr = zr.next = e; return n } var ir = null; function cl(e) { ir === null ? ir = [e] : ir.push(e) } function od(e, n, o, a) { var f = n.interleaved; return f === null ? (o.next = o, cl(n)) : (o.next = f.next, f.next = o), n.interleaved = o, yn(e, a) } function yn(e, n) { e.lanes |= n; var o = e.alternate; for (o !== null && (o.lanes |= n), o = e, e = e.return; e !== null;)e.childLanes |= n, o = e.alternate, o !== null && (o.childLanes |= n), o = e, e = e.return; return o.tag === 3 ? o.stateNode : null } var In = !1; function fl(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function sd(e, n) { e = e.updateQueue, n.updateQueue === e && (n.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function vn(e, n) { return { eventTime: e, lane: n, tag: 0, payload: null, callback: null, next: null } } function _n(e, n, o) { var a = e.updateQueue; if (a === null) return null; if (a = a.shared, (Ee & 2) !== 0) { var f = a.pending; return f === null ? n.next = n : (n.next = f.next, f.next = n), a.pending = n, yn(e, o) } return f = a.interleaved, f === null ? (n.next = n, cl(a)) : (n.next = f.next, f.next = n), a.interleaved = n, yn(e, o) } function hs(e, n, o) { if (n = n.updateQueue, n !== null && (n = n.shared, (o & 4194240) !== 0)) { var a = n.lanes; a &= e.pendingLanes, o |= a, n.lanes = o, Pa(e, o) } } function ad(e, n) { var o = e.updateQueue, a = e.alternate; if (a !== null && (a = a.updateQueue, o === a)) { var f = null, p = null; if (o = o.firstBaseUpdate, o !== null) { do { var y = { eventTime: o.eventTime, lane: o.lane, tag: o.tag, payload: o.payload, callback: o.callback, next: null }; p === null ? f = p = y : p = p.next = y, o = o.next } while (o !== null); p === null ? f = p = n : p = p.next = n } else f = p = n; o = { baseState: a.baseState, firstBaseUpdate: f, lastBaseUpdate: p, shared: a.shared, effects: a.effects }, e.updateQueue = o; return } e = o.lastBaseUpdate, e === null ? o.firstBaseUpdate = n : e.next = n, o.lastBaseUpdate = n } function ps(e, n, o, a) { var f = e.updateQueue; In = !1; var p = f.firstBaseUpdate, y = f.lastBaseUpdate, S = f.shared.pending; if (S !== null) { f.shared.pending = null; var T = S, F = T.next; T.next = null, y === null ? p = F : y.next = F, y = T; var B = e.alternate; B !== null && (B = B.updateQueue, S = B.lastBaseUpdate, S !== y && (S === null ? B.firstBaseUpdate = F : S.next = F, B.lastBaseUpdate = T)) } if (p !== null) { var $ = f.baseState; y = 0, B = F = T = null, S = p; do { var z = S.lane, X = S.eventTime; if ((a & z) === z) { B !== null && (B = B.next = { eventTime: X, lane: 0, tag: S.tag, payload: S.payload, callback: S.callback, next: null }); e: { var J = e, re = S; switch (z = n, X = o, re.tag) { case 1: if (J = re.payload, typeof J == "function") { $ = J.call(X, $, z); break e } $ = J; break e; case 3: J.flags = J.flags & -65537 | 128; case 0: if (J = re.payload, z = typeof J == "function" ? J.call(X, $, z) : J, z == null) break e; $ = G({}, $, z); break e; case 2: In = !0 } } S.callback !== null && S.lane !== 0 && (e.flags |= 64, z = f.effects, z === null ? f.effects = [S] : z.push(S)) } else X = { eventTime: X, lane: z, tag: S.tag, payload: S.payload, callback: S.callback, next: null }, B === null ? (F = B = X, T = $) : B = B.next = X, y |= z; if (S = S.next, S === null) { if (S = f.shared.pending, S === null) break; z = S, S = z.next, z.next = null, f.lastBaseUpdate = z, f.shared.pending = null } } while (!0); if (B === null && (T = $), f.baseState = T, f.firstBaseUpdate = F, f.lastBaseUpdate = B, n = f.shared.interleaved, n !== null) { f = n; do y |= f.lane, f = f.next; while (f !== n) } else p === null && (f.shared.lanes = 0); ar |= y, e.lanes = y, e.memoizedState = $ } } function ld(e, n, o) { if (e = n.effects, n.effects = null, e !== null) for (n = 0; n < e.length; n++) { var a = e[n], f = a.callback; if (f !== null) { if (a.callback = null, a = o, typeof f != "function") throw Error(i(191, f)); f.call(a) } } } var $i = {}, rn = Dn($i), Wi = Dn($i), Hi = Dn($i); function or(e) { if (e === $i) throw Error(i(174)); return e } function dl(e, n) { switch (Me(Hi, n), Me(Wi, e), Me(rn, $i), e = n.nodeType, e) { case 9: case 11: n = (n = n.documentElement) ? n.namespaceURI : kr(null, ""); break; default: e = e === 8 ? n.parentNode : n, n = e.namespaceURI || null, e = e.tagName, n = kr(n, e) }De(rn), Me(rn, n) } function Ur() { De(rn), De(Wi), De(Hi) } function ud(e) { or(Hi.current); var n = or(rn.current), o = kr(n, e.type); n !== o && (Me(Wi, e), Me(rn, o)) } function hl(e) { Wi.current === e && (De(rn), De(Wi)) } var _e = Dn(0); function ms(e) { for (var n = e; n !== null;) { if (n.tag === 13) { var o = n.memoizedState; if (o !== null && (o = o.dehydrated, o === null || o.data === "$?" || o.data === "$!")) return n } else if (n.tag === 19 && n.memoizedProps.revealOrder !== void 0) { if ((n.flags & 128) !== 0) return n } else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return null; n = n.return } n.sibling.return = n.return, n = n.sibling } return null } var pl = []; function ml() { for (var e = 0; e < pl.length; e++)pl[e]._workInProgressVersionPrimary = null; pl.length = 0 } var gs = U.ReactCurrentDispatcher, gl = U.ReactCurrentBatchConfig, sr = 0, Oe = null, Xe = null, tt = null, ys = !1, Ki = !1, Gi = 0, i0 = 0; function lt() { throw Error(i(321)) } function yl(e, n) { if (n === null) return !1; for (var o = 0; o < n.length && o < e.length; o++)if (!$t(e[o], n[o])) return !1; return !0 } function vl(e, n, o, a, f, p) { if (sr = p, Oe = n, n.memoizedState = null, n.updateQueue = null, n.lanes = 0, gs.current = e === null || e.memoizedState === null ? l0 : u0, e = o(a, f), Ki) { p = 0; do { if (Ki = !1, Gi = 0, 25 <= p) throw Error(i(301)); p += 1, tt = Xe = null, n.updateQueue = null, gs.current = c0, e = o(a, f) } while (Ki) } if (gs.current = ws, n = Xe !== null && Xe.next !== null, sr = 0, tt = Xe = Oe = null, ys = !1, n) throw Error(i(300)); return e } function xl() { var e = Gi !== 0; return Gi = 0, e } function on() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return tt === null ? Oe.memoizedState = tt = e : tt = tt.next = e, tt } function Ft() { if (Xe === null) { var e = Oe.alternate; e = e !== null ? e.memoizedState : null } else e = Xe.next; var n = tt === null ? Oe.memoizedState : tt.next; if (n !== null) tt = n, Xe = e; else { if (e === null) throw Error(i(310)); Xe = e, e = { memoizedState: Xe.memoizedState, baseState: Xe.baseState, baseQueue: Xe.baseQueue, queue: Xe.queue, next: null }, tt === null ? Oe.memoizedState = tt = e : tt = tt.next = e } return tt } function Yi(e, n) { return typeof n == "function" ? n(e) : n } function wl(e) { var n = Ft(), o = n.queue; if (o === null) throw Error(i(311)); o.lastRenderedReducer = e; var a = Xe, f = a.baseQueue, p = o.pending; if (p !== null) { if (f !== null) { var y = f.next; f.next = p.next, p.next = y } a.baseQueue = f = p, o.pending = null } if (f !== null) { p = f.next, a = a.baseState; var S = y = null, T = null, F = p; do { var B = F.lane; if ((sr & B) === B) T !== null && (T = T.next = { lane: 0, action: F.action, hasEagerState: F.hasEagerState, eagerState: F.eagerState, next: null }), a = F.hasEagerState ? F.eagerState : e(a, F.action); else { var $ = { lane: B, action: F.action, hasEagerState: F.hasEagerState, eagerState: F.eagerState, next: null }; T === null ? (S = T = $, y = a) : T = T.next = $, Oe.lanes |= B, ar |= B } F = F.next } while (F !== null && F !== p); T === null ? y = a : T.next = S, $t(a, n.memoizedState) || (yt = !0), n.memoizedState = a, n.baseState = y, n.baseQueue = T, o.lastRenderedState = a } if (e = o.interleaved, e !== null) { f = e; do p = f.lane, Oe.lanes |= p, ar |= p, f = f.next; while (f !== e) } else f === null && (o.lanes = 0); return [n.memoizedState, o.dispatch] } function Sl(e) { var n = Ft(), o = n.queue; if (o === null) throw Error(i(311)); o.lastRenderedReducer = e; var a = o.dispatch, f = o.pending, p = n.memoizedState; if (f !== null) { o.pending = null; var y = f = f.next; do p = e(p, y.action), y = y.next; while (y !== f); $t(p, n.memoizedState) || (yt = !0), n.memoizedState = p, n.baseQueue === null && (n.baseState = p), o.lastRenderedState = p } return [p, a] } function cd() { } function fd(e, n) { var o = Oe, a = Ft(), f = n(), p = !$t(a.memoizedState, f); if (p && (a.memoizedState = f, yt = !0), a = a.queue, kl(pd.bind(null, o, a, e), [e]), a.getSnapshot !== n || p || tt !== null && tt.memoizedState.tag & 1) { if (o.flags |= 2048, Xi(9, hd.bind(null, o, a, f, n), void 0, null), nt === null) throw Error(i(349)); (sr & 30) !== 0 || dd(o, n, f) } return f } function dd(e, n, o) { e.flags |= 16384, e = { getSnapshot: n, value: o }, n = Oe.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, Oe.updateQueue = n, n.stores = [e]) : (o = n.stores, o === null ? n.stores = [e] : o.push(e)) } function hd(e, n, o, a) { n.value = o, n.getSnapshot = a, md(n) && gd(e) } function pd(e, n, o) { return o(function () { md(n) && gd(e) }) } function md(e) { var n = e.getSnapshot; e = e.value; try { var o = n(); return !$t(e, o) } catch { return !0 } } function gd(e) { var n = yn(e, 1); n !== null && Yt(n, e, 1, -1) } function yd(e) { var n = on(); return typeof e == "function" && (e = e()), n.memoizedState = n.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Yi, lastRenderedState: e }, n.queue = e, e = e.dispatch = a0.bind(null, Oe, e), [n.memoizedState, e] } function Xi(e, n, o, a) { return e = { tag: e, create: n, destroy: o, deps: a, next: null }, n = Oe.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, Oe.updateQueue = n, n.lastEffect = e.next = e) : (o = n.lastEffect, o === null ? n.lastEffect = e.next = e : (a = o.next, o.next = e, e.next = a, n.lastEffect = e)), e } function vd() { return Ft().memoizedState } function vs(e, n, o, a) { var f = on(); Oe.flags |= e, f.memoizedState = Xi(1 | n, o, void 0, a === void 0 ? null : a) } function xs(e, n, o, a) { var f = Ft(); a = a === void 0 ? null : a; var p = void 0; if (Xe !== null) { var y = Xe.memoizedState; if (p = y.destroy, a !== null && yl(a, y.deps)) { f.memoizedState = Xi(n, o, p, a); return } } Oe.flags |= e, f.memoizedState = Xi(1 | n, o, p, a) } function xd(e, n) { return vs(8390656, 8, e, n) } function kl(e, n) { return xs(2048, 8, e, n) } function wd(e, n) { return xs(4, 2, e, n) } function Sd(e, n) { return xs(4, 4, e, n) } function kd(e, n) { if (typeof n == "function") return e = e(), n(e), function () { n(null) }; if (n != null) return e = e(), n.current = e, function () { n.current = null } } function Ed(e, n, o) { return o = o != null ? o.concat([e]) : null, xs(4, 4, kd.bind(null, n, e), o) } function El() { } function Cd(e, n) { var o = Ft(); n = n === void 0 ? null : n; var a = o.memoizedState; return a !== null && n !== null && yl(n, a[1]) ? a[0] : (o.memoizedState = [e, n], e) } function Pd(e, n) { var o = Ft(); n = n === void 0 ? null : n; var a = o.memoizedState; return a !== null && n !== null && yl(n, a[1]) ? a[0] : (e = e(), o.memoizedState = [e, n], e) } function Td(e, n, o) { return (sr & 21) === 0 ? (e.baseState && (e.baseState = !1, yt = !0), e.memoizedState = o) : ($t(o, n) || (o = tf(), Oe.lanes |= o, ar |= o, e.baseState = !0), n) } function o0(e, n) { var o = Ae; Ae = o !== 0 && 4 > o ? o : 4, e(!0); var a = gl.transition; gl.transition = {}; try { e(!1), n() } finally { Ae = o, gl.transition = a } } function Nd() { return Ft().memoizedState } function s0(e, n, o) { var a = Un(e); if (o = { lane: a, action: o, hasEagerState: !1, eagerState: null, next: null }, bd(e)) Rd(n, o); else if (o = od(e, n, o, a), o !== null) { var f = ht(); Yt(o, e, a, f), jd(o, n, a) } } function a0(e, n, o) { var a = Un(e), f = { lane: a, action: o, hasEagerState: !1, eagerState: null, next: null }; if (bd(e)) Rd(n, f); else { var p = e.alternate; if (e.lanes === 0 && (p === null || p.lanes === 0) && (p = n.lastRenderedReducer, p !== null)) try { var y = n.lastRenderedState, S = p(y, o); if (f.hasEagerState = !0, f.eagerState = S, $t(S, y)) { var T = n.interleaved; T === null ? (f.next = f, cl(n)) : (f.next = T.next, T.next = f), n.interleaved = f; return } } catch { } finally { } o = od(e, n, f, a), o !== null && (f = ht(), Yt(o, e, a, f), jd(o, n, a)) } } function bd(e) { var n = e.alternate; return e === Oe || n !== null && n === Oe } function Rd(e, n) { Ki = ys = !0; var o = e.pending; o === null ? n.next = n : (n.next = o.next, o.next = n), e.pending = n } function jd(e, n, o) { if ((o & 4194240) !== 0) { var a = n.lanes; a &= e.pendingLanes, o |= a, n.lanes = o, Pa(e, o) } } var ws = { readContext: Dt, useCallback: lt, useContext: lt, useEffect: lt, useImperativeHandle: lt, useInsertionEffect: lt, useLayoutEffect: lt, useMemo: lt, useReducer: lt, useRef: lt, useState: lt, useDebugValue: lt, useDeferredValue: lt, useTransition: lt, useMutableSource: lt, useSyncExternalStore: lt, useId: lt, unstable_isNewReconciler: !1 }, l0 = { readContext: Dt, useCallback: function (e, n) { return on().memoizedState = [e, n === void 0 ? null : n], e }, useContext: Dt, useEffect: xd, useImperativeHandle: function (e, n, o) { return o = o != null ? o.concat([e]) : null, vs(4194308, 4, kd.bind(null, n, e), o) }, useLayoutEffect: function (e, n) { return vs(4194308, 4, e, n) }, useInsertionEffect: function (e, n) { return vs(4, 2, e, n) }, useMemo: function (e, n) { var o = on(); return n = n === void 0 ? null : n, e = e(), o.memoizedState = [e, n], e }, useReducer: function (e, n, o) { var a = on(); return n = o !== void 0 ? o(n) : n, a.memoizedState = a.baseState = n, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: n }, a.queue = e, e = e.dispatch = s0.bind(null, Oe, e), [a.memoizedState, e] }, useRef: function (e) { var n = on(); return e = { current: e }, n.memoizedState = e }, useState: yd, useDebugValue: El, useDeferredValue: function (e) { return on().memoizedState = e }, useTransition: function () { var e = yd(!1), n = e[0]; return e = o0.bind(null, e[1]), on().memoizedState = e, [n, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, n, o) { var a = Oe, f = on(); if (Ve) { if (o === void 0) throw Error(i(407)); o = o() } else { if (o = n(), nt === null) throw Error(i(349)); (sr & 30) !== 0 || dd(a, n, o) } f.memoizedState = o; var p = { value: o, getSnapshot: n }; return f.queue = p, xd(pd.bind(null, a, p, e), [e]), a.flags |= 2048, Xi(9, hd.bind(null, a, p, o, n), void 0, null), o }, useId: function () { var e = on(), n = nt.identifierPrefix; if (Ve) { var o = gn, a = mn; o = (a & ~(1 << 32 - Ut(a) - 1)).toString(32) + o, n = ":" + n + "R" + o, o = Gi++, 0 < o && (n += "H" + o.toString(32)), n += ":" } else o = i0++, n = ":" + n + "r" + o.toString(32) + ":"; return e.memoizedState = n }, unstable_isNewReconciler: !1 }, u0 = { readContext: Dt, useCallback: Cd, useContext: Dt, useEffect: kl, useImperativeHandle: Ed, useInsertionEffect: wd, useLayoutEffect: Sd, useMemo: Pd, useReducer: wl, useRef: vd, useState: function () { return wl(Yi) }, useDebugValue: El, useDeferredValue: function (e) { var n = Ft(); return Td(n, Xe.memoizedState, e) }, useTransition: function () { var e = wl(Yi)[0], n = Ft().memoizedState; return [e, n] }, useMutableSource: cd, useSyncExternalStore: fd, useId: Nd, unstable_isNewReconciler: !1 }, c0 = { readContext: Dt, useCallback: Cd, useContext: Dt, useEffect: kl, useImperativeHandle: Ed, useInsertionEffect: wd, useLayoutEffect: Sd, useMemo: Pd, useReducer: Sl, useRef: vd, useState: function () { return Sl(Yi) }, useDebugValue: El, useDeferredValue: function (e) { var n = Ft(); return Xe === null ? n.memoizedState = e : Td(n, Xe.memoizedState, e) }, useTransition: function () { var e = Sl(Yi)[0], n = Ft().memoizedState; return [e, n] }, useMutableSource: cd, useSyncExternalStore: fd, useId: Nd, unstable_isNewReconciler: !1 }; function Ht(e, n) { if (e && e.defaultProps) { n = G({}, n), e = e.defaultProps; for (var o in e) n[o] === void 0 && (n[o] = e[o]); return n } return n } function Cl(e, n, o, a) { n = e.memoizedState, o = o(a, n), o = o == null ? n : G({}, n, o), e.memoizedState = o, e.lanes === 0 && (e.updateQueue.baseState = o) } var Ss = { isMounted: function (e) { return (e = e._reactInternals) ? Jn(e) === e : !1 }, enqueueSetState: function (e, n, o) { e = e._reactInternals; var a = ht(), f = Un(e), p = vn(a, f); p.payload = n, o != null && (p.callback = o), n = _n(e, p, f), n !== null && (Yt(n, e, f, a), hs(n, e, f)) }, enqueueReplaceState: function (e, n, o) { e = e._reactInternals; var a = ht(), f = Un(e), p = vn(a, f); p.tag = 1, p.payload = n, o != null && (p.callback = o), n = _n(e, p, f), n !== null && (Yt(n, e, f, a), hs(n, e, f)) }, enqueueForceUpdate: function (e, n) { e = e._reactInternals; var o = ht(), a = Un(e), f = vn(o, a); f.tag = 2, n != null && (f.callback = n), n = _n(e, f, a), n !== null && (Yt(n, e, a, o), hs(n, e, a)) } }; function Ad(e, n, o, a, f, p, y) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(a, p, y) : n.prototype && n.prototype.isPureReactComponent ? !Fi(o, a) || !Fi(f, p) : !0 } function Md(e, n, o) { var a = !1, f = Fn, p = n.contextType; return typeof p == "object" && p !== null ? p = Dt(p) : (f = gt(n) ? tr : at.current, a = n.contextTypes, p = (a = a != null) ? Fr(e, f) : Fn), n = new n(o, p), e.memoizedState = n.state !== null && n.state !== void 0 ? n.state : null, n.updater = Ss, e.stateNode = n, n._reactInternals = e, a && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = f, e.__reactInternalMemoizedMaskedChildContext = p), n } function Ld(e, n, o, a) { e = n.state, typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps(o, a), typeof n.UNSAFE_componentWillReceiveProps == "function" && n.UNSAFE_componentWillReceiveProps(o, a), n.state !== e && Ss.enqueueReplaceState(n, n.state, null) } function Pl(e, n, o, a) { var f = e.stateNode; f.props = o, f.state = e.memoizedState, f.refs = {}, fl(e); var p = n.contextType; typeof p == "object" && p !== null ? f.context = Dt(p) : (p = gt(n) ? tr : at.current, f.context = Fr(e, p)), f.state = e.memoizedState, p = n.getDerivedStateFromProps, typeof p == "function" && (Cl(e, n, p, o), f.state = e.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof f.getSnapshotBeforeUpdate == "function" || typeof f.UNSAFE_componentWillMount != "function" && typeof f.componentWillMount != "function" || (n = f.state, typeof f.componentWillMount == "function" && f.componentWillMount(), typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), n !== f.state && Ss.enqueueReplaceState(f, f.state, null), ps(e, o, f, a), f.state = e.memoizedState), typeof f.componentDidMount == "function" && (e.flags |= 4194308) } function $r(e, n) {
    try { var o = "", a = n; do o += me(a), a = a.return; while (a); var f = o } catch (p) {
      f = `
Error generating stack: `+ p.message + `
`+ p.stack
    } return { value: e, source: n, stack: f, digest: null }
  } function Tl(e, n, o) { return { value: e, source: null, stack: o ?? null, digest: n ?? null } } function Nl(e, n) { try { console.error(n.value) } catch (o) { setTimeout(function () { throw o }) } } var f0 = typeof WeakMap == "function" ? WeakMap : Map; function Dd(e, n, o) { o = vn(-1, o), o.tag = 3, o.payload = { element: null }; var a = n.value; return o.callback = function () { bs || (bs = !0, Ul = a), Nl(e, n) }, o } function Fd(e, n, o) { o = vn(-1, o), o.tag = 3; var a = e.type.getDerivedStateFromError; if (typeof a == "function") { var f = n.value; o.payload = function () { return a(f) }, o.callback = function () { Nl(e, n) } } var p = e.stateNode; return p !== null && typeof p.componentDidCatch == "function" && (o.callback = function () { Nl(e, n), typeof a != "function" && (zn === null ? zn = new Set([this]) : zn.add(this)); var y = n.stack; this.componentDidCatch(n.value, { componentStack: y !== null ? y : "" }) }), o } function Vd(e, n, o) { var a = e.pingCache; if (a === null) { a = e.pingCache = new f0; var f = new Set; a.set(n, f) } else f = a.get(n), f === void 0 && (f = new Set, a.set(n, f)); f.has(o) || (f.add(o), e = P0.bind(null, e, n, o), n.then(e, e)) } function Id(e) { do { var n; if ((n = e.tag === 13) && (n = e.memoizedState, n = n !== null ? n.dehydrated !== null : !0), n) return e; e = e.return } while (e !== null); return null } function _d(e, n, o, a, f) { return (e.mode & 1) === 0 ? (e === n ? e.flags |= 65536 : (e.flags |= 128, o.flags |= 131072, o.flags &= -52805, o.tag === 1 && (o.alternate === null ? o.tag = 17 : (n = vn(-1, 1), n.tag = 2, _n(o, n, 1))), o.lanes |= 1), e) : (e.flags |= 65536, e.lanes = f, e) } var d0 = U.ReactCurrentOwner, yt = !1; function dt(e, n, o, a) { n.child = e === null ? id(n, null, o, a) : Or(n, e.child, o, a) } function Od(e, n, o, a, f) { o = o.render; var p = n.ref; return Br(n, f), a = vl(e, n, o, a, p, f), o = xl(), e !== null && !yt ? (n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~f, xn(e, n, f)) : (Ve && o && tl(n), n.flags |= 1, dt(e, n, a, f), n.child) } function zd(e, n, o, a, f) { if (e === null) { var p = o.type; return typeof p == "function" && !Xl(p) && p.defaultProps === void 0 && o.compare === null && o.defaultProps === void 0 ? (n.tag = 15, n.type = p, Bd(e, n, p, a, f)) : (e = Ds(o.type, null, a, n, n.mode, f), e.ref = n.ref, e.return = n, n.child = e) } if (p = e.child, (e.lanes & f) === 0) { var y = p.memoizedProps; if (o = o.compare, o = o !== null ? o : Fi, o(y, a) && e.ref === n.ref) return xn(e, n, f) } return n.flags |= 1, e = Wn(p, a), e.ref = n.ref, e.return = n, n.child = e } function Bd(e, n, o, a, f) { if (e !== null) { var p = e.memoizedProps; if (Fi(p, a) && e.ref === n.ref) if (yt = !1, n.pendingProps = a = p, (e.lanes & f) !== 0) (e.flags & 131072) !== 0 && (yt = !0); else return n.lanes = e.lanes, xn(e, n, f) } return bl(e, n, o, a, f) } function Ud(e, n, o) { var a = n.pendingProps, f = a.children, p = e !== null ? e.memoizedState : null; if (a.mode === "hidden") if ((n.mode & 1) === 0) n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Me(Hr, bt), bt |= o; else { if ((o & 1073741824) === 0) return e = p !== null ? p.baseLanes | o : o, n.lanes = n.childLanes = 1073741824, n.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, n.updateQueue = null, Me(Hr, bt), bt |= e, null; n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, a = p !== null ? p.baseLanes : o, Me(Hr, bt), bt |= a } else p !== null ? (a = p.baseLanes | o, n.memoizedState = null) : a = o, Me(Hr, bt), bt |= a; return dt(e, n, f, o), n.child } function $d(e, n) { var o = n.ref; (e === null && o !== null || e !== null && e.ref !== o) && (n.flags |= 512, n.flags |= 2097152) } function bl(e, n, o, a, f) { var p = gt(o) ? tr : at.current; return p = Fr(n, p), Br(n, f), o = vl(e, n, o, a, p, f), a = xl(), e !== null && !yt ? (n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~f, xn(e, n, f)) : (Ve && a && tl(n), n.flags |= 1, dt(e, n, o, f), n.child) } function Wd(e, n, o, a, f) { if (gt(o)) { var p = !0; os(n) } else p = !1; if (Br(n, f), n.stateNode === null) Es(e, n), Md(n, o, a), Pl(n, o, a, f), a = !0; else if (e === null) { var y = n.stateNode, S = n.memoizedProps; y.props = S; var T = y.context, F = o.contextType; typeof F == "object" && F !== null ? F = Dt(F) : (F = gt(o) ? tr : at.current, F = Fr(n, F)); var B = o.getDerivedStateFromProps, $ = typeof B == "function" || typeof y.getSnapshotBeforeUpdate == "function"; $ || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (S !== a || T !== F) && Ld(n, y, a, F), In = !1; var z = n.memoizedState; y.state = z, ps(n, a, y, f), T = n.memoizedState, S !== a || z !== T || mt.current || In ? (typeof B == "function" && (Cl(n, o, B, a), T = n.memoizedState), (S = In || Ad(n, o, S, a, z, T, F)) ? ($ || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount()), typeof y.componentDidMount == "function" && (n.flags |= 4194308)) : (typeof y.componentDidMount == "function" && (n.flags |= 4194308), n.memoizedProps = a, n.memoizedState = T), y.props = a, y.state = T, y.context = F, a = S) : (typeof y.componentDidMount == "function" && (n.flags |= 4194308), a = !1) } else { y = n.stateNode, sd(e, n), S = n.memoizedProps, F = n.type === n.elementType ? S : Ht(n.type, S), y.props = F, $ = n.pendingProps, z = y.context, T = o.contextType, typeof T == "object" && T !== null ? T = Dt(T) : (T = gt(o) ? tr : at.current, T = Fr(n, T)); var X = o.getDerivedStateFromProps; (B = typeof X == "function" || typeof y.getSnapshotBeforeUpdate == "function") || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (S !== $ || z !== T) && Ld(n, y, a, T), In = !1, z = n.memoizedState, y.state = z, ps(n, a, y, f); var J = n.memoizedState; S !== $ || z !== J || mt.current || In ? (typeof X == "function" && (Cl(n, o, X, a), J = n.memoizedState), (F = In || Ad(n, o, F, a, z, J, T) || !1) ? (B || typeof y.UNSAFE_componentWillUpdate != "function" && typeof y.componentWillUpdate != "function" || (typeof y.componentWillUpdate == "function" && y.componentWillUpdate(a, J, T), typeof y.UNSAFE_componentWillUpdate == "function" && y.UNSAFE_componentWillUpdate(a, J, T)), typeof y.componentDidUpdate == "function" && (n.flags |= 4), typeof y.getSnapshotBeforeUpdate == "function" && (n.flags |= 1024)) : (typeof y.componentDidUpdate != "function" || S === e.memoizedProps && z === e.memoizedState || (n.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || S === e.memoizedProps && z === e.memoizedState || (n.flags |= 1024), n.memoizedProps = a, n.memoizedState = J), y.props = a, y.state = J, y.context = T, a = F) : (typeof y.componentDidUpdate != "function" || S === e.memoizedProps && z === e.memoizedState || (n.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || S === e.memoizedProps && z === e.memoizedState || (n.flags |= 1024), a = !1) } return Rl(e, n, o, a, p, f) } function Rl(e, n, o, a, f, p) { $d(e, n); var y = (n.flags & 128) !== 0; if (!a && !y) return f && Xf(n, o, !1), xn(e, n, p); a = n.stateNode, d0.current = n; var S = y && typeof o.getDerivedStateFromError != "function" ? null : a.render(); return n.flags |= 1, e !== null && y ? (n.child = Or(n, e.child, null, p), n.child = Or(n, null, S, p)) : dt(e, n, S, p), n.memoizedState = a.state, f && Xf(n, o, !0), n.child } function Hd(e) { var n = e.stateNode; n.pendingContext ? Gf(e, n.pendingContext, n.pendingContext !== n.context) : n.context && Gf(e, n.context, !1), dl(e, n.containerInfo) } function Kd(e, n, o, a, f) { return _r(), ol(f), n.flags |= 256, dt(e, n, o, a), n.child } var jl = { dehydrated: null, treeContext: null, retryLane: 0 }; function Al(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Gd(e, n, o) { var a = n.pendingProps, f = _e.current, p = !1, y = (n.flags & 128) !== 0, S; if ((S = y) || (S = e !== null && e.memoizedState === null ? !1 : (f & 2) !== 0), S ? (p = !0, n.flags &= -129) : (e === null || e.memoizedState !== null) && (f |= 1), Me(_e, f & 1), e === null) return il(n), e = n.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? ((n.mode & 1) === 0 ? n.lanes = 1 : e.data === "$!" ? n.lanes = 8 : n.lanes = 1073741824, null) : (y = a.children, e = a.fallback, p ? (a = n.mode, p = n.child, y = { mode: "hidden", children: y }, (a & 1) === 0 && p !== null ? (p.childLanes = 0, p.pendingProps = y) : p = Fs(y, a, 0, null), e = fr(e, a, o, null), p.return = n, e.return = n, p.sibling = e, n.child = p, n.child.memoizedState = Al(o), n.memoizedState = jl, e) : Ml(n, y)); if (f = e.memoizedState, f !== null && (S = f.dehydrated, S !== null)) return h0(e, n, y, a, S, f, o); if (p) { p = a.fallback, y = n.mode, f = e.child, S = f.sibling; var T = { mode: "hidden", children: a.children }; return (y & 1) === 0 && n.child !== f ? (a = n.child, a.childLanes = 0, a.pendingProps = T, n.deletions = null) : (a = Wn(f, T), a.subtreeFlags = f.subtreeFlags & 14680064), S !== null ? p = Wn(S, p) : (p = fr(p, y, o, null), p.flags |= 2), p.return = n, a.return = n, a.sibling = p, n.child = a, a = p, p = n.child, y = e.child.memoizedState, y = y === null ? Al(o) : { baseLanes: y.baseLanes | o, cachePool: null, transitions: y.transitions }, p.memoizedState = y, p.childLanes = e.childLanes & ~o, n.memoizedState = jl, a } return p = e.child, e = p.sibling, a = Wn(p, { mode: "visible", children: a.children }), (n.mode & 1) === 0 && (a.lanes = o), a.return = n, a.sibling = null, e !== null && (o = n.deletions, o === null ? (n.deletions = [e], n.flags |= 16) : o.push(e)), n.child = a, n.memoizedState = null, a } function Ml(e, n) { return n = Fs({ mode: "visible", children: n }, e.mode, 0, null), n.return = e, e.child = n } function ks(e, n, o, a) { return a !== null && ol(a), Or(n, e.child, null, o), e = Ml(n, n.pendingProps.children), e.flags |= 2, n.memoizedState = null, e } function h0(e, n, o, a, f, p, y) { if (o) return n.flags & 256 ? (n.flags &= -257, a = Tl(Error(i(422))), ks(e, n, y, a)) : n.memoizedState !== null ? (n.child = e.child, n.flags |= 128, null) : (p = a.fallback, f = n.mode, a = Fs({ mode: "visible", children: a.children }, f, 0, null), p = fr(p, f, y, null), p.flags |= 2, a.return = n, p.return = n, a.sibling = p, n.child = a, (n.mode & 1) !== 0 && Or(n, e.child, null, y), n.child.memoizedState = Al(y), n.memoizedState = jl, p); if ((n.mode & 1) === 0) return ks(e, n, y, null); if (f.data === "$!") { if (a = f.nextSibling && f.nextSibling.dataset, a) var S = a.dgst; return a = S, p = Error(i(419)), a = Tl(p, a, void 0), ks(e, n, y, a) } if (S = (y & e.childLanes) !== 0, yt || S) { if (a = nt, a !== null) { switch (y & -y) { case 4: f = 2; break; case 16: f = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: f = 32; break; case 536870912: f = 268435456; break; default: f = 0 }f = (f & (a.suspendedLanes | y)) !== 0 ? 0 : f, f !== 0 && f !== p.retryLane && (p.retryLane = f, yn(e, f), Yt(a, e, f, -1)) } return Yl(), a = Tl(Error(i(421))), ks(e, n, y, a) } return f.data === "$?" ? (n.flags |= 128, n.child = e.child, n = T0.bind(null, e), f._reactRetry = n, null) : (e = p.treeContext, Nt = Ln(f.nextSibling), Tt = n, Ve = !0, Wt = null, e !== null && (Mt[Lt++] = mn, Mt[Lt++] = gn, Mt[Lt++] = nr, mn = e.id, gn = e.overflow, nr = n), n = Ml(n, a.children), n.flags |= 4096, n) } function Yd(e, n, o) { e.lanes |= n; var a = e.alternate; a !== null && (a.lanes |= n), ul(e.return, n, o) } function Ll(e, n, o, a, f) { var p = e.memoizedState; p === null ? e.memoizedState = { isBackwards: n, rendering: null, renderingStartTime: 0, last: a, tail: o, tailMode: f } : (p.isBackwards = n, p.rendering = null, p.renderingStartTime = 0, p.last = a, p.tail = o, p.tailMode = f) } function Xd(e, n, o) { var a = n.pendingProps, f = a.revealOrder, p = a.tail; if (dt(e, n, a.children, o), a = _e.current, (a & 2) !== 0) a = a & 1 | 2, n.flags |= 128; else { if (e !== null && (e.flags & 128) !== 0) e: for (e = n.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && Yd(e, o, n); else if (e.tag === 19) Yd(e, o, n); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === n) break e; for (; e.sibling === null;) { if (e.return === null || e.return === n) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } a &= 1 } if (Me(_e, a), (n.mode & 1) === 0) n.memoizedState = null; else switch (f) { case "forwards": for (o = n.child, f = null; o !== null;)e = o.alternate, e !== null && ms(e) === null && (f = o), o = o.sibling; o = f, o === null ? (f = n.child, n.child = null) : (f = o.sibling, o.sibling = null), Ll(n, !1, f, o, p); break; case "backwards": for (o = null, f = n.child, n.child = null; f !== null;) { if (e = f.alternate, e !== null && ms(e) === null) { n.child = f; break } e = f.sibling, f.sibling = o, o = f, f = e } Ll(n, !0, o, null, p); break; case "together": Ll(n, !1, null, null, void 0); break; default: n.memoizedState = null }return n.child } function Es(e, n) { (n.mode & 1) === 0 && e !== null && (e.alternate = null, n.alternate = null, n.flags |= 2) } function xn(e, n, o) { if (e !== null && (n.dependencies = e.dependencies), ar |= n.lanes, (o & n.childLanes) === 0) return null; if (e !== null && n.child !== e.child) throw Error(i(153)); if (n.child !== null) { for (e = n.child, o = Wn(e, e.pendingProps), n.child = o, o.return = n; e.sibling !== null;)e = e.sibling, o = o.sibling = Wn(e, e.pendingProps), o.return = n; o.sibling = null } return n.child } function p0(e, n, o) { switch (n.tag) { case 3: Hd(n), _r(); break; case 5: ud(n); break; case 1: gt(n.type) && os(n); break; case 4: dl(n, n.stateNode.containerInfo); break; case 10: var a = n.type._context, f = n.memoizedProps.value; Me(fs, a._currentValue), a._currentValue = f; break; case 13: if (a = n.memoizedState, a !== null) return a.dehydrated !== null ? (Me(_e, _e.current & 1), n.flags |= 128, null) : (o & n.child.childLanes) !== 0 ? Gd(e, n, o) : (Me(_e, _e.current & 1), e = xn(e, n, o), e !== null ? e.sibling : null); Me(_e, _e.current & 1); break; case 19: if (a = (o & n.childLanes) !== 0, (e.flags & 128) !== 0) { if (a) return Xd(e, n, o); n.flags |= 128 } if (f = n.memoizedState, f !== null && (f.rendering = null, f.tail = null, f.lastEffect = null), Me(_e, _e.current), a) break; return null; case 22: case 23: return n.lanes = 0, Ud(e, n, o) }return xn(e, n, o) } var Qd, Dl, qd, Zd; Qd = function (e, n) { for (var o = n.child; o !== null;) { if (o.tag === 5 || o.tag === 6) e.appendChild(o.stateNode); else if (o.tag !== 4 && o.child !== null) { o.child.return = o, o = o.child; continue } if (o === n) break; for (; o.sibling === null;) { if (o.return === null || o.return === n) return; o = o.return } o.sibling.return = o.return, o = o.sibling } }, Dl = function () { }, qd = function (e, n, o, a) { var f = e.memoizedProps; if (f !== a) { e = n.stateNode, or(rn.current); var p = null; switch (o) { case "input": f = Fe(e, f), a = Fe(e, a), p = []; break; case "select": f = G({}, f, { value: void 0 }), a = G({}, a, { value: void 0 }), p = []; break; case "textarea": f = qn(e, f), a = qn(e, a), p = []; break; default: typeof f.onClick != "function" && typeof a.onClick == "function" && (e.onclick = ns) }hi(o, a); var y; o = null; for (F in f) if (!a.hasOwnProperty(F) && f.hasOwnProperty(F) && f[F] != null) if (F === "style") { var S = f[F]; for (y in S) S.hasOwnProperty(y) && (o || (o = {}), o[y] = "") } else F !== "dangerouslySetInnerHTML" && F !== "children" && F !== "suppressContentEditableWarning" && F !== "suppressHydrationWarning" && F !== "autoFocus" && (l.hasOwnProperty(F) ? p || (p = []) : (p = p || []).push(F, null)); for (F in a) { var T = a[F]; if (S = f?.[F], a.hasOwnProperty(F) && T !== S && (T != null || S != null)) if (F === "style") if (S) { for (y in S) !S.hasOwnProperty(y) || T && T.hasOwnProperty(y) || (o || (o = {}), o[y] = ""); for (y in T) T.hasOwnProperty(y) && S[y] !== T[y] && (o || (o = {}), o[y] = T[y]) } else o || (p || (p = []), p.push(F, o)), o = T; else F === "dangerouslySetInnerHTML" ? (T = T ? T.__html : void 0, S = S ? S.__html : void 0, T != null && S !== T && (p = p || []).push(F, T)) : F === "children" ? typeof T != "string" && typeof T != "number" || (p = p || []).push(F, "" + T) : F !== "suppressContentEditableWarning" && F !== "suppressHydrationWarning" && (l.hasOwnProperty(F) ? (T != null && F === "onScroll" && Le("scroll", e), p || S === T || (p = [])) : (p = p || []).push(F, T)) } o && (p = p || []).push("style", o); var F = p; (n.updateQueue = F) && (n.flags |= 4) } }, Zd = function (e, n, o, a) { o !== a && (n.flags |= 4) }; function Qi(e, n) { if (!Ve) switch (e.tailMode) { case "hidden": n = e.tail; for (var o = null; n !== null;)n.alternate !== null && (o = n), n = n.sibling; o === null ? e.tail = null : o.sibling = null; break; case "collapsed": o = e.tail; for (var a = null; o !== null;)o.alternate !== null && (a = o), o = o.sibling; a === null ? n || e.tail === null ? e.tail = null : e.tail.sibling = null : a.sibling = null } } function ut(e) { var n = e.alternate !== null && e.alternate.child === e.child, o = 0, a = 0; if (n) for (var f = e.child; f !== null;)o |= f.lanes | f.childLanes, a |= f.subtreeFlags & 14680064, a |= f.flags & 14680064, f.return = e, f = f.sibling; else for (f = e.child; f !== null;)o |= f.lanes | f.childLanes, a |= f.subtreeFlags, a |= f.flags, f.return = e, f = f.sibling; return e.subtreeFlags |= a, e.childLanes = o, n } function m0(e, n, o) { var a = n.pendingProps; switch (nl(n), n.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return ut(n), null; case 1: return gt(n.type) && is(), ut(n), null; case 3: return a = n.stateNode, Ur(), De(mt), De(at), ml(), a.pendingContext && (a.context = a.pendingContext, a.pendingContext = null), (e === null || e.child === null) && (us(n) ? n.flags |= 4 : e === null || e.memoizedState.isDehydrated && (n.flags & 256) === 0 || (n.flags |= 1024, Wt !== null && (Hl(Wt), Wt = null))), Dl(e, n), ut(n), null; case 5: hl(n); var f = or(Hi.current); if (o = n.type, e !== null && n.stateNode != null) qd(e, n, o, a, f), e.ref !== n.ref && (n.flags |= 512, n.flags |= 2097152); else { if (!a) { if (n.stateNode === null) throw Error(i(166)); return ut(n), null } if (e = or(rn.current), us(n)) { a = n.stateNode, o = n.type; var p = n.memoizedProps; switch (a[nn] = n, a[zi] = p, e = (n.mode & 1) !== 0, o) { case "dialog": Le("cancel", a), Le("close", a); break; case "iframe": case "object": case "embed": Le("load", a); break; case "video": case "audio": for (f = 0; f < Ii.length; f++)Le(Ii[f], a); break; case "source": Le("error", a); break; case "img": case "image": case "link": Le("error", a), Le("load", a); break; case "details": Le("toggle", a); break; case "input": et(a, p), Le("invalid", a); break; case "select": a._wrapperState = { wasMultiple: !!p.multiple }, Le("invalid", a); break; case "textarea": Sr(a, p), Le("invalid", a) }hi(o, p), f = null; for (var y in p) if (p.hasOwnProperty(y)) { var S = p[y]; y === "children" ? typeof S == "string" ? a.textContent !== S && (p.suppressHydrationWarning !== !0 && ts(a.textContent, S, e), f = ["children", S]) : typeof S == "number" && a.textContent !== "" + S && (p.suppressHydrationWarning !== !0 && ts(a.textContent, S, e), f = ["children", "" + S]) : l.hasOwnProperty(y) && S != null && y === "onScroll" && Le("scroll", a) } switch (o) { case "input": Ce(a), en(a, p, !0); break; case "textarea": Ce(a), fi(a); break; case "select": case "option": break; default: typeof p.onClick == "function" && (a.onclick = ns) }a = f, n.updateQueue = a, a !== null && (n.flags |= 4) } else { y = f.nodeType === 9 ? f : f.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Ao(o)), e === "http://www.w3.org/1999/xhtml" ? o === "script" ? (e = y.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof a.is == "string" ? e = y.createElement(o, { is: a.is }) : (e = y.createElement(o), o === "select" && (y = e, a.multiple ? y.multiple = !0 : a.size && (y.size = a.size))) : e = y.createElementNS(e, o), e[nn] = n, e[zi] = a, Qd(e, n, !1, !1), n.stateNode = e; e: { switch (y = pi(o, a), o) { case "dialog": Le("cancel", e), Le("close", e), f = a; break; case "iframe": case "object": case "embed": Le("load", e), f = a; break; case "video": case "audio": for (f = 0; f < Ii.length; f++)Le(Ii[f], e); f = a; break; case "source": Le("error", e), f = a; break; case "img": case "image": case "link": Le("error", e), Le("load", e), f = a; break; case "details": Le("toggle", e), f = a; break; case "input": et(e, a), f = Fe(e, a), Le("invalid", e); break; case "option": f = a; break; case "select": e._wrapperState = { wasMultiple: !!a.multiple }, f = G({}, a, { value: void 0 }), Le("invalid", e); break; case "textarea": Sr(e, a), f = qn(e, a), Le("invalid", e); break; default: f = a }hi(o, f), S = f; for (p in S) if (S.hasOwnProperty(p)) { var T = S[p]; p === "style" ? Mo(e, T) : p === "dangerouslySetInnerHTML" ? (T = T ? T.__html : void 0, T != null && Cr(e, T)) : p === "children" ? typeof T == "string" ? (o !== "textarea" || T !== "") && At(e, T) : typeof T == "number" && At(e, "" + T) : p !== "suppressContentEditableWarning" && p !== "suppressHydrationWarning" && p !== "autoFocus" && (l.hasOwnProperty(p) ? T != null && p === "onScroll" && Le("scroll", e) : T != null && L(e, p, T, y)) } switch (o) { case "input": Ce(e), en(e, a, !1); break; case "textarea": Ce(e), fi(e); break; case "option": a.value != null && e.setAttribute("value", "" + fe(a.value)); break; case "select": e.multiple = !!a.multiple, p = a.value, p != null ? jt(e, !!a.multiple, p, !1) : a.defaultValue != null && jt(e, !!a.multiple, a.defaultValue, !0); break; default: typeof f.onClick == "function" && (e.onclick = ns) }switch (o) { case "button": case "input": case "select": case "textarea": a = !!a.autoFocus; break e; case "img": a = !0; break e; default: a = !1 } } a && (n.flags |= 4) } n.ref !== null && (n.flags |= 512, n.flags |= 2097152) } return ut(n), null; case 6: if (e && n.stateNode != null) Zd(e, n, e.memoizedProps, a); else { if (typeof a != "string" && n.stateNode === null) throw Error(i(166)); if (o = or(Hi.current), or(rn.current), us(n)) { if (a = n.stateNode, o = n.memoizedProps, a[nn] = n, (p = a.nodeValue !== o) && (e = Tt, e !== null)) switch (e.tag) { case 3: ts(a.nodeValue, o, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && ts(a.nodeValue, o, (e.mode & 1) !== 0) }p && (n.flags |= 4) } else a = (o.nodeType === 9 ? o : o.ownerDocument).createTextNode(a), a[nn] = n, n.stateNode = a } return ut(n), null; case 13: if (De(_e), a = n.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (Ve && Nt !== null && (n.mode & 1) !== 0 && (n.flags & 128) === 0) td(), _r(), n.flags |= 98560, p = !1; else if (p = us(n), a !== null && a.dehydrated !== null) { if (e === null) { if (!p) throw Error(i(318)); if (p = n.memoizedState, p = p !== null ? p.dehydrated : null, !p) throw Error(i(317)); p[nn] = n } else _r(), (n.flags & 128) === 0 && (n.memoizedState = null), n.flags |= 4; ut(n), p = !1 } else Wt !== null && (Hl(Wt), Wt = null), p = !0; if (!p) return n.flags & 65536 ? n : null } return (n.flags & 128) !== 0 ? (n.lanes = o, n) : (a = a !== null, a !== (e !== null && e.memoizedState !== null) && a && (n.child.flags |= 8192, (n.mode & 1) !== 0 && (e === null || (_e.current & 1) !== 0 ? Qe === 0 && (Qe = 3) : Yl())), n.updateQueue !== null && (n.flags |= 4), ut(n), null); case 4: return Ur(), Dl(e, n), e === null && _i(n.stateNode.containerInfo), ut(n), null; case 10: return ll(n.type._context), ut(n), null; case 17: return gt(n.type) && is(), ut(n), null; case 19: if (De(_e), p = n.memoizedState, p === null) return ut(n), null; if (a = (n.flags & 128) !== 0, y = p.rendering, y === null) if (a) Qi(p, !1); else { if (Qe !== 0 || e !== null && (e.flags & 128) !== 0) for (e = n.child; e !== null;) { if (y = ms(e), y !== null) { for (n.flags |= 128, Qi(p, !1), a = y.updateQueue, a !== null && (n.updateQueue = a, n.flags |= 4), n.subtreeFlags = 0, a = o, o = n.child; o !== null;)p = o, e = a, p.flags &= 14680066, y = p.alternate, y === null ? (p.childLanes = 0, p.lanes = e, p.child = null, p.subtreeFlags = 0, p.memoizedProps = null, p.memoizedState = null, p.updateQueue = null, p.dependencies = null, p.stateNode = null) : (p.childLanes = y.childLanes, p.lanes = y.lanes, p.child = y.child, p.subtreeFlags = 0, p.deletions = null, p.memoizedProps = y.memoizedProps, p.memoizedState = y.memoizedState, p.updateQueue = y.updateQueue, p.type = y.type, e = y.dependencies, p.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), o = o.sibling; return Me(_e, _e.current & 1 | 2), n.child } e = e.sibling } p.tail !== null && He() > Kr && (n.flags |= 128, a = !0, Qi(p, !1), n.lanes = 4194304) } else { if (!a) if (e = ms(y), e !== null) { if (n.flags |= 128, a = !0, o = e.updateQueue, o !== null && (n.updateQueue = o, n.flags |= 4), Qi(p, !0), p.tail === null && p.tailMode === "hidden" && !y.alternate && !Ve) return ut(n), null } else 2 * He() - p.renderingStartTime > Kr && o !== 1073741824 && (n.flags |= 128, a = !0, Qi(p, !1), n.lanes = 4194304); p.isBackwards ? (y.sibling = n.child, n.child = y) : (o = p.last, o !== null ? o.sibling = y : n.child = y, p.last = y) } return p.tail !== null ? (n = p.tail, p.rendering = n, p.tail = n.sibling, p.renderingStartTime = He(), n.sibling = null, o = _e.current, Me(_e, a ? o & 1 | 2 : o & 1), n) : (ut(n), null); case 22: case 23: return Gl(), a = n.memoizedState !== null, e !== null && e.memoizedState !== null !== a && (n.flags |= 8192), a && (n.mode & 1) !== 0 ? (bt & 1073741824) !== 0 && (ut(n), n.subtreeFlags & 6 && (n.flags |= 8192)) : ut(n), null; case 24: return null; case 25: return null }throw Error(i(156, n.tag)) } function g0(e, n) { switch (nl(n), n.tag) { case 1: return gt(n.type) && is(), e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 3: return Ur(), De(mt), De(at), ml(), e = n.flags, (e & 65536) !== 0 && (e & 128) === 0 ? (n.flags = e & -65537 | 128, n) : null; case 5: return hl(n), null; case 13: if (De(_e), e = n.memoizedState, e !== null && e.dehydrated !== null) { if (n.alternate === null) throw Error(i(340)); _r() } return e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 19: return De(_e), null; case 4: return Ur(), null; case 10: return ll(n.type._context), null; case 22: case 23: return Gl(), null; case 24: return null; default: return null } } var Cs = !1, ct = !1, y0 = typeof WeakSet == "function" ? WeakSet : Set, q = null; function Wr(e, n) { var o = e.ref; if (o !== null) if (typeof o == "function") try { o(null) } catch (a) { $e(e, n, a) } else o.current = null } function Fl(e, n, o) { try { o() } catch (a) { $e(e, n, a) } } var Jd = !1; function v0(e, n) { if (Ga = Wo, e = Af(), Oa(e)) { if ("selectionStart" in e) var o = { start: e.selectionStart, end: e.selectionEnd }; else e: { o = (o = e.ownerDocument) && o.defaultView || window; var a = o.getSelection && o.getSelection(); if (a && a.rangeCount !== 0) { o = a.anchorNode; var f = a.anchorOffset, p = a.focusNode; a = a.focusOffset; try { o.nodeType, p.nodeType } catch { o = null; break e } var y = 0, S = -1, T = -1, F = 0, B = 0, $ = e, z = null; t: for (; ;) { for (var X; $ !== o || f !== 0 && $.nodeType !== 3 || (S = y + f), $ !== p || a !== 0 && $.nodeType !== 3 || (T = y + a), $.nodeType === 3 && (y += $.nodeValue.length), (X = $.firstChild) !== null;)z = $, $ = X; for (; ;) { if ($ === e) break t; if (z === o && ++F === f && (S = y), z === p && ++B === a && (T = y), (X = $.nextSibling) !== null) break; $ = z, z = $.parentNode } $ = X } o = S === -1 || T === -1 ? null : { start: S, end: T } } else o = null } o = o || { start: 0, end: 0 } } else o = null; for (Ya = { focusedElem: e, selectionRange: o }, Wo = !1, q = n; q !== null;)if (n = q, e = n.child, (n.subtreeFlags & 1028) !== 0 && e !== null) e.return = n, q = e; else for (; q !== null;) { n = q; try { var J = n.alternate; if ((n.flags & 1024) !== 0) switch (n.tag) { case 0: case 11: case 15: break; case 1: if (J !== null) { var re = J.memoizedProps, Ke = J.memoizedState, M = n.stateNode, R = M.getSnapshotBeforeUpdate(n.elementType === n.type ? re : Ht(n.type, re), Ke); M.__reactInternalSnapshotBeforeUpdate = R } break; case 3: var D = n.stateNode.containerInfo; D.nodeType === 1 ? D.textContent = "" : D.nodeType === 9 && D.documentElement && D.removeChild(D.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(i(163)) } } catch (W) { $e(n, n.return, W) } if (e = n.sibling, e !== null) { e.return = n.return, q = e; break } q = n.return } return J = Jd, Jd = !1, J } function qi(e, n, o) { var a = n.updateQueue; if (a = a !== null ? a.lastEffect : null, a !== null) { var f = a = a.next; do { if ((f.tag & e) === e) { var p = f.destroy; f.destroy = void 0, p !== void 0 && Fl(n, o, p) } f = f.next } while (f !== a) } } function Ps(e, n) { if (n = n.updateQueue, n = n !== null ? n.lastEffect : null, n !== null) { var o = n = n.next; do { if ((o.tag & e) === e) { var a = o.create; o.destroy = a() } o = o.next } while (o !== n) } } function Vl(e) { var n = e.ref; if (n !== null) { var o = e.stateNode; switch (e.tag) { case 5: e = o; break; default: e = o }typeof n == "function" ? n(e) : n.current = e } } function eh(e) { var n = e.alternate; n !== null && (e.alternate = null, eh(n)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (n = e.stateNode, n !== null && (delete n[nn], delete n[zi], delete n[Za], delete n[e0], delete n[t0])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function th(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function nh(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || th(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function Il(e, n, o) { var a = e.tag; if (a === 5 || a === 6) e = e.stateNode, n ? o.nodeType === 8 ? o.parentNode.insertBefore(e, n) : o.insertBefore(e, n) : (o.nodeType === 8 ? (n = o.parentNode, n.insertBefore(e, o)) : (n = o, n.appendChild(e)), o = o._reactRootContainer, o != null || n.onclick !== null || (n.onclick = ns)); else if (a !== 4 && (e = e.child, e !== null)) for (Il(e, n, o), e = e.sibling; e !== null;)Il(e, n, o), e = e.sibling } function _l(e, n, o) { var a = e.tag; if (a === 5 || a === 6) e = e.stateNode, n ? o.insertBefore(e, n) : o.appendChild(e); else if (a !== 4 && (e = e.child, e !== null)) for (_l(e, n, o), e = e.sibling; e !== null;)_l(e, n, o), e = e.sibling } var it = null, Kt = !1; function On(e, n, o) { for (o = o.child; o !== null;)rh(e, n, o), o = o.sibling } function rh(e, n, o) { if (tn && typeof tn.onCommitFiberUnmount == "function") try { tn.onCommitFiberUnmount(_o, o) } catch { } switch (o.tag) { case 5: ct || Wr(o, n); case 6: var a = it, f = Kt; it = null, On(e, n, o), it = a, Kt = f, it !== null && (Kt ? (e = it, o = o.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(o) : e.removeChild(o)) : it.removeChild(o.stateNode)); break; case 18: it !== null && (Kt ? (e = it, o = o.stateNode, e.nodeType === 8 ? qa(e.parentNode, o) : e.nodeType === 1 && qa(e, o), Ri(e)) : qa(it, o.stateNode)); break; case 4: a = it, f = Kt, it = o.stateNode.containerInfo, Kt = !0, On(e, n, o), it = a, Kt = f; break; case 0: case 11: case 14: case 15: if (!ct && (a = o.updateQueue, a !== null && (a = a.lastEffect, a !== null))) { f = a = a.next; do { var p = f, y = p.destroy; p = p.tag, y !== void 0 && ((p & 2) !== 0 || (p & 4) !== 0) && Fl(o, n, y), f = f.next } while (f !== a) } On(e, n, o); break; case 1: if (!ct && (Wr(o, n), a = o.stateNode, typeof a.componentWillUnmount == "function")) try { a.props = o.memoizedProps, a.state = o.memoizedState, a.componentWillUnmount() } catch (S) { $e(o, n, S) } On(e, n, o); break; case 21: On(e, n, o); break; case 22: o.mode & 1 ? (ct = (a = ct) || o.memoizedState !== null, On(e, n, o), ct = a) : On(e, n, o); break; default: On(e, n, o) } } function ih(e) { var n = e.updateQueue; if (n !== null) { e.updateQueue = null; var o = e.stateNode; o === null && (o = e.stateNode = new y0), n.forEach(function (a) { var f = N0.bind(null, e, a); o.has(a) || (o.add(a), a.then(f, f)) }) } } function Gt(e, n) { var o = n.deletions; if (o !== null) for (var a = 0; a < o.length; a++) { var f = o[a]; try { var p = e, y = n, S = y; e: for (; S !== null;) { switch (S.tag) { case 5: it = S.stateNode, Kt = !1; break e; case 3: it = S.stateNode.containerInfo, Kt = !0; break e; case 4: it = S.stateNode.containerInfo, Kt = !0; break e }S = S.return } if (it === null) throw Error(i(160)); rh(p, y, f), it = null, Kt = !1; var T = f.alternate; T !== null && (T.return = null), f.return = null } catch (F) { $e(f, n, F) } } if (n.subtreeFlags & 12854) for (n = n.child; n !== null;)oh(n, e), n = n.sibling } function oh(e, n) { var o = e.alternate, a = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Gt(n, e), sn(e), a & 4) { try { qi(3, e, e.return), Ps(3, e) } catch (re) { $e(e, e.return, re) } try { qi(5, e, e.return) } catch (re) { $e(e, e.return, re) } } break; case 1: Gt(n, e), sn(e), a & 512 && o !== null && Wr(o, o.return); break; case 5: if (Gt(n, e), sn(e), a & 512 && o !== null && Wr(o, o.return), e.flags & 32) { var f = e.stateNode; try { At(f, "") } catch (re) { $e(e, e.return, re) } } if (a & 4 && (f = e.stateNode, f != null)) { var p = e.memoizedProps, y = o !== null ? o.memoizedProps : p, S = e.type, T = e.updateQueue; if (e.updateQueue = null, T !== null) try { S === "input" && p.type === "radio" && p.name != null && kt(f, p), pi(S, y); var F = pi(S, p); for (y = 0; y < T.length; y += 2) { var B = T[y], $ = T[y + 1]; B === "style" ? Mo(f, $) : B === "dangerouslySetInnerHTML" ? Cr(f, $) : B === "children" ? At(f, $) : L(f, B, $, F) } switch (S) { case "input": Et(f, p); break; case "textarea": ci(f, p); break; case "select": var z = f._wrapperState.wasMultiple; f._wrapperState.wasMultiple = !!p.multiple; var X = p.value; X != null ? jt(f, !!p.multiple, X, !1) : z !== !!p.multiple && (p.defaultValue != null ? jt(f, !!p.multiple, p.defaultValue, !0) : jt(f, !!p.multiple, p.multiple ? [] : "", !1)) }f[zi] = p } catch (re) { $e(e, e.return, re) } } break; case 6: if (Gt(n, e), sn(e), a & 4) { if (e.stateNode === null) throw Error(i(162)); f = e.stateNode, p = e.memoizedProps; try { f.nodeValue = p } catch (re) { $e(e, e.return, re) } } break; case 3: if (Gt(n, e), sn(e), a & 4 && o !== null && o.memoizedState.isDehydrated) try { Ri(n.containerInfo) } catch (re) { $e(e, e.return, re) } break; case 4: Gt(n, e), sn(e); break; case 13: Gt(n, e), sn(e), f = e.child, f.flags & 8192 && (p = f.memoizedState !== null, f.stateNode.isHidden = p, !p || f.alternate !== null && f.alternate.memoizedState !== null || (Bl = He())), a & 4 && ih(e); break; case 22: if (B = o !== null && o.memoizedState !== null, e.mode & 1 ? (ct = (F = ct) || B, Gt(n, e), ct = F) : Gt(n, e), sn(e), a & 8192) { if (F = e.memoizedState !== null, (e.stateNode.isHidden = F) && !B && (e.mode & 1) !== 0) for (q = e, B = e.child; B !== null;) { for ($ = q = B; q !== null;) { switch (z = q, X = z.child, z.tag) { case 0: case 11: case 14: case 15: qi(4, z, z.return); break; case 1: Wr(z, z.return); var J = z.stateNode; if (typeof J.componentWillUnmount == "function") { a = z, o = z.return; try { n = a, J.props = n.memoizedProps, J.state = n.memoizedState, J.componentWillUnmount() } catch (re) { $e(a, o, re) } } break; case 5: Wr(z, z.return); break; case 22: if (z.memoizedState !== null) { lh($); continue } }X !== null ? (X.return = z, q = X) : lh($) } B = B.sibling } e: for (B = null, $ = e; ;) { if ($.tag === 5) { if (B === null) { B = $; try { f = $.stateNode, F ? (p = f.style, typeof p.setProperty == "function" ? p.setProperty("display", "none", "important") : p.display = "none") : (S = $.stateNode, T = $.memoizedProps.style, y = T != null && T.hasOwnProperty("display") ? T.display : null, S.style.display = Zn("display", y)) } catch (re) { $e(e, e.return, re) } } } else if ($.tag === 6) { if (B === null) try { $.stateNode.nodeValue = F ? "" : $.memoizedProps } catch (re) { $e(e, e.return, re) } } else if (($.tag !== 22 && $.tag !== 23 || $.memoizedState === null || $ === e) && $.child !== null) { $.child.return = $, $ = $.child; continue } if ($ === e) break e; for (; $.sibling === null;) { if ($.return === null || $.return === e) break e; B === $ && (B = null), $ = $.return } B === $ && (B = null), $.sibling.return = $.return, $ = $.sibling } } break; case 19: Gt(n, e), sn(e), a & 4 && ih(e); break; case 21: break; default: Gt(n, e), sn(e) } } function sn(e) { var n = e.flags; if (n & 2) { try { e: { for (var o = e.return; o !== null;) { if (th(o)) { var a = o; break e } o = o.return } throw Error(i(160)) } switch (a.tag) { case 5: var f = a.stateNode; a.flags & 32 && (At(f, ""), a.flags &= -33); var p = nh(e); _l(e, p, f); break; case 3: case 4: var y = a.stateNode.containerInfo, S = nh(e); Il(e, S, y); break; default: throw Error(i(161)) } } catch (T) { $e(e, e.return, T) } e.flags &= -3 } n & 4096 && (e.flags &= -4097) } function x0(e, n, o) { q = e, sh(e) } function sh(e, n, o) { for (var a = (e.mode & 1) !== 0; q !== null;) { var f = q, p = f.child; if (f.tag === 22 && a) { var y = f.memoizedState !== null || Cs; if (!y) { var S = f.alternate, T = S !== null && S.memoizedState !== null || ct; S = Cs; var F = ct; if (Cs = y, (ct = T) && !F) for (q = f; q !== null;)y = q, T = y.child, y.tag === 22 && y.memoizedState !== null ? uh(f) : T !== null ? (T.return = y, q = T) : uh(f); for (; p !== null;)q = p, sh(p), p = p.sibling; q = f, Cs = S, ct = F } ah(e) } else (f.subtreeFlags & 8772) !== 0 && p !== null ? (p.return = f, q = p) : ah(e) } } function ah(e) { for (; q !== null;) { var n = q; if ((n.flags & 8772) !== 0) { var o = n.alternate; try { if ((n.flags & 8772) !== 0) switch (n.tag) { case 0: case 11: case 15: ct || Ps(5, n); break; case 1: var a = n.stateNode; if (n.flags & 4 && !ct) if (o === null) a.componentDidMount(); else { var f = n.elementType === n.type ? o.memoizedProps : Ht(n.type, o.memoizedProps); a.componentDidUpdate(f, o.memoizedState, a.__reactInternalSnapshotBeforeUpdate) } var p = n.updateQueue; p !== null && ld(n, p, a); break; case 3: var y = n.updateQueue; if (y !== null) { if (o = null, n.child !== null) switch (n.child.tag) { case 5: o = n.child.stateNode; break; case 1: o = n.child.stateNode }ld(n, y, o) } break; case 5: var S = n.stateNode; if (o === null && n.flags & 4) { o = S; var T = n.memoizedProps; switch (n.type) { case "button": case "input": case "select": case "textarea": T.autoFocus && o.focus(); break; case "img": T.src && (o.src = T.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (n.memoizedState === null) { var F = n.alternate; if (F !== null) { var B = F.memoizedState; if (B !== null) { var $ = B.dehydrated; $ !== null && Ri($) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(i(163)) }ct || n.flags & 512 && Vl(n) } catch (z) { $e(n, n.return, z) } } if (n === e) { q = null; break } if (o = n.sibling, o !== null) { o.return = n.return, q = o; break } q = n.return } } function lh(e) { for (; q !== null;) { var n = q; if (n === e) { q = null; break } var o = n.sibling; if (o !== null) { o.return = n.return, q = o; break } q = n.return } } function uh(e) { for (; q !== null;) { var n = q; try { switch (n.tag) { case 0: case 11: case 15: var o = n.return; try { Ps(4, n) } catch (T) { $e(n, o, T) } break; case 1: var a = n.stateNode; if (typeof a.componentDidMount == "function") { var f = n.return; try { a.componentDidMount() } catch (T) { $e(n, f, T) } } var p = n.return; try { Vl(n) } catch (T) { $e(n, p, T) } break; case 5: var y = n.return; try { Vl(n) } catch (T) { $e(n, y, T) } } } catch (T) { $e(n, n.return, T) } if (n === e) { q = null; break } var S = n.sibling; if (S !== null) { S.return = n.return, q = S; break } q = n.return } } var w0 = Math.ceil, Ts = U.ReactCurrentDispatcher, Ol = U.ReactCurrentOwner, Vt = U.ReactCurrentBatchConfig, Ee = 0, nt = null, Ge = null, ot = 0, bt = 0, Hr = Dn(0), Qe = 0, Zi = null, ar = 0, Ns = 0, zl = 0, Ji = null, vt = null, Bl = 0, Kr = 1 / 0, wn = null, bs = !1, Ul = null, zn = null, Rs = !1, Bn = null, js = 0, eo = 0, $l = null, As = -1, Ms = 0; function ht() { return (Ee & 6) !== 0 ? He() : As !== -1 ? As : As = He() } function Un(e) { return (e.mode & 1) === 0 ? 1 : (Ee & 2) !== 0 && ot !== 0 ? ot & -ot : r0.transition !== null ? (Ms === 0 && (Ms = tf()), Ms) : (e = Ae, e !== 0 || (e = window.event, e = e === void 0 ? 16 : ff(e.type)), e) } function Yt(e, n, o, a) { if (50 < eo) throw eo = 0, $l = null, Error(i(185)); Ci(e, o, a), ((Ee & 2) === 0 || e !== nt) && (e === nt && ((Ee & 2) === 0 && (Ns |= o), Qe === 4 && $n(e, ot)), xt(e, a), o === 1 && Ee === 0 && (n.mode & 1) === 0 && (Kr = He() + 500, ss && Vn())) } function xt(e, n) { var o = e.callbackNode; rv(e, n); var a = Bo(e, e === nt ? ot : 0); if (a === 0) o !== null && Zc(o), e.callbackNode = null, e.callbackPriority = 0; else if (n = a & -a, e.callbackPriority !== n) { if (o != null && Zc(o), n === 1) e.tag === 0 ? n0(fh.bind(null, e)) : Qf(fh.bind(null, e)), Zv(function () { (Ee & 6) === 0 && Vn() }), o = null; else { switch (nf(a)) { case 1: o = ka; break; case 4: o = Jc; break; case 16: o = Io; break; case 536870912: o = ef; break; default: o = Io }o = xh(o, ch.bind(null, e)) } e.callbackPriority = n, e.callbackNode = o } } function ch(e, n) { if (As = -1, Ms = 0, (Ee & 6) !== 0) throw Error(i(327)); var o = e.callbackNode; if (Gr() && e.callbackNode !== o) return null; var a = Bo(e, e === nt ? ot : 0); if (a === 0) return null; if ((a & 30) !== 0 || (a & e.expiredLanes) !== 0 || n) n = Ls(e, a); else { n = a; var f = Ee; Ee |= 2; var p = hh(); (nt !== e || ot !== n) && (wn = null, Kr = He() + 500, ur(e, n)); do try { E0(); break } catch (S) { dh(e, S) } while (!0); al(), Ts.current = p, Ee = f, Ge !== null ? n = 0 : (nt = null, ot = 0, n = Qe) } if (n !== 0) { if (n === 2 && (f = Ea(e), f !== 0 && (a = f, n = Wl(e, f))), n === 1) throw o = Zi, ur(e, 0), $n(e, a), xt(e, He()), o; if (n === 6) $n(e, a); else { if (f = e.current.alternate, (a & 30) === 0 && !S0(f) && (n = Ls(e, a), n === 2 && (p = Ea(e), p !== 0 && (a = p, n = Wl(e, p))), n === 1)) throw o = Zi, ur(e, 0), $n(e, a), xt(e, He()), o; switch (e.finishedWork = f, e.finishedLanes = a, n) { case 0: case 1: throw Error(i(345)); case 2: cr(e, vt, wn); break; case 3: if ($n(e, a), (a & 130023424) === a && (n = Bl + 500 - He(), 10 < n)) { if (Bo(e, 0) !== 0) break; if (f = e.suspendedLanes, (f & a) !== a) { ht(), e.pingedLanes |= e.suspendedLanes & f; break } e.timeoutHandle = Qa(cr.bind(null, e, vt, wn), n); break } cr(e, vt, wn); break; case 4: if ($n(e, a), (a & 4194240) === a) break; for (n = e.eventTimes, f = -1; 0 < a;) { var y = 31 - Ut(a); p = 1 << y, y = n[y], y > f && (f = y), a &= ~p } if (a = f, a = He() - a, a = (120 > a ? 120 : 480 > a ? 480 : 1080 > a ? 1080 : 1920 > a ? 1920 : 3e3 > a ? 3e3 : 4320 > a ? 4320 : 1960 * w0(a / 1960)) - a, 10 < a) { e.timeoutHandle = Qa(cr.bind(null, e, vt, wn), a); break } cr(e, vt, wn); break; case 5: cr(e, vt, wn); break; default: throw Error(i(329)) } } } return xt(e, He()), e.callbackNode === o ? ch.bind(null, e) : null } function Wl(e, n) { var o = Ji; return e.current.memoizedState.isDehydrated && (ur(e, n).flags |= 256), e = Ls(e, n), e !== 2 && (n = vt, vt = o, n !== null && Hl(n)), e } function Hl(e) { vt === null ? vt = e : vt.push.apply(vt, e) } function S0(e) { for (var n = e; ;) { if (n.flags & 16384) { var o = n.updateQueue; if (o !== null && (o = o.stores, o !== null)) for (var a = 0; a < o.length; a++) { var f = o[a], p = f.getSnapshot; f = f.value; try { if (!$t(p(), f)) return !1 } catch { return !1 } } } if (o = n.child, n.subtreeFlags & 16384 && o !== null) o.return = n, n = o; else { if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return !0; n = n.return } n.sibling.return = n.return, n = n.sibling } } return !0 } function $n(e, n) { for (n &= ~zl, n &= ~Ns, e.suspendedLanes |= n, e.pingedLanes &= ~n, e = e.expirationTimes; 0 < n;) { var o = 31 - Ut(n), a = 1 << o; e[o] = -1, n &= ~a } } function fh(e) { if ((Ee & 6) !== 0) throw Error(i(327)); Gr(); var n = Bo(e, 0); if ((n & 1) === 0) return xt(e, He()), null; var o = Ls(e, n); if (e.tag !== 0 && o === 2) { var a = Ea(e); a !== 0 && (n = a, o = Wl(e, a)) } if (o === 1) throw o = Zi, ur(e, 0), $n(e, n), xt(e, He()), o; if (o === 6) throw Error(i(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = n, cr(e, vt, wn), xt(e, He()), null } function Kl(e, n) { var o = Ee; Ee |= 1; try { return e(n) } finally { Ee = o, Ee === 0 && (Kr = He() + 500, ss && Vn()) } } function lr(e) { Bn !== null && Bn.tag === 0 && (Ee & 6) === 0 && Gr(); var n = Ee; Ee |= 1; var o = Vt.transition, a = Ae; try { if (Vt.transition = null, Ae = 1, e) return e() } finally { Ae = a, Vt.transition = o, Ee = n, (Ee & 6) === 0 && Vn() } } function Gl() { bt = Hr.current, De(Hr) } function ur(e, n) { e.finishedWork = null, e.finishedLanes = 0; var o = e.timeoutHandle; if (o !== -1 && (e.timeoutHandle = -1, qv(o)), Ge !== null) for (o = Ge.return; o !== null;) { var a = o; switch (nl(a), a.tag) { case 1: a = a.type.childContextTypes, a != null && is(); break; case 3: Ur(), De(mt), De(at), ml(); break; case 5: hl(a); break; case 4: Ur(); break; case 13: De(_e); break; case 19: De(_e); break; case 10: ll(a.type._context); break; case 22: case 23: Gl() }o = o.return } if (nt = e, Ge = e = Wn(e.current, null), ot = bt = n, Qe = 0, Zi = null, zl = Ns = ar = 0, vt = Ji = null, ir !== null) { for (n = 0; n < ir.length; n++)if (o = ir[n], a = o.interleaved, a !== null) { o.interleaved = null; var f = a.next, p = o.pending; if (p !== null) { var y = p.next; p.next = f, a.next = y } o.pending = a } ir = null } return e } function dh(e, n) { do { var o = Ge; try { if (al(), gs.current = ws, ys) { for (var a = Oe.memoizedState; a !== null;) { var f = a.queue; f !== null && (f.pending = null), a = a.next } ys = !1 } if (sr = 0, tt = Xe = Oe = null, Ki = !1, Gi = 0, Ol.current = null, o === null || o.return === null) { Qe = 1, Zi = n, Ge = null; break } e: { var p = e, y = o.return, S = o, T = n; if (n = ot, S.flags |= 32768, T !== null && typeof T == "object" && typeof T.then == "function") { var F = T, B = S, $ = B.tag; if ((B.mode & 1) === 0 && ($ === 0 || $ === 11 || $ === 15)) { var z = B.alternate; z ? (B.updateQueue = z.updateQueue, B.memoizedState = z.memoizedState, B.lanes = z.lanes) : (B.updateQueue = null, B.memoizedState = null) } var X = Id(y); if (X !== null) { X.flags &= -257, _d(X, y, S, p, n), X.mode & 1 && Vd(p, F, n), n = X, T = F; var J = n.updateQueue; if (J === null) { var re = new Set; re.add(T), n.updateQueue = re } else J.add(T); break e } else { if ((n & 1) === 0) { Vd(p, F, n), Yl(); break e } T = Error(i(426)) } } else if (Ve && S.mode & 1) { var Ke = Id(y); if (Ke !== null) { (Ke.flags & 65536) === 0 && (Ke.flags |= 256), _d(Ke, y, S, p, n), ol($r(T, S)); break e } } p = T = $r(T, S), Qe !== 4 && (Qe = 2), Ji === null ? Ji = [p] : Ji.push(p), p = y; do { switch (p.tag) { case 3: p.flags |= 65536, n &= -n, p.lanes |= n; var M = Dd(p, T, n); ad(p, M); break e; case 1: S = T; var R = p.type, D = p.stateNode; if ((p.flags & 128) === 0 && (typeof R.getDerivedStateFromError == "function" || D !== null && typeof D.componentDidCatch == "function" && (zn === null || !zn.has(D)))) { p.flags |= 65536, n &= -n, p.lanes |= n; var W = Fd(p, S, n); ad(p, W); break e } }p = p.return } while (p !== null) } mh(o) } catch (oe) { n = oe, Ge === o && o !== null && (Ge = o = o.return); continue } break } while (!0) } function hh() { var e = Ts.current; return Ts.current = ws, e === null ? ws : e } function Yl() { (Qe === 0 || Qe === 3 || Qe === 2) && (Qe = 4), nt === null || (ar & 268435455) === 0 && (Ns & 268435455) === 0 || $n(nt, ot) } function Ls(e, n) { var o = Ee; Ee |= 2; var a = hh(); (nt !== e || ot !== n) && (wn = null, ur(e, n)); do try { k0(); break } catch (f) { dh(e, f) } while (!0); if (al(), Ee = o, Ts.current = a, Ge !== null) throw Error(i(261)); return nt = null, ot = 0, Qe } function k0() { for (; Ge !== null;)ph(Ge) } function E0() { for (; Ge !== null && !Yy();)ph(Ge) } function ph(e) { var n = vh(e.alternate, e, bt); e.memoizedProps = e.pendingProps, n === null ? mh(e) : Ge = n, Ol.current = null } function mh(e) { var n = e; do { var o = n.alternate; if (e = n.return, (n.flags & 32768) === 0) { if (o = m0(o, n, bt), o !== null) { Ge = o; return } } else { if (o = g0(o, n), o !== null) { o.flags &= 32767, Ge = o; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { Qe = 6, Ge = null; return } } if (n = n.sibling, n !== null) { Ge = n; return } Ge = n = e } while (n !== null); Qe === 0 && (Qe = 5) } function cr(e, n, o) { var a = Ae, f = Vt.transition; try { Vt.transition = null, Ae = 1, C0(e, n, o, a) } finally { Vt.transition = f, Ae = a } return null } function C0(e, n, o, a) { do Gr(); while (Bn !== null); if ((Ee & 6) !== 0) throw Error(i(327)); o = e.finishedWork; var f = e.finishedLanes; if (o === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, o === e.current) throw Error(i(177)); e.callbackNode = null, e.callbackPriority = 0; var p = o.lanes | o.childLanes; if (iv(e, p), e === nt && (Ge = nt = null, ot = 0), (o.subtreeFlags & 2064) === 0 && (o.flags & 2064) === 0 || Rs || (Rs = !0, xh(Io, function () { return Gr(), null })), p = (o.flags & 15990) !== 0, (o.subtreeFlags & 15990) !== 0 || p) { p = Vt.transition, Vt.transition = null; var y = Ae; Ae = 1; var S = Ee; Ee |= 4, Ol.current = null, v0(e, o), oh(o, e), Wv(Ya), Wo = !!Ga, Ya = Ga = null, e.current = o, x0(o), Xy(), Ee = S, Ae = y, Vt.transition = p } else e.current = o; if (Rs && (Rs = !1, Bn = e, js = f), p = e.pendingLanes, p === 0 && (zn = null), Zy(o.stateNode), xt(e, He()), n !== null) for (a = e.onRecoverableError, o = 0; o < n.length; o++)f = n[o], a(f.value, { componentStack: f.stack, digest: f.digest }); if (bs) throw bs = !1, e = Ul, Ul = null, e; return (js & 1) !== 0 && e.tag !== 0 && Gr(), p = e.pendingLanes, (p & 1) !== 0 ? e === $l ? eo++ : (eo = 0, $l = e) : eo = 0, Vn(), null } function Gr() { if (Bn !== null) { var e = nf(js), n = Vt.transition, o = Ae; try { if (Vt.transition = null, Ae = 16 > e ? 16 : e, Bn === null) var a = !1; else { if (e = Bn, Bn = null, js = 0, (Ee & 6) !== 0) throw Error(i(331)); var f = Ee; for (Ee |= 4, q = e.current; q !== null;) { var p = q, y = p.child; if ((q.flags & 16) !== 0) { var S = p.deletions; if (S !== null) { for (var T = 0; T < S.length; T++) { var F = S[T]; for (q = F; q !== null;) { var B = q; switch (B.tag) { case 0: case 11: case 15: qi(8, B, p) }var $ = B.child; if ($ !== null) $.return = B, q = $; else for (; q !== null;) { B = q; var z = B.sibling, X = B.return; if (eh(B), B === F) { q = null; break } if (z !== null) { z.return = X, q = z; break } q = X } } } var J = p.alternate; if (J !== null) { var re = J.child; if (re !== null) { J.child = null; do { var Ke = re.sibling; re.sibling = null, re = Ke } while (re !== null) } } q = p } } if ((p.subtreeFlags & 2064) !== 0 && y !== null) y.return = p, q = y; else e: for (; q !== null;) { if (p = q, (p.flags & 2048) !== 0) switch (p.tag) { case 0: case 11: case 15: qi(9, p, p.return) }var M = p.sibling; if (M !== null) { M.return = p.return, q = M; break e } q = p.return } } var R = e.current; for (q = R; q !== null;) { y = q; var D = y.child; if ((y.subtreeFlags & 2064) !== 0 && D !== null) D.return = y, q = D; else e: for (y = R; q !== null;) { if (S = q, (S.flags & 2048) !== 0) try { switch (S.tag) { case 0: case 11: case 15: Ps(9, S) } } catch (oe) { $e(S, S.return, oe) } if (S === y) { q = null; break e } var W = S.sibling; if (W !== null) { W.return = S.return, q = W; break e } q = S.return } } if (Ee = f, Vn(), tn && typeof tn.onPostCommitFiberRoot == "function") try { tn.onPostCommitFiberRoot(_o, e) } catch { } a = !0 } return a } finally { Ae = o, Vt.transition = n } } return !1 } function gh(e, n, o) { n = $r(o, n), n = Dd(e, n, 1), e = _n(e, n, 1), n = ht(), e !== null && (Ci(e, 1, n), xt(e, n)) } function $e(e, n, o) { if (e.tag === 3) gh(e, e, o); else for (; n !== null;) { if (n.tag === 3) { gh(n, e, o); break } else if (n.tag === 1) { var a = n.stateNode; if (typeof n.type.getDerivedStateFromError == "function" || typeof a.componentDidCatch == "function" && (zn === null || !zn.has(a))) { e = $r(o, e), e = Fd(n, e, 1), n = _n(n, e, 1), e = ht(), n !== null && (Ci(n, 1, e), xt(n, e)); break } } n = n.return } } function P0(e, n, o) { var a = e.pingCache; a !== null && a.delete(n), n = ht(), e.pingedLanes |= e.suspendedLanes & o, nt === e && (ot & o) === o && (Qe === 4 || Qe === 3 && (ot & 130023424) === ot && 500 > He() - Bl ? ur(e, 0) : zl |= o), xt(e, n) } function yh(e, n) { n === 0 && ((e.mode & 1) === 0 ? n = 1 : (n = zo, zo <<= 1, (zo & 130023424) === 0 && (zo = 4194304))); var o = ht(); e = yn(e, n), e !== null && (Ci(e, n, o), xt(e, o)) } function T0(e) { var n = e.memoizedState, o = 0; n !== null && (o = n.retryLane), yh(e, o) } function N0(e, n) { var o = 0; switch (e.tag) { case 13: var a = e.stateNode, f = e.memoizedState; f !== null && (o = f.retryLane); break; case 19: a = e.stateNode; break; default: throw Error(i(314)) }a !== null && a.delete(n), yh(e, o) } var vh; vh = function (e, n, o) { if (e !== null) if (e.memoizedProps !== n.pendingProps || mt.current) yt = !0; else { if ((e.lanes & o) === 0 && (n.flags & 128) === 0) return yt = !1, p0(e, n, o); yt = (e.flags & 131072) !== 0 } else yt = !1, Ve && (n.flags & 1048576) !== 0 && qf(n, ls, n.index); switch (n.lanes = 0, n.tag) { case 2: var a = n.type; Es(e, n), e = n.pendingProps; var f = Fr(n, at.current); Br(n, o), f = vl(null, n, a, e, f, o); var p = xl(); return n.flags |= 1, typeof f == "object" && f !== null && typeof f.render == "function" && f.$$typeof === void 0 ? (n.tag = 1, n.memoizedState = null, n.updateQueue = null, gt(a) ? (p = !0, os(n)) : p = !1, n.memoizedState = f.state !== null && f.state !== void 0 ? f.state : null, fl(n), f.updater = Ss, n.stateNode = f, f._reactInternals = n, Pl(n, a, e, o), n = Rl(null, n, a, !0, p, o)) : (n.tag = 0, Ve && p && tl(n), dt(null, n, f, o), n = n.child), n; case 16: a = n.elementType; e: { switch (Es(e, n), e = n.pendingProps, f = a._init, a = f(a._payload), n.type = a, f = n.tag = R0(a), e = Ht(a, e), f) { case 0: n = bl(null, n, a, e, o); break e; case 1: n = Wd(null, n, a, e, o); break e; case 11: n = Od(null, n, a, e, o); break e; case 14: n = zd(null, n, a, Ht(a.type, e), o); break e }throw Error(i(306, a, "")) } return n; case 0: return a = n.type, f = n.pendingProps, f = n.elementType === a ? f : Ht(a, f), bl(e, n, a, f, o); case 1: return a = n.type, f = n.pendingProps, f = n.elementType === a ? f : Ht(a, f), Wd(e, n, a, f, o); case 3: e: { if (Hd(n), e === null) throw Error(i(387)); a = n.pendingProps, p = n.memoizedState, f = p.element, sd(e, n), ps(n, a, null, o); var y = n.memoizedState; if (a = y.element, p.isDehydrated) if (p = { element: a, isDehydrated: !1, cache: y.cache, pendingSuspenseBoundaries: y.pendingSuspenseBoundaries, transitions: y.transitions }, n.updateQueue.baseState = p, n.memoizedState = p, n.flags & 256) { f = $r(Error(i(423)), n), n = Kd(e, n, a, o, f); break e } else if (a !== f) { f = $r(Error(i(424)), n), n = Kd(e, n, a, o, f); break e } else for (Nt = Ln(n.stateNode.containerInfo.firstChild), Tt = n, Ve = !0, Wt = null, o = id(n, null, a, o), n.child = o; o;)o.flags = o.flags & -3 | 4096, o = o.sibling; else { if (_r(), a === f) { n = xn(e, n, o); break e } dt(e, n, a, o) } n = n.child } return n; case 5: return ud(n), e === null && il(n), a = n.type, f = n.pendingProps, p = e !== null ? e.memoizedProps : null, y = f.children, Xa(a, f) ? y = null : p !== null && Xa(a, p) && (n.flags |= 32), $d(e, n), dt(e, n, y, o), n.child; case 6: return e === null && il(n), null; case 13: return Gd(e, n, o); case 4: return dl(n, n.stateNode.containerInfo), a = n.pendingProps, e === null ? n.child = Or(n, null, a, o) : dt(e, n, a, o), n.child; case 11: return a = n.type, f = n.pendingProps, f = n.elementType === a ? f : Ht(a, f), Od(e, n, a, f, o); case 7: return dt(e, n, n.pendingProps, o), n.child; case 8: return dt(e, n, n.pendingProps.children, o), n.child; case 12: return dt(e, n, n.pendingProps.children, o), n.child; case 10: e: { if (a = n.type._context, f = n.pendingProps, p = n.memoizedProps, y = f.value, Me(fs, a._currentValue), a._currentValue = y, p !== null) if ($t(p.value, y)) { if (p.children === f.children && !mt.current) { n = xn(e, n, o); break e } } else for (p = n.child, p !== null && (p.return = n); p !== null;) { var S = p.dependencies; if (S !== null) { y = p.child; for (var T = S.firstContext; T !== null;) { if (T.context === a) { if (p.tag === 1) { T = vn(-1, o & -o), T.tag = 2; var F = p.updateQueue; if (F !== null) { F = F.shared; var B = F.pending; B === null ? T.next = T : (T.next = B.next, B.next = T), F.pending = T } } p.lanes |= o, T = p.alternate, T !== null && (T.lanes |= o), ul(p.return, o, n), S.lanes |= o; break } T = T.next } } else if (p.tag === 10) y = p.type === n.type ? null : p.child; else if (p.tag === 18) { if (y = p.return, y === null) throw Error(i(341)); y.lanes |= o, S = y.alternate, S !== null && (S.lanes |= o), ul(y, o, n), y = p.sibling } else y = p.child; if (y !== null) y.return = p; else for (y = p; y !== null;) { if (y === n) { y = null; break } if (p = y.sibling, p !== null) { p.return = y.return, y = p; break } y = y.return } p = y } dt(e, n, f.children, o), n = n.child } return n; case 9: return f = n.type, a = n.pendingProps.children, Br(n, o), f = Dt(f), a = a(f), n.flags |= 1, dt(e, n, a, o), n.child; case 14: return a = n.type, f = Ht(a, n.pendingProps), f = Ht(a.type, f), zd(e, n, a, f, o); case 15: return Bd(e, n, n.type, n.pendingProps, o); case 17: return a = n.type, f = n.pendingProps, f = n.elementType === a ? f : Ht(a, f), Es(e, n), n.tag = 1, gt(a) ? (e = !0, os(n)) : e = !1, Br(n, o), Md(n, a, f), Pl(n, a, f, o), Rl(null, n, a, !0, e, o); case 19: return Xd(e, n, o); case 22: return Ud(e, n, o) }throw Error(i(156, n.tag)) }; function xh(e, n) { return qc(e, n) } function b0(e, n, o, a) { this.tag = e, this.key = o, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = n, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = a, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function It(e, n, o, a) { return new b0(e, n, o, a) } function Xl(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function R0(e) { if (typeof e == "function") return Xl(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === Se) return 11; if (e === Te) return 14 } return 2 } function Wn(e, n) { var o = e.alternate; return o === null ? (o = It(e.tag, n, e.key, e.mode), o.elementType = e.elementType, o.type = e.type, o.stateNode = e.stateNode, o.alternate = e, e.alternate = o) : (o.pendingProps = n, o.type = e.type, o.flags = 0, o.subtreeFlags = 0, o.deletions = null), o.flags = e.flags & 14680064, o.childLanes = e.childLanes, o.lanes = e.lanes, o.child = e.child, o.memoizedProps = e.memoizedProps, o.memoizedState = e.memoizedState, o.updateQueue = e.updateQueue, n = e.dependencies, o.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }, o.sibling = e.sibling, o.index = e.index, o.ref = e.ref, o } function Ds(e, n, o, a, f, p) { var y = 2; if (a = e, typeof e == "function") Xl(e) && (y = 1); else if (typeof e == "string") y = 5; else e: switch (e) { case K: return fr(o.children, f, p, n); case I: y = 8, f |= 8; break; case Q: return e = It(12, o, n, f | 2), e.elementType = Q, e.lanes = p, e; case Re: return e = It(13, o, n, f), e.elementType = Re, e.lanes = p, e; case je: return e = It(19, o, n, f), e.elementType = je, e.lanes = p, e; case ae: return Fs(o, f, p, n); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case le: y = 10; break e; case pe: y = 9; break e; case Se: y = 11; break e; case Te: y = 14; break e; case ke: y = 16, a = null; break e }throw Error(i(130, e == null ? e : typeof e, "")) }return n = It(y, o, n, f), n.elementType = e, n.type = a, n.lanes = p, n } function fr(e, n, o, a) { return e = It(7, e, a, n), e.lanes = o, e } function Fs(e, n, o, a) { return e = It(22, e, a, n), e.elementType = ae, e.lanes = o, e.stateNode = { isHidden: !1 }, e } function Ql(e, n, o) { return e = It(6, e, null, n), e.lanes = o, e } function ql(e, n, o) { return n = It(4, e.children !== null ? e.children : [], e.key, n), n.lanes = o, n.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, n } function j0(e, n, o, a, f) { this.tag = n, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ca(0), this.expirationTimes = Ca(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ca(0), this.identifierPrefix = a, this.onRecoverableError = f, this.mutableSourceEagerHydrationData = null } function Zl(e, n, o, a, f, p, y, S, T) { return e = new j0(e, n, o, S, T), n === 1 ? (n = 1, p === !0 && (n |= 8)) : n = 0, p = It(3, null, null, n), e.current = p, p.stateNode = e, p.memoizedState = { element: a, isDehydrated: o, cache: null, transitions: null, pendingSuspenseBoundaries: null }, fl(p), e } function A0(e, n, o) { var a = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: H, key: a == null ? null : "" + a, children: e, containerInfo: n, implementation: o } } function wh(e) { if (!e) return Fn; e = e._reactInternals; e: { if (Jn(e) !== e || e.tag !== 1) throw Error(i(170)); var n = e; do { switch (n.tag) { case 3: n = n.stateNode.context; break e; case 1: if (gt(n.type)) { n = n.stateNode.__reactInternalMemoizedMergedChildContext; break e } }n = n.return } while (n !== null); throw Error(i(171)) } if (e.tag === 1) { var o = e.type; if (gt(o)) return Yf(e, o, n) } return n } function Sh(e, n, o, a, f, p, y, S, T) { return e = Zl(o, a, !0, e, f, p, y, S, T), e.context = wh(null), o = e.current, a = ht(), f = Un(o), p = vn(a, f), p.callback = n ?? null, _n(o, p, f), e.current.lanes = f, Ci(e, f, a), xt(e, a), e } function Vs(e, n, o, a) { var f = n.current, p = ht(), y = Un(f); return o = wh(o), n.context === null ? n.context = o : n.pendingContext = o, n = vn(p, y), n.payload = { element: e }, a = a === void 0 ? null : a, a !== null && (n.callback = a), e = _n(f, n, y), e !== null && (Yt(e, f, y, p), hs(e, f, y)), y } function Is(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function kh(e, n) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var o = e.retryLane; e.retryLane = o !== 0 && o < n ? o : n } } function Jl(e, n) { kh(e, n), (e = e.alternate) && kh(e, n) } function M0() { return null } var Eh = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function eu(e) { this._internalRoot = e } _s.prototype.render = eu.prototype.render = function (e) { var n = this._internalRoot; if (n === null) throw Error(i(409)); Vs(e, n, null, null) }, _s.prototype.unmount = eu.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var n = e.containerInfo; lr(function () { Vs(null, e, null, null) }), n[hn] = null } }; function _s(e) { this._internalRoot = e } _s.prototype.unstable_scheduleHydration = function (e) { if (e) { var n = sf(); e = { blockedOn: null, target: e, priority: n }; for (var o = 0; o < jn.length && n !== 0 && n < jn[o].priority; o++); jn.splice(o, 0, e), o === 0 && uf(e) } }; function tu(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function Os(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function Ch() { } function L0(e, n, o, a, f) { if (f) { if (typeof a == "function") { var p = a; a = function () { var F = Is(y); p.call(F) } } var y = Sh(n, a, e, 0, null, !1, !1, "", Ch); return e._reactRootContainer = y, e[hn] = y.current, _i(e.nodeType === 8 ? e.parentNode : e), lr(), y } for (; f = e.lastChild;)e.removeChild(f); if (typeof a == "function") { var S = a; a = function () { var F = Is(T); S.call(F) } } var T = Zl(e, 0, !1, null, null, !1, !1, "", Ch); return e._reactRootContainer = T, e[hn] = T.current, _i(e.nodeType === 8 ? e.parentNode : e), lr(function () { Vs(n, T, o, a) }), T } function zs(e, n, o, a, f) { var p = o._reactRootContainer; if (p) { var y = p; if (typeof f == "function") { var S = f; f = function () { var T = Is(y); S.call(T) } } Vs(n, y, e, f) } else y = L0(o, n, e, f, a); return Is(y) } rf = function (e) { switch (e.tag) { case 3: var n = e.stateNode; if (n.current.memoizedState.isDehydrated) { var o = Ei(n.pendingLanes); o !== 0 && (Pa(n, o | 1), xt(n, He()), (Ee & 6) === 0 && (Kr = He() + 500, Vn())) } break; case 13: lr(function () { var a = yn(e, 1); if (a !== null) { var f = ht(); Yt(a, e, 1, f) } }), Jl(e, 1) } }, Ta = function (e) { if (e.tag === 13) { var n = yn(e, 134217728); if (n !== null) { var o = ht(); Yt(n, e, 134217728, o) } Jl(e, 134217728) } }, of = function (e) { if (e.tag === 13) { var n = Un(e), o = yn(e, n); if (o !== null) { var a = ht(); Yt(o, e, n, a) } Jl(e, n) } }, sf = function () { return Ae }, af = function (e, n) { var o = Ae; try { return Ae = e, n() } finally { Ae = o } }, gi = function (e, n, o) { switch (n) { case "input": if (Et(e, o), n = o.name, o.type === "radio" && n != null) { for (o = e; o.parentNode;)o = o.parentNode; for (o = o.querySelectorAll("input[name=" + JSON.stringify("" + n) + '][type="radio"]'), n = 0; n < o.length; n++) { var a = o[n]; if (a !== e && a.form === e.form) { var f = rs(a); if (!f) throw Error(i(90)); Z(a), Et(a, f) } } } break; case "textarea": ci(e, o); break; case "select": n = o.value, n != null && jt(e, !!o.multiple, n, !1) } }, xi = Kl, Do = lr; var D0 = { usingClientEntryPoint: !1, Events: [Bi, Lr, rs, Lo, vi, Kl] }, to = { findFiberByHostInstance: er, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, F0 = { bundleType: to.bundleType, version: to.version, rendererPackageName: to.rendererPackageName, rendererConfig: to.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: U.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Xc(e), e === null ? null : e.stateNode }, findFiberByHostInstance: to.findFiberByHostInstance || M0, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Bs = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Bs.isDisabled && Bs.supportsFiber) try { _o = Bs.inject(F0), tn = Bs } catch { } } return wt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = D0, wt.createPortal = function (e, n) { var o = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!tu(n)) throw Error(i(200)); return A0(e, n, null, o) }, wt.createRoot = function (e, n) { if (!tu(e)) throw Error(i(299)); var o = !1, a = "", f = Eh; return n != null && (n.unstable_strictMode === !0 && (o = !0), n.identifierPrefix !== void 0 && (a = n.identifierPrefix), n.onRecoverableError !== void 0 && (f = n.onRecoverableError)), n = Zl(e, 1, !1, null, null, o, !1, a, f), e[hn] = n.current, _i(e.nodeType === 8 ? e.parentNode : e), new eu(n) }, wt.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var n = e._reactInternals; if (n === void 0) throw typeof e.render == "function" ? Error(i(188)) : (e = Object.keys(e).join(","), Error(i(268, e))); return e = Xc(n), e = e === null ? null : e.stateNode, e }, wt.flushSync = function (e) { return lr(e) }, wt.hydrate = function (e, n, o) { if (!Os(n)) throw Error(i(200)); return zs(null, e, n, !0, o) }, wt.hydrateRoot = function (e, n, o) { if (!tu(e)) throw Error(i(405)); var a = o != null && o.hydratedSources || null, f = !1, p = "", y = Eh; if (o != null && (o.unstable_strictMode === !0 && (f = !0), o.identifierPrefix !== void 0 && (p = o.identifierPrefix), o.onRecoverableError !== void 0 && (y = o.onRecoverableError)), n = Sh(n, null, e, 1, o ?? null, f, !1, p, y), e[hn] = n.current, _i(e), a) for (e = 0; e < a.length; e++)o = a[e], f = o._getVersion, f = f(o._source), n.mutableSourceEagerHydrationData == null ? n.mutableSourceEagerHydrationData = [o, f] : n.mutableSourceEagerHydrationData.push(o, f); return new _s(n) }, wt.render = function (e, n, o) { if (!Os(n)) throw Error(i(200)); return zs(null, e, n, !1, o) }, wt.unmountComponentAtNode = function (e) { if (!Os(e)) throw Error(i(40)); return e._reactRootContainer ? (lr(function () { zs(null, null, e, !1, function () { e._reactRootContainer = null, e[hn] = null }) }), !0) : !1 }, wt.unstable_batchedUpdates = Kl, wt.unstable_renderSubtreeIntoContainer = function (e, n, o, a) { if (!Os(o)) throw Error(i(200)); if (e == null || e._reactInternals === void 0) throw Error(i(38)); return zs(e, n, o, !1, a) }, wt.version = "18.3.1-next-f1338f8080-20240426", wt
} var Mh; function cm() { if (Mh) return iu.exports; Mh = 1; function t() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t) } catch (r) { console.error(r) } } return t(), iu.exports = W0(), iu.exports } var Lh; function H0() { if (Lh) return Us; Lh = 1; var t = cm(); return Us.createRoot = t.createRoot, Us.hydrateRoot = t.hydrateRoot, Us } var K0 = H0(), b = tc(); const G0 = _0(b), Y0 = I0({ __proto__: null, default: G0 }, [b]);/**
 * react-router v7.12.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */var Dh = "popstate"; function X0(t = {}) { function r(s, l) { let { pathname: c, search: u, hash: d } = s.location; return bu("", { pathname: c, search: u, hash: d }, l.state && l.state.usr || null, l.state && l.state.key || "default") } function i(s, l) { return typeof l == "string" ? l : po(l) } return q0(r, i, null, t) } function Ue(t, r) { if (t === !1 || t === null || typeof t > "u") throw new Error(r) } function Jt(t, r) { if (!t) { typeof console < "u" && console.warn(r); try { throw new Error(r) } catch { } } } function Q0() { return Math.random().toString(36).substring(2, 10) } function Fh(t, r) { return { usr: t.state, key: t.key, idx: r } } function bu(t, r, i = null, s) { return { pathname: typeof t == "string" ? t : t.pathname, search: "", hash: "", ...typeof r == "string" ? ri(r) : r, state: i, key: r && r.key || s || Q0() } } function po({ pathname: t = "/", search: r = "", hash: i = "" }) { return r && r !== "?" && (t += r.charAt(0) === "?" ? r : "?" + r), i && i !== "#" && (t += i.charAt(0) === "#" ? i : "#" + i), t } function ri(t) { let r = {}; if (t) { let i = t.indexOf("#"); i >= 0 && (r.hash = t.substring(i), t = t.substring(0, i)); let s = t.indexOf("?"); s >= 0 && (r.search = t.substring(s), t = t.substring(0, s)), t && (r.pathname = t) } return r } function q0(t, r, i, s = {}) { let { window: l = document.defaultView, v5Compat: c = !1 } = s, u = l.history, d = "POP", h = null, m = g(); m == null && (m = 0, u.replaceState({ ...u.state, idx: m }, "")); function g() { return (u.state || { idx: null }).idx } function v() { d = "POP"; let C = g(), P = C == null ? null : C - m; m = C, h && h({ action: d, location: N.location, delta: P }) } function w(C, P) { d = "PUSH"; let A = bu(N.location, C, P); m = g() + 1; let L = Fh(A, m), U = N.createHref(A); try { u.pushState(L, "", U) } catch (O) { if (O instanceof DOMException && O.name === "DataCloneError") throw O; l.location.assign(U) } c && h && h({ action: d, location: N.location, delta: 1 }) } function k(C, P) { d = "REPLACE"; let A = bu(N.location, C, P); m = g(); let L = Fh(A, m), U = N.createHref(A); u.replaceState(L, "", U), c && h && h({ action: d, location: N.location, delta: 0 }) } function E(C) { return Z0(C) } let N = { get action() { return d }, get location() { return t(l, u) }, listen(C) { if (h) throw new Error("A history only accepts one active listener"); return l.addEventListener(Dh, v), h = C, () => { l.removeEventListener(Dh, v), h = null } }, createHref(C) { return r(l, C) }, createURL: E, encodeLocation(C) { let P = E(C); return { pathname: P.pathname, search: P.search, hash: P.hash } }, push: w, replace: k, go(C) { return u.go(C) } }; return N } function Z0(t, r = !1) { let i = "http://localhost"; typeof window < "u" && (i = window.location.origin !== "null" ? window.location.origin : window.location.href), Ue(i, "No window.location.(origin|href) available to create URL"); let s = typeof t == "string" ? t : po(t); return s = s.replace(/ $/, "%20"), !r && s.startsWith("//") && (s = i + s), new URL(s, i) } function fm(t, r, i = "/") { return J0(t, r, i, !1) } function J0(t, r, i, s) { let l = typeof r == "string" ? ri(r) : r, c = En(l.pathname || "/", i); if (c == null) return null; let u = dm(t); ex(u); let d = null; for (let h = 0; d == null && h < u.length; ++h) { let m = fx(c); d = ux(u[h], m, s) } return d } function dm(t, r = [], i = [], s = "", l = !1) { let c = (u, d, h = l, m) => { let g = { relativePath: m === void 0 ? u.path || "" : m, caseSensitive: u.caseSensitive === !0, childrenIndex: d, route: u }; if (g.relativePath.startsWith("/")) { if (!g.relativePath.startsWith(s) && h) return; Ue(g.relativePath.startsWith(s), `Absolute route path "${g.relativePath}" nested under path "${s}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`), g.relativePath = g.relativePath.slice(s.length) } let v = kn([s, g.relativePath]), w = i.concat(g); u.children && u.children.length > 0 && (Ue(u.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${v}".`), dm(u.children, r, w, v, h)), !(u.path == null && !u.index) && r.push({ path: v, score: ax(v, u.index), routesMeta: w }) }; return t.forEach((u, d) => { if (u.path === "" || !u.path?.includes("?")) c(u, d); else for (let h of hm(u.path)) c(u, d, !0, h) }), r } function hm(t) { let r = t.split("/"); if (r.length === 0) return []; let [i, ...s] = r, l = i.endsWith("?"), c = i.replace(/\?$/, ""); if (s.length === 0) return l ? [c, ""] : [c]; let u = hm(s.join("/")), d = []; return d.push(...u.map(h => h === "" ? c : [c, h].join("/"))), l && d.push(...u), d.map(h => t.startsWith("/") && h === "" ? "/" : h) } function ex(t) { t.sort((r, i) => r.score !== i.score ? i.score - r.score : lx(r.routesMeta.map(s => s.childrenIndex), i.routesMeta.map(s => s.childrenIndex))) } var tx = /^:[\w-]+$/, nx = 3, rx = 2, ix = 1, ox = 10, sx = -2, Vh = t => t === "*"; function ax(t, r) { let i = t.split("/"), s = i.length; return i.some(Vh) && (s += sx), r && (s += rx), i.filter(l => !Vh(l)).reduce((l, c) => l + (tx.test(c) ? nx : c === "" ? ix : ox), s) } function lx(t, r) { return t.length === r.length && t.slice(0, -1).every((s, l) => s === r[l]) ? t[t.length - 1] - r[r.length - 1] : 0 } function ux(t, r, i = !1) { let { routesMeta: s } = t, l = {}, c = "/", u = []; for (let d = 0; d < s.length; ++d) { let h = s[d], m = d === s.length - 1, g = c === "/" ? r : r.slice(c.length) || "/", v = ta({ path: h.relativePath, caseSensitive: h.caseSensitive, end: m }, g), w = h.route; if (!v && m && i && !s[s.length - 1].route.index && (v = ta({ path: h.relativePath, caseSensitive: h.caseSensitive, end: !1 }, g)), !v) return null; Object.assign(l, v.params), u.push({ params: l, pathname: kn([c, v.pathname]), pathnameBase: mx(kn([c, v.pathnameBase])), route: w }), v.pathnameBase !== "/" && (c = kn([c, v.pathnameBase])) } return u } function ta(t, r) { typeof t == "string" && (t = { path: t, caseSensitive: !1, end: !0 }); let [i, s] = cx(t.path, t.caseSensitive, t.end), l = r.match(i); if (!l) return null; let c = l[0], u = c.replace(/(.)\/+$/, "$1"), d = l.slice(1); return { params: s.reduce((m, { paramName: g, isOptional: v }, w) => { if (g === "*") { let E = d[w] || ""; u = c.slice(0, c.length - E.length).replace(/(.)\/+$/, "$1") } const k = d[w]; return v && !k ? m[g] = void 0 : m[g] = (k || "").replace(/%2F/g, "/"), m }, {}), pathname: c, pathnameBase: u, pattern: t } } function cx(t, r = !1, i = !0) { Jt(t === "*" || !t.endsWith("*") || t.endsWith("/*"), `Route path "${t}" will be treated as if it were "${t.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${t.replace(/\*$/, "/*")}".`); let s = [], l = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (u, d, h) => (s.push({ paramName: d, isOptional: h != null }), h ? "/?([^\\/]+)?" : "/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2"); return t.endsWith("*") ? (s.push({ paramName: "*" }), l += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : i ? l += "\\/*$" : t !== "" && t !== "/" && (l += "(?:(?=\\/|$))"), [new RegExp(l, r ? void 0 : "i"), s] } function fx(t) { try { return t.split("/").map(r => decodeURIComponent(r).replace(/\//g, "%2F")).join("/") } catch (r) { return Jt(!1, `The URL path "${t}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${r}).`), t } } function En(t, r) { if (r === "/") return t; if (!t.toLowerCase().startsWith(r.toLowerCase())) return null; let i = r.endsWith("/") ? r.length - 1 : r.length, s = t.charAt(i); return s && s !== "/" ? null : t.slice(i) || "/" } var pm = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, dx = t => pm.test(t); function hx(t, r = "/") { let { pathname: i, search: s = "", hash: l = "" } = typeof t == "string" ? ri(t) : t, c; if (i) if (dx(i)) c = i; else { if (i.includes("//")) { let u = i; i = i.replace(/\/\/+/g, "/"), Jt(!1, `Pathnames cannot have embedded double slashes - normalizing ${u} -> ${i}`) } i.startsWith("/") ? c = Ih(i.substring(1), "/") : c = Ih(i, r) } else c = r; return { pathname: c, search: gx(s), hash: yx(l) } } function Ih(t, r) { let i = r.replace(/\/+$/, "").split("/"); return t.split("/").forEach(l => { l === ".." ? i.length > 1 && i.pop() : l !== "." && i.push(l) }), i.length > 1 ? i.join("/") : "/" } function au(t, r, i, s) { return `Cannot include a '${t}' character in a manually specified \`to.${r}\` field [${JSON.stringify(s)}].  Please separate it out to the \`to.${i}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.` } function px(t) { return t.filter((r, i) => i === 0 || r.route.path && r.route.path.length > 0) } function mm(t) { let r = px(t); return r.map((i, s) => s === r.length - 1 ? i.pathname : i.pathnameBase) } function gm(t, r, i, s = !1) { let l; typeof t == "string" ? l = ri(t) : (l = { ...t }, Ue(!l.pathname || !l.pathname.includes("?"), au("?", "pathname", "search", l)), Ue(!l.pathname || !l.pathname.includes("#"), au("#", "pathname", "hash", l)), Ue(!l.search || !l.search.includes("#"), au("#", "search", "hash", l))); let c = t === "" || l.pathname === "", u = c ? "/" : l.pathname, d; if (u == null) d = i; else { let v = r.length - 1; if (!s && u.startsWith("..")) { let w = u.split("/"); for (; w[0] === "..";)w.shift(), v -= 1; l.pathname = w.join("/") } d = v >= 0 ? r[v] : "/" } let h = hx(l, d), m = u && u !== "/" && u.endsWith("/"), g = (c || u === ".") && i.endsWith("/"); return !h.pathname.endsWith("/") && (m || g) && (h.pathname += "/"), h } var kn = t => t.join("/").replace(/\/\/+/g, "/"), mx = t => t.replace(/\/+$/, "").replace(/^\/*/, "/"), gx = t => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t, yx = t => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t, vx = class { constructor(t, r, i, s = !1) { this.status = t, this.statusText = r || "", this.internal = s, i instanceof Error ? (this.data = i.toString(), this.error = i) : this.data = i } }; function xx(t) { return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.internal == "boolean" && "data" in t } function wx(t) { return t.map(r => r.route.path).filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/" } var ym = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"; function vm(t, r) { let i = t; if (typeof i != "string" || !pm.test(i)) return { absoluteURL: void 0, isExternal: !1, to: i }; let s = i, l = !1; if (ym) try { let c = new URL(window.location.href), u = i.startsWith("//") ? new URL(c.protocol + i) : new URL(i), d = En(u.pathname, r); u.origin === c.origin && d != null ? i = d + u.search + u.hash : l = !0 } catch { Jt(!1, `<Link to="${i}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`) } return { absoluteURL: s, isExternal: l, to: i } } Object.getOwnPropertyNames(Object.prototype).sort().join("\0"); var xm = ["POST", "PUT", "PATCH", "DELETE"]; new Set(xm); var Sx = ["GET", ...xm]; new Set(Sx); var ii = b.createContext(null); ii.displayName = "DataRouter"; var da = b.createContext(null); da.displayName = "DataRouterState"; var kx = b.createContext(!1), wm = b.createContext({ isTransitioning: !1 }); wm.displayName = "ViewTransition"; var Ex = b.createContext(new Map); Ex.displayName = "Fetchers"; var Cx = b.createContext(null); Cx.displayName = "Await"; var Bt = b.createContext(null); Bt.displayName = "Navigation"; var Eo = b.createContext(null); Eo.displayName = "Location"; var un = b.createContext({ outlet: null, matches: [], isDataRoute: !1 }); un.displayName = "Route"; var nc = b.createContext(null); nc.displayName = "RouteError"; var Sm = "REACT_ROUTER_ERROR", Px = "REDIRECT", Tx = "ROUTE_ERROR_RESPONSE"; function Nx(t) { if (t.startsWith(`${Sm}:${Px}:{`)) try { let r = JSON.parse(t.slice(28)); if (typeof r == "object" && r && typeof r.status == "number" && typeof r.statusText == "string" && typeof r.location == "string" && typeof r.reloadDocument == "boolean" && typeof r.replace == "boolean") return r } catch { } } function bx(t) { if (t.startsWith(`${Sm}:${Tx}:{`)) try { let r = JSON.parse(t.slice(40)); if (typeof r == "object" && r && typeof r.status == "number" && typeof r.statusText == "string") return new vx(r.status, r.statusText, r.data) } catch { } } function Rx(t, { relative: r } = {}) { Ue(Co(), "useHref() may be used only in the context of a <Router> component."); let { basename: i, navigator: s } = b.useContext(Bt), { hash: l, pathname: c, search: u } = Po(t, { relative: r }), d = c; return i !== "/" && (d = c === "/" ? i : kn([i, c])), s.createHref({ pathname: d, search: u, hash: l }) } function Co() { return b.useContext(Eo) != null } function Tn() { return Ue(Co(), "useLocation() may be used only in the context of a <Router> component."), b.useContext(Eo).location } var km = "You should call navigate() in a React.useEffect(), not when your component is first rendered."; function Em(t) { b.useContext(Bt).static || b.useLayoutEffect(t) } function Cm() { let { isDataRoute: t } = b.useContext(un); return t ? Wx() : jx() } function jx() { Ue(Co(), "useNavigate() may be used only in the context of a <Router> component."); let t = b.useContext(ii), { basename: r, navigator: i } = b.useContext(Bt), { matches: s } = b.useContext(un), { pathname: l } = Tn(), c = JSON.stringify(mm(s)), u = b.useRef(!1); return Em(() => { u.current = !0 }), b.useCallback((h, m = {}) => { if (Jt(u.current, km), !u.current) return; if (typeof h == "number") { i.go(h); return } let g = gm(h, JSON.parse(c), l, m.relative === "path"); t == null && r !== "/" && (g.pathname = g.pathname === "/" ? r : kn([r, g.pathname])), (m.replace ? i.replace : i.push)(g, m.state, m) }, [r, i, c, l, t]) } var Ax = b.createContext(null); function Mx(t) { let r = b.useContext(un).outlet; return b.useMemo(() => r && b.createElement(Ax.Provider, { value: t }, r), [r, t]) } function Po(t, { relative: r } = {}) { let { matches: i } = b.useContext(un), { pathname: s } = Tn(), l = JSON.stringify(mm(i)); return b.useMemo(() => gm(t, JSON.parse(l), s, r === "path"), [t, l, s, r]) } function Lx(t, r) { return Pm(t, r) } function Pm(t, r, i, s, l) {
  Ue(Co(), "useRoutes() may be used only in the context of a <Router> component."); let { navigator: c } = b.useContext(Bt), { matches: u } = b.useContext(un), d = u[u.length - 1], h = d ? d.params : {}, m = d ? d.pathname : "/", g = d ? d.pathnameBase : "/", v = d && d.route; {
    let A = v && v.path || ""; Nm(m, !v || A.endsWith("*") || A.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${m}" (under <Route path="${A}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${A}"> to <Route path="${A === "/" ? "*" : `${A}/*`}">.`)
  } let w = Tn(), k; if (r) { let A = typeof r == "string" ? ri(r) : r; Ue(g === "/" || A.pathname?.startsWith(g), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${g}" but pathname "${A.pathname}" was given in the \`location\` prop.`), k = A } else k = w; let E = k.pathname || "/", N = E; if (g !== "/") { let A = g.replace(/^\//, "").split("/"); N = "/" + E.replace(/^\//, "").split("/").slice(A.length).join("/") } let C = fm(t, { pathname: N }); Jt(v || C != null, `No routes matched location "${k.pathname}${k.search}${k.hash}" `), Jt(C == null || C[C.length - 1].route.element !== void 0 || C[C.length - 1].route.Component !== void 0 || C[C.length - 1].route.lazy !== void 0, `Matched leaf route at location "${k.pathname}${k.search}${k.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`); let P = _x(C && C.map(A => Object.assign({}, A, { params: Object.assign({}, h, A.params), pathname: kn([g, c.encodeLocation ? c.encodeLocation(A.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : A.pathname]), pathnameBase: A.pathnameBase === "/" ? g : kn([g, c.encodeLocation ? c.encodeLocation(A.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : A.pathnameBase]) })), u, i, s, l); return r && P ? b.createElement(Eo.Provider, { value: { location: { pathname: "/", search: "", hash: "", state: null, key: "default", ...k }, navigationType: "POP" } }, P) : P
} function Dx() { let t = $x(), r = xx(t) ? `${t.status} ${t.statusText}` : t instanceof Error ? t.message : JSON.stringify(t), i = t instanceof Error ? t.stack : null, s = "rgba(200,200,200, 0.5)", l = { padding: "0.5rem", backgroundColor: s }, c = { padding: "2px 4px", backgroundColor: s }, u = null; return console.error("Error handled by React Router default ErrorBoundary:", t), u = b.createElement(b.Fragment, null, b.createElement("p", null, " Hey developer "), b.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", b.createElement("code", { style: c }, "ErrorBoundary"), " or", " ", b.createElement("code", { style: c }, "errorElement"), " prop on your route.")), b.createElement(b.Fragment, null, b.createElement("h2", null, "Unexpected Application Error!"), b.createElement("h3", { style: { fontStyle: "italic" } }, r), i ? b.createElement("pre", { style: l }, i) : null, u) } var Fx = b.createElement(Dx, null), Tm = class extends b.Component { constructor(t) { super(t), this.state = { location: t.location, revalidation: t.revalidation, error: t.error } } static getDerivedStateFromError(t) { return { error: t } } static getDerivedStateFromProps(t, r) { return r.location !== t.location || r.revalidation !== "idle" && t.revalidation === "idle" ? { error: t.error, location: t.location, revalidation: t.revalidation } : { error: t.error !== void 0 ? t.error : r.error, location: r.location, revalidation: t.revalidation || r.revalidation } } componentDidCatch(t, r) { this.props.onError ? this.props.onError(t, r) : console.error("React Router caught the following error during render", t) } render() { let t = this.state.error; if (this.context && typeof t == "object" && t && "digest" in t && typeof t.digest == "string") { const i = bx(t.digest); i && (t = i) } let r = t !== void 0 ? b.createElement(un.Provider, { value: this.props.routeContext }, b.createElement(nc.Provider, { value: t, children: this.props.component })) : this.props.children; return this.context ? b.createElement(Vx, { error: t }, r) : r } }; Tm.contextType = kx; var lu = new WeakMap; function Vx({ children: t, error: r }) { let { basename: i } = b.useContext(Bt); if (typeof r == "object" && r && "digest" in r && typeof r.digest == "string") { let s = Nx(r.digest); if (s) { let l = lu.get(r); if (l) throw l; let c = vm(s.location, i); if (ym && !lu.get(r)) if (c.isExternal || s.reloadDocument) window.location.href = c.absoluteURL || c.to; else { const u = Promise.resolve().then(() => window.__reactRouterDataRouter.navigate(c.to, { replace: s.replace })); throw lu.set(r, u), u } return b.createElement("meta", { httpEquiv: "refresh", content: `0;url=${c.absoluteURL || c.to}` }) } } return t } function Ix({ routeContext: t, match: r, children: i }) { let s = b.useContext(ii); return s && s.static && s.staticContext && (r.route.errorElement || r.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = r.route.id), b.createElement(un.Provider, { value: t }, i) } function _x(t, r = [], i = null, s = null, l = null) { if (t == null) { if (!i) return null; if (i.errors) t = i.matches; else if (r.length === 0 && !i.initialized && i.matches.length > 0) t = i.matches; else return null } let c = t, u = i?.errors; if (u != null) { let g = c.findIndex(v => v.route.id && u?.[v.route.id] !== void 0); Ue(g >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(u).join(",")}`), c = c.slice(0, Math.min(c.length, g + 1)) } let d = !1, h = -1; if (i) for (let g = 0; g < c.length; g++) { let v = c[g]; if ((v.route.HydrateFallback || v.route.hydrateFallbackElement) && (h = g), v.route.id) { let { loaderData: w, errors: k } = i, E = v.route.loader && !w.hasOwnProperty(v.route.id) && (!k || k[v.route.id] === void 0); if (v.route.lazy || E) { d = !0, h >= 0 ? c = c.slice(0, h + 1) : c = [c[0]]; break } } } let m = i && s ? (g, v) => { s(g, { location: i.location, params: i.matches?.[0]?.params ?? {}, unstable_pattern: wx(i.matches), errorInfo: v }) } : void 0; return c.reduceRight((g, v, w) => { let k, E = !1, N = null, C = null; i && (k = u && v.route.id ? u[v.route.id] : void 0, N = v.route.errorElement || Fx, d && (h < 0 && w === 0 ? (Nm("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), E = !0, C = null) : h === w && (E = !0, C = v.route.hydrateFallbackElement || null))); let P = r.concat(c.slice(0, w + 1)), A = () => { let L; return k ? L = N : E ? L = C : v.route.Component ? L = b.createElement(v.route.Component, null) : v.route.element ? L = v.route.element : L = g, b.createElement(Ix, { match: v, routeContext: { outlet: g, matches: P, isDataRoute: i != null }, children: L }) }; return i && (v.route.ErrorBoundary || v.route.errorElement || w === 0) ? b.createElement(Tm, { location: i.location, revalidation: i.revalidation, component: N, error: k, children: A(), routeContext: { outlet: null, matches: P, isDataRoute: !0 }, onError: m }) : A() }, null) } function rc(t) { return `${t} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function Ox(t) { let r = b.useContext(ii); return Ue(r, rc(t)), r } function zx(t) { let r = b.useContext(da); return Ue(r, rc(t)), r } function Bx(t) { let r = b.useContext(un); return Ue(r, rc(t)), r } function ic(t) { let r = Bx(t), i = r.matches[r.matches.length - 1]; return Ue(i.route.id, `${t} can only be used on routes that contain a unique "id"`), i.route.id } function Ux() { return ic("useRouteId") } function $x() { let t = b.useContext(nc), r = zx("useRouteError"), i = ic("useRouteError"); return t !== void 0 ? t : r.errors?.[i] } function Wx() { let { router: t } = Ox("useNavigate"), r = ic("useNavigate"), i = b.useRef(!1); return Em(() => { i.current = !0 }), b.useCallback(async (l, c = {}) => { Jt(i.current, km), i.current && (typeof l == "number" ? await t.navigate(l) : await t.navigate(l, { fromRouteId: r, ...c })) }, [t, r]) } var _h = {}; function Nm(t, r, i) { !r && !_h[t] && (_h[t] = !0, Jt(!1, i)) } b.memo(Hx); function Hx({ routes: t, future: r, state: i, onError: s }) { return Pm(t, void 0, i, s, r) } function Kx(t) { return Mx(t.context) } function pr(t) { Ue(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") } function Gx({ basename: t = "/", children: r = null, location: i, navigationType: s = "POP", navigator: l, static: c = !1, unstable_useTransitions: u }) { Ue(!Co(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."); let d = t.replace(/^\/*/, "/"), h = b.useMemo(() => ({ basename: d, navigator: l, static: c, unstable_useTransitions: u, future: {} }), [d, l, c, u]); typeof i == "string" && (i = ri(i)); let { pathname: m = "/", search: g = "", hash: v = "", state: w = null, key: k = "default" } = i, E = b.useMemo(() => { let N = En(m, d); return N == null ? null : { location: { pathname: N, search: g, hash: v, state: w, key: k }, navigationType: s } }, [d, m, g, v, w, k, s]); return Jt(E != null, `<Router basename="${d}"> is not able to match the URL "${m}${g}${v}" because it does not start with the basename, so the <Router> won't render anything.`), E == null ? null : b.createElement(Bt.Provider, { value: h }, b.createElement(Eo.Provider, { children: r, value: E })) } function Yx({ children: t, location: r }) { return Lx(Ru(t), r) } function Ru(t, r = []) { let i = []; return b.Children.forEach(t, (s, l) => { if (!b.isValidElement(s)) return; let c = [...r, l]; if (s.type === b.Fragment) { i.push.apply(i, Ru(s.props.children, c)); return } Ue(s.type === pr, `[${typeof s.type == "string" ? s.type : s.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`), Ue(!s.props.index || !s.props.children, "An index route cannot have child routes."); let u = { id: s.props.id || c.join("-"), caseSensitive: s.props.caseSensitive, element: s.props.element, Component: s.props.Component, index: s.props.index, path: s.props.path, middleware: s.props.middleware, loader: s.props.loader, action: s.props.action, hydrateFallbackElement: s.props.hydrateFallbackElement, HydrateFallback: s.props.HydrateFallback, errorElement: s.props.errorElement, ErrorBoundary: s.props.ErrorBoundary, hasErrorBoundary: s.props.hasErrorBoundary === !0 || s.props.ErrorBoundary != null || s.props.errorElement != null, shouldRevalidate: s.props.shouldRevalidate, handle: s.props.handle, lazy: s.props.lazy }; s.props.children && (u.children = Ru(s.props.children, c)), i.push(u) }), i } var Xs = "get", Qs = "application/x-www-form-urlencoded"; function ha(t) { return typeof HTMLElement < "u" && t instanceof HTMLElement } function Xx(t) { return ha(t) && t.tagName.toLowerCase() === "button" } function Qx(t) { return ha(t) && t.tagName.toLowerCase() === "form" } function qx(t) { return ha(t) && t.tagName.toLowerCase() === "input" } function Zx(t) { return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) } function Jx(t, r) { return t.button === 0 && (!r || r === "_self") && !Zx(t) } var $s = null; function e1() { if ($s === null) try { new FormData(document.createElement("form"), 0), $s = !1 } catch { $s = !0 } return $s } var t1 = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]); function uu(t) { return t != null && !t1.has(t) ? (Jt(!1, `"${t}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Qs}"`), null) : t } function n1(t, r) { let i, s, l, c, u; if (Qx(t)) { let d = t.getAttribute("action"); s = d ? En(d, r) : null, i = t.getAttribute("method") || Xs, l = uu(t.getAttribute("enctype")) || Qs, c = new FormData(t) } else if (Xx(t) || qx(t) && (t.type === "submit" || t.type === "image")) { let d = t.form; if (d == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>'); let h = t.getAttribute("formaction") || d.getAttribute("action"); if (s = h ? En(h, r) : null, i = t.getAttribute("formmethod") || d.getAttribute("method") || Xs, l = uu(t.getAttribute("formenctype")) || uu(d.getAttribute("enctype")) || Qs, c = new FormData(d, t), !e1()) { let { name: m, type: g, value: v } = t; if (g === "image") { let w = m ? `${m}.` : ""; c.append(`${w}x`, "0"), c.append(`${w}y`, "0") } else m && c.append(m, v) } } else { if (ha(t)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">'); i = Xs, s = null, l = Qs, u = t } return c && l === "text/plain" && (u = c, c = void 0), { action: s, method: i.toLowerCase(), encType: l, formData: c, body: u } } Object.getOwnPropertyNames(Object.prototype).sort().join("\0"); function oc(t, r) { if (t === !1 || t === null || typeof t > "u") throw new Error(r) } function r1(t, r, i, s) { let l = typeof t == "string" ? new URL(t, typeof window > "u" ? "server://singlefetch/" : window.location.origin) : t; return i ? l.pathname.endsWith("/") ? l.pathname = `${l.pathname}_.${s}` : l.pathname = `${l.pathname}.${s}` : l.pathname === "/" ? l.pathname = `_root.${s}` : r && En(l.pathname, r) === "/" ? l.pathname = `${r.replace(/\/$/, "")}/_root.${s}` : l.pathname = `${l.pathname.replace(/\/$/, "")}.${s}`, l } async function i1(t, r) { if (t.id in r) return r[t.id]; try { let i = await import(t.module); return r[t.id] = i, i } catch (i) { return console.error(`Error loading route module \`${t.module}\`, reloading page...`), console.error(i), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => { }) } } function o1(t) { return t == null ? !1 : t.href == null ? t.rel === "preload" && typeof t.imageSrcSet == "string" && typeof t.imageSizes == "string" : typeof t.rel == "string" && typeof t.href == "string" } async function s1(t, r, i) { let s = await Promise.all(t.map(async l => { let c = r.routes[l.route.id]; if (c) { let u = await i1(c, i); return u.links ? u.links() : [] } return [] })); return c1(s.flat(1).filter(o1).filter(l => l.rel === "stylesheet" || l.rel === "preload").map(l => l.rel === "stylesheet" ? { ...l, rel: "prefetch", as: "style" } : { ...l, rel: "prefetch" })) } function Oh(t, r, i, s, l, c) { let u = (h, m) => i[m] ? h.route.id !== i[m].route.id : !0, d = (h, m) => i[m].pathname !== h.pathname || i[m].route.path?.endsWith("*") && i[m].params["*"] !== h.params["*"]; return c === "assets" ? r.filter((h, m) => u(h, m) || d(h, m)) : c === "data" ? r.filter((h, m) => { let g = s.routes[h.route.id]; if (!g || !g.hasLoader) return !1; if (u(h, m) || d(h, m)) return !0; if (h.route.shouldRevalidate) { let v = h.route.shouldRevalidate({ currentUrl: new URL(l.pathname + l.search + l.hash, window.origin), currentParams: i[0]?.params || {}, nextUrl: new URL(t, window.origin), nextParams: h.params, defaultShouldRevalidate: !0 }); if (typeof v == "boolean") return v } return !0 }) : [] } function a1(t, r, { includeHydrateFallback: i } = {}) { return l1(t.map(s => { let l = r.routes[s.route.id]; if (!l) return []; let c = [l.module]; return l.clientActionModule && (c = c.concat(l.clientActionModule)), l.clientLoaderModule && (c = c.concat(l.clientLoaderModule)), i && l.hydrateFallbackModule && (c = c.concat(l.hydrateFallbackModule)), l.imports && (c = c.concat(l.imports)), c }).flat(1)) } function l1(t) { return [...new Set(t)] } function u1(t) { let r = {}, i = Object.keys(t).sort(); for (let s of i) r[s] = t[s]; return r } function c1(t, r) { let i = new Set; return new Set(r), t.reduce((s, l) => { let c = JSON.stringify(u1(l)); return i.has(c) || (i.add(c), s.push({ key: c, link: l })), s }, []) } function bm() { let t = b.useContext(ii); return oc(t, "You must render this element inside a <DataRouterContext.Provider> element"), t } function f1() { let t = b.useContext(da); return oc(t, "You must render this element inside a <DataRouterStateContext.Provider> element"), t } var sc = b.createContext(void 0); sc.displayName = "FrameworkContext"; function Rm() { let t = b.useContext(sc); return oc(t, "You must render this element inside a <HydratedRouter> element"), t } function d1(t, r) { let i = b.useContext(sc), [s, l] = b.useState(!1), [c, u] = b.useState(!1), { onFocus: d, onBlur: h, onMouseEnter: m, onMouseLeave: g, onTouchStart: v } = r, w = b.useRef(null); b.useEffect(() => { if (t === "render" && u(!0), t === "viewport") { let N = P => { P.forEach(A => { u(A.isIntersecting) }) }, C = new IntersectionObserver(N, { threshold: .5 }); return w.current && C.observe(w.current), () => { C.disconnect() } } }, [t]), b.useEffect(() => { if (s) { let N = setTimeout(() => { u(!0) }, 100); return () => { clearTimeout(N) } } }, [s]); let k = () => { l(!0) }, E = () => { l(!1), u(!1) }; return i ? t !== "intent" ? [c, w, {}] : [c, w, { onFocus: ro(d, k), onBlur: ro(h, E), onMouseEnter: ro(m, k), onMouseLeave: ro(g, E), onTouchStart: ro(v, k) }] : [!1, w, {}] } function ro(t, r) { return i => { t && t(i), i.defaultPrevented || r(i) } } function h1({ page: t, ...r }) { let { router: i } = bm(), s = b.useMemo(() => fm(i.routes, t, i.basename), [i.routes, t, i.basename]); return s ? b.createElement(m1, { page: t, matches: s, ...r }) : null } function p1(t) { let { manifest: r, routeModules: i } = Rm(), [s, l] = b.useState([]); return b.useEffect(() => { let c = !1; return s1(t, r, i).then(u => { c || l(u) }), () => { c = !0 } }, [t, r, i]), s } function m1({ page: t, matches: r, ...i }) { let s = Tn(), { future: l, manifest: c, routeModules: u } = Rm(), { basename: d } = bm(), { loaderData: h, matches: m } = f1(), g = b.useMemo(() => Oh(t, r, m, c, s, "data"), [t, r, m, c, s]), v = b.useMemo(() => Oh(t, r, m, c, s, "assets"), [t, r, m, c, s]), w = b.useMemo(() => { if (t === s.pathname + s.search + s.hash) return []; let N = new Set, C = !1; if (r.forEach(A => { let L = c.routes[A.route.id]; !L || !L.hasLoader || (!g.some(U => U.route.id === A.route.id) && A.route.id in h && u[A.route.id]?.shouldRevalidate || L.hasClientLoader ? C = !0 : N.add(A.route.id)) }), N.size === 0) return []; let P = r1(t, d, l.unstable_trailingSlashAwareDataRequests, "data"); return C && N.size > 0 && P.searchParams.set("_routes", r.filter(A => N.has(A.route.id)).map(A => A.route.id).join(",")), [P.pathname + P.search] }, [d, l.unstable_trailingSlashAwareDataRequests, h, s, c, g, r, t, u]), k = b.useMemo(() => a1(v, c), [v, c]), E = p1(v); return b.createElement(b.Fragment, null, w.map(N => b.createElement("link", { key: N, rel: "prefetch", as: "fetch", href: N, ...i })), k.map(N => b.createElement("link", { key: N, rel: "modulepreload", href: N, ...i })), E.map(({ key: N, link: C }) => b.createElement("link", { key: N, nonce: i.nonce, ...C }))) } function g1(...t) { return r => { t.forEach(i => { typeof i == "function" ? i(r) : i != null && (i.current = r) }) } } var y1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"; try { y1 && (window.__reactRouterVersion = "7.12.0") } catch { } function v1({ basename: t, children: r, unstable_useTransitions: i, window: s }) { let l = b.useRef(); l.current == null && (l.current = X0({ window: s, v5Compat: !0 })); let c = l.current, [u, d] = b.useState({ action: c.action, location: c.location }), h = b.useCallback(m => { i === !1 ? d(m) : b.startTransition(() => d(m)) }, [i]); return b.useLayoutEffect(() => c.listen(h), [c, h]), b.createElement(Gx, { basename: t, children: r, location: u.location, navigationType: u.action, navigator: c, unstable_useTransitions: i }) } var jm = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, qt = b.forwardRef(function ({ onClick: r, discover: i = "render", prefetch: s = "none", relative: l, reloadDocument: c, replace: u, state: d, target: h, to: m, preventScrollReset: g, viewTransition: v, unstable_defaultShouldRevalidate: w, ...k }, E) { let { basename: N, unstable_useTransitions: C } = b.useContext(Bt), P = typeof m == "string" && jm.test(m), A = vm(m, N); m = A.to; let L = Rx(m, { relative: l }), [U, O, H] = d1(s, k), K = k1(m, { replace: u, state: d, target: h, preventScrollReset: g, relative: l, viewTransition: v, unstable_defaultShouldRevalidate: w, unstable_useTransitions: C }); function I(le) { r && r(le), le.defaultPrevented || K(le) } let Q = b.createElement("a", { ...k, ...H, href: A.absoluteURL || L, onClick: A.isExternal || c ? r : I, ref: g1(E, O), target: h, "data-discover": !P && i === "render" ? "true" : void 0 }); return U && !P ? b.createElement(b.Fragment, null, Q, b.createElement(h1, { page: L })) : Q }); qt.displayName = "Link"; var x1 = b.forwardRef(function ({ "aria-current": r = "page", caseSensitive: i = !1, className: s = "", end: l = !1, style: c, to: u, viewTransition: d, children: h, ...m }, g) { let v = Po(u, { relative: m.relative }), w = Tn(), k = b.useContext(da), { navigator: E, basename: N } = b.useContext(Bt), C = k != null && N1(v) && d === !0, P = E.encodeLocation ? E.encodeLocation(v).pathname : v.pathname, A = w.pathname, L = k && k.navigation && k.navigation.location ? k.navigation.location.pathname : null; i || (A = A.toLowerCase(), L = L ? L.toLowerCase() : null, P = P.toLowerCase()), L && N && (L = En(L, N) || L); const U = P !== "/" && P.endsWith("/") ? P.length - 1 : P.length; let O = A === P || !l && A.startsWith(P) && A.charAt(U) === "/", H = L != null && (L === P || !l && L.startsWith(P) && L.charAt(P.length) === "/"), K = { isActive: O, isPending: H, isTransitioning: C }, I = O ? r : void 0, Q; typeof s == "function" ? Q = s(K) : Q = [s, O ? "active" : null, H ? "pending" : null, C ? "transitioning" : null].filter(Boolean).join(" "); let le = typeof c == "function" ? c(K) : c; return b.createElement(qt, { ...m, "aria-current": I, className: Q, ref: g, style: le, to: u, viewTransition: d }, typeof h == "function" ? h(K) : h) }); x1.displayName = "NavLink"; var w1 = b.forwardRef(({ discover: t = "render", fetcherKey: r, navigate: i, reloadDocument: s, replace: l, state: c, method: u = Xs, action: d, onSubmit: h, relative: m, preventScrollReset: g, viewTransition: v, unstable_defaultShouldRevalidate: w, ...k }, E) => { let { unstable_useTransitions: N } = b.useContext(Bt), C = P1(), P = T1(d, { relative: m }), A = u.toLowerCase() === "get" ? "get" : "post", L = typeof d == "string" && jm.test(d), U = O => { if (h && h(O), O.defaultPrevented) return; O.preventDefault(); let H = O.nativeEvent.submitter, K = H?.getAttribute("formmethod") || u, I = () => C(H || O.currentTarget, { fetcherKey: r, method: K, navigate: i, replace: l, state: c, relative: m, preventScrollReset: g, viewTransition: v, unstable_defaultShouldRevalidate: w }); N && i !== !1 ? b.startTransition(() => I()) : I() }; return b.createElement("form", { ref: E, method: A, action: P, onSubmit: s ? h : U, ...k, "data-discover": !L && t === "render" ? "true" : void 0 }) }); w1.displayName = "Form"; function S1(t) { return `${t} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function Am(t) { let r = b.useContext(ii); return Ue(r, S1(t)), r } function k1(t, { target: r, replace: i, state: s, preventScrollReset: l, relative: c, viewTransition: u, unstable_defaultShouldRevalidate: d, unstable_useTransitions: h } = {}) { let m = Cm(), g = Tn(), v = Po(t, { relative: c }); return b.useCallback(w => { if (Jx(w, r)) { w.preventDefault(); let k = i !== void 0 ? i : po(g) === po(v), E = () => m(t, { replace: k, state: s, preventScrollReset: l, relative: c, viewTransition: u, unstable_defaultShouldRevalidate: d }); h ? b.startTransition(() => E()) : E() } }, [g, m, v, i, s, r, t, l, c, u, d, h]) } var E1 = 0, C1 = () => `__${String(++E1)}__`; function P1() { let { router: t } = Am("useSubmit"), { basename: r } = b.useContext(Bt), i = Ux(), s = t.fetch, l = t.navigate; return b.useCallback(async (c, u = {}) => { let { action: d, method: h, encType: m, formData: g, body: v } = n1(c, r); if (u.navigate === !1) { let w = u.fetcherKey || C1(); await s(w, i, u.action || d, { unstable_defaultShouldRevalidate: u.unstable_defaultShouldRevalidate, preventScrollReset: u.preventScrollReset, formData: g, body: v, formMethod: u.method || h, formEncType: u.encType || m, flushSync: u.flushSync }) } else await l(u.action || d, { unstable_defaultShouldRevalidate: u.unstable_defaultShouldRevalidate, preventScrollReset: u.preventScrollReset, formData: g, body: v, formMethod: u.method || h, formEncType: u.encType || m, replace: u.replace, state: u.state, fromRouteId: i, flushSync: u.flushSync, viewTransition: u.viewTransition }) }, [s, l, r, i]) } function T1(t, { relative: r } = {}) { let { basename: i } = b.useContext(Bt), s = b.useContext(un); Ue(s, "useFormAction must be used inside a RouteContext"); let [l] = s.matches.slice(-1), c = { ...Po(t || ".", { relative: r }) }, u = Tn(); if (t == null) { c.search = u.search; let d = new URLSearchParams(c.search), h = d.getAll("index"); if (h.some(g => g === "")) { d.delete("index"), h.filter(v => v).forEach(v => d.append("index", v)); let g = d.toString(); c.search = g ? `?${g}` : "" } } return (!t || t === ".") && l.route.index && (c.search = c.search ? c.search.replace(/^\?/, "?index&") : "?index"), i !== "/" && (c.pathname = c.pathname === "/" ? i : kn([i, c.pathname])), po(c) } function N1(t, { relative: r } = {}) { let i = b.useContext(wm); Ue(i != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"); let { basename: s } = Am("useViewTransitionState"), l = Po(t, { relative: r }); if (!i.isTransitioning) return !1; let c = En(i.currentLocation.pathname, s) || i.currentLocation.pathname, u = En(i.nextLocation.pathname, s) || i.nextLocation.pathname; return ta(l.pathname, u) != null || ta(l.pathname, c) != null } cm(); const Mm = "/assets/logo-CnILK9Ci.png"; function b1({ className: t }) { const [r, i] = b.useState(!1), s = Tn(), l = Cm(), c = h => { i(!1), l(h) }, u = h => s.pathname === h, d = h => `transition-colors ${u(h) ? "text-[#1E62FF] font-medium" : "text-slate-700 hover:text-[#1E62FF]"}`; return x.jsx("header", { className: `bg-white shadow-sm sticky top-0 z-50 ${t ?? ""}`, children: x.jsxs("nav", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: [x.jsxs("div", { className: "flex justify-between items-center h-20", children: [x.jsxs(qt, { to: "/", className: "flex items-center gap-3", children: [x.jsx("img", { src: Mm, alt: "MakeASite Logo", className: "w-10 h-10 rounded-lg border border-[#1E62FF22]" }), x.jsxs("span", { className: "heading-font text-slate-900", style: { fontSize: "22px" }, children: ["MakeA", x.jsx("span", { className: "text-[#1E62FF]", children: "Site" }), x.jsx("span", { className: "text-slate-700", children: ".in" })] })] }), x.jsxs("div", { className: "hidden md:flex items-center gap-8", children: [x.jsx(qt, { to: "/", className: d("/"), children: "Home" }), x.jsx(qt, { to: "/services", className: d("/services"), children: "Services" }), x.jsx(qt, { to: "/pricing", className: d("/pricing"), children: "Pricing" }), x.jsx(qt, { to: "/portfolio", className: d("/portfolio"), children: "Portfolio" }), x.jsx(qt, { to: "/contact", className: d("/contact"), children: "Contact" })] }), x.jsx("div", { className: "hidden md:block", children: x.jsx(qt, { to: "/contact", className: "neon-hover bg-[#1E62FF] text-white px-6 py-3 rounded-xl transition-all", children: "Get Started" }) }), x.jsxs("button", { className: "md:hidden p-2", onClick: () => i(!r), children: [x.jsx("div", { className: "w-6 h-0.5 bg-slate-800 mb-1.5" }), x.jsx("div", { className: "w-6 h-0.5 bg-slate-800 mb-1.5" }), x.jsx("div", { className: "w-6 h-0.5 bg-slate-800" })] })] }), r && x.jsx("div", { className: "md:hidden py-4 border-t", children: x.jsxs("div", { className: "flex flex-col gap-4", children: [x.jsx("button", { onClick: () => c("/"), className: `text-left ${d("/")}`, children: "Home" }), x.jsx("button", { onClick: () => c("/services"), className: `text-left ${d("/services")}`, children: "Services" }), x.jsx("button", { onClick: () => c("/pricing"), className: `text-left ${d("/pricing")}`, children: "Pricing" }), x.jsx("button", { onClick: () => c("/portfolio"), className: `text-left ${d("/portfolio")}`, children: "Portfolio" }), x.jsx("button", { onClick: () => c("/contact"), className: `text-left ${d("/contact")}`, children: "Contact" }), x.jsx("button", { onClick: () => c("/contact"), className: "bg-[#1E62FF] text-white px-6 py-3 rounded-xl hover:shadow-lg transition-all text-center", children: "Get Started" })] }) })] }) }) }/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const R1 = t => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), j1 = t => t.replace(/^([A-Z])|[\s-_]+(\w)/g, (r, i, s) => s ? s.toUpperCase() : i.toLowerCase()), zh = t => { const r = j1(t); return r.charAt(0).toUpperCase() + r.slice(1) }, Lm = (...t) => t.filter((r, i, s) => !!r && r.trim() !== "" && s.indexOf(r) === i).join(" ").trim();/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var A1 = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const M1 = b.forwardRef(({ color: t = "currentColor", size: r = 24, strokeWidth: i = 2, absoluteStrokeWidth: s, className: l = "", children: c, iconNode: u, ...d }, h) => b.createElement("svg", { ref: h, ...A1, width: r, height: r, stroke: t, strokeWidth: s ? Number(i) * 24 / Number(r) : i, className: Lm("lucide", l), ...d }, [...u.map(([m, g]) => b.createElement(m, g)), ...Array.isArray(c) ? c : [c]]));/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Je = (t, r) => { const i = b.forwardRef(({ className: s, ...l }, c) => b.createElement(M1, { ref: c, iconNode: r, className: Lm(`lucide-${R1(zh(t))}`, `lucide-${t}`, s), ...l })); return i.displayName = zh(t), i };/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const L1 = [["path", { d: "M5 12h14", key: "1ays0h" }], ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]], D1 = Je("arrow-right", L1);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const F1 = [["path", { d: "M12 8V4H8", key: "hb8ula" }], ["rect", { width: "16", height: "12", x: "4", y: "8", rx: "2", key: "enze0r" }], ["path", { d: "M2 14h2", key: "vft8re" }], ["path", { d: "M20 14h2", key: "4cs60a" }], ["path", { d: "M15 13v2", key: "1xurst" }], ["path", { d: "M9 13v2", key: "rq6x2g" }]], V1 = Je("bot", F1);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const I1 = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], _1 = Je("check", I1);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const O1 = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]], z1 = Je("circle-check", O1);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const B1 = [["line", { x1: "12", x2: "12", y1: "2", y2: "22", key: "7eqyqh" }], ["path", { d: "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6", key: "1b0p4s" }]], U1 = Je("dollar-sign", B1);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const $1 = [["path", { d: "M15 3h6v6", key: "1q9fwt" }], ["path", { d: "M10 14 21 3", key: "gplh6r" }], ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]], W1 = Je("external-link", $1);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const H1 = [["path", { d: "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z", key: "1jg4f8" }]], K1 = Je("facebook", H1);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const G1 = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }], ["path", { d: "M2 12h20", key: "9i4pu4" }]], Dm = Je("globe", G1);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Y1 = [["rect", { width: "20", height: "20", x: "2", y: "2", rx: "5", ry: "5", key: "2e1cvw" }], ["path", { d: "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z", key: "9exkf1" }], ["line", { x1: "17.5", x2: "17.51", y1: "6.5", y2: "6.5", key: "r4j83e" }]], X1 = Je("instagram", Y1);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Q1 = [["path", { d: "M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z", key: "c2jq9f" }], ["rect", { width: "4", height: "12", x: "2", y: "9", key: "mk3on5" }], ["circle", { cx: "4", cy: "4", r: "2", key: "bt5ra8" }]], q1 = Je("linkedin", Q1);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Z1 = [["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }], ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]], Fm = Je("mail", Z1);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const J1 = [["path", { d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0", key: "1r0f0z" }], ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]], ew = Je("map-pin", J1);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const tw = [["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z", key: "vv11sd" }]], nw = Je("message-circle", tw);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const rw = [["path", { d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z", key: "foiqr5" }]], Vm = Je("phone", rw);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const iw = [["path", { d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z", key: "1ffxy3" }], ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]], ow = Je("send", iw);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const sw = [["path", { d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z", key: "4pj2yx" }], ["path", { d: "M20 3v4", key: "1olli1" }], ["path", { d: "M22 5h-4", key: "1gvqau" }], ["path", { d: "M4 17v2", key: "vumght" }], ["path", { d: "M5 18H3", key: "zchphs" }]], Im = Je("sparkles", sw);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const aw = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["circle", { cx: "12", cy: "12", r: "6", key: "1vlfrh" }], ["circle", { cx: "12", cy: "12", r: "2", key: "1c9p78" }]], lw = Je("target", aw);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const uw = [["polyline", { points: "22 7 13.5 15.5 8.5 10.5 2 17", key: "126l90" }], ["polyline", { points: "16 7 22 7 22 13", key: "kwv8wd" }]], cw = Je("trending-up", uw);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const fw = [["path", { d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z", key: "1xq2db" }]], dw = Je("zap", fw); function hw() { return x.jsx("footer", { className: "bg-gradient-to-b from-[#8098b7] to-[#1E62FF] text-dark", children: x.jsxs("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16", children: [x.jsxs("div", { className: "grid md:grid-cols-2 lg:grid-cols-4 gap-12", children: [x.jsxs("div", { children: [x.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [x.jsx("img", { src: Mm, alt: "MakeASite.in", className: "w-10 h-10 rounded-lg" }), x.jsxs("span", { className: "heading-font", style: { fontSize: "22px" }, children: ["MakeA", x.jsx("span", { className: "text-[#00E6FF]", children: "Site" }), x.jsx("span", { className: "text-white/80", children: ".in" })] })] }), x.jsx("p", { className: "text-white mb-6 leading-relaxed", children: "Building beautiful, functional websites for small businesses and startups. Simple, fast, and affordable." }), x.jsxs("div", { className: "flex gap-4", children: [x.jsx("a", { href: "https://www.facebook.com/profile.php?id=61586175400100", target: "_blank", rel: "noopener noreferrer", className: "w-10 h-10 bg-white/10 hover:bg-[#00E6FF22] rounded-lg flex items-center justify-center transition-all", "aria-label": "Facebook", children: x.jsx(K1, { className: "w-5 h-5" }) }), x.jsx("a", { href: "https://www.instagram.com/makeasite.in/", target: "_blank", rel: "noopener noreferrer", className: "w-10 h-10 bg-white/10 hover:bg-[#00E6FF22] rounded-lg flex items-center justify-center transition-all", "aria-label": "Instagram", children: x.jsx(X1, { className: "w-5 h-5" }) }), x.jsx("a", { href: "https://www.linkedin.com/in/makeasite/", target: "_blank", rel: "noopener noreferrer", className: "w-10 h-10 bg-white/10 hover:bg-[#00E6FF22] rounded-lg flex items-center justify-center transition-all", "aria-label": "LinkedIn", children: x.jsx(q1, { className: "w-5 h-5" }) })] })] }), x.jsxs("div", { children: [x.jsx("h3", { className: "heading-font mb-6", children: "Services" }), x.jsxs("ul", { className: "space-y-3 text-white", children: [x.jsx("li", { children: x.jsx("a", { href: "#", className: "hover:text-[#5FD1C8] transition-colors", children: "Business Websites" }) }), x.jsx("li", { children: x.jsx("a", { href: "#", className: "hover:text-[#5FD1C8] transition-colors", children: "Portfolio Websites" }) }), x.jsx("li", { children: x.jsx("a", { href: "#", className: "hover:text-[#5FD1C8] transition-colors", children: "Landing Pages" }) }), x.jsx("li", { children: x.jsx("a", { href: "#", className: "hover:text-[#5FD1C8] transition-colors", children: "E-commerce Basics" }) }), x.jsx("li", { children: x.jsx("a", { href: "#", className: "hover:text-[#5FD1C8] transition-colors", children: "Digital Growth Support" }) }), x.jsx("li", { children: x.jsx("a", { href: "#", className: "hover:text-[#5FD1C8] transition-colors", children: "Branding Kit" }) })] })] }), x.jsxs("div", { children: [x.jsx("h3", { className: "heading-font mb-6", children: "Quick Links" }), x.jsxs("ul", { className: "space-y-3 text-white", children: [x.jsx("li", { children: x.jsx("a", { href: "#home", className: "hover:text-[#5FD1C8] transition-colors", children: "Home" }) }), x.jsx("li", { children: x.jsx("a", { href: "#about", className: "hover:text-[#5FD1C8] transition-colors", children: "About Us" }) }), x.jsx("li", { children: x.jsx("a", { href: "#portfolio", className: "hover:text-[#5FD1C8] transition-colors", children: "Portfolio" }) }), x.jsx("li", { children: x.jsx("a", { href: "#pricing", className: "hover:text-[#5FD1C8] transition-colors", children: "Pricing" }) }), x.jsx("li", { children: x.jsx("a", { href: "#contact", className: "hover:text-[#5FD1C8] transition-colors", children: "Contact" }) }), x.jsx("li", { children: x.jsx("a", { href: "#", className: "hover:text-[#5FD1C8] transition-colors", children: "Blog" }) })] })] }), x.jsxs("div", { children: [x.jsx("h3", { className: "heading-font mb-6", children: "Contact Us" }), x.jsxs("ul", { className: "space-y-4 text-white", children: [x.jsxs("li", { className: "flex items-start gap-3", children: [x.jsx(Vm, { className: "w-5 h-5 flex-shrink-0 mt-0.5" }), x.jsxs("div", { children: [x.jsx("div", { children: "6238014370" }), x.jsx("div", { children: "8304824323" })] })] }), x.jsxs("li", { className: "flex items-start gap-3", children: [x.jsx(Fm, { className: "w-5 h-5 flex-shrink-0 mt-0.5" }), x.jsx("div", { children: "makeasite.in@gmail.com" })] }), x.jsxs("li", { className: "flex items-start gap-3", children: [x.jsx(Dm, { className: "w-5 h-5 flex-shrink-0 mt-0.5" }), x.jsx("div", { children: "MakeASite.in" })] })] })] })] }), x.jsxs("div", { className: "border-t border-white/10 mt-12 pt-8 flex flex-col md:flex-row justify-between items-center gap-4 text-white/80 text-sm", children: [x.jsx("div", { children: " 2026 MakeASite.in. All rights reserved." }), x.jsxs("div", { className: "flex gap-6", children: [x.jsx("a", { href: "#", className: "hover:text-[#00E6FF] transition-colors", children: "Privacy Policy" }), x.jsx("a", { href: "#", className: "hover:text-[#00E6FF] transition-colors", children: "Terms of Service" }), x.jsx("a", { href: "#", className: "hover:text-[#00E6FF] transition-colors", children: "Cookie Policy" })] })] })] }) }) } function pw() { return x.jsxs("a", { href: "https://wa.me/917306683199", target: "_blank", rel: "noopener noreferrer", className: "fixed bottom-6 right-6 z-50 bg-[#25D366] text-white w-14 h-14 rounded-full shadow-2xl hover:shadow-3xl hover:scale-110 transition-all duration-300 flex items-center justify-center group", "aria-label": "Chat on WhatsApp", children: [x.jsx("svg", { viewBox: "0 0 24 24", fill: "currentColor", className: "w-7 h-7 group-hover:rotate-12 transition-transform", children: x.jsx("path", { d: "M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413z" }) }), x.jsx("span", { className: "absolute inset-0 rounded-full bg-[#25D366] animate-ping opacity-20" })] }) } function mw() { const { pathname: t } = Tn(); return b.useEffect(() => { window.scrollTo(0, 0) }, [t]), x.jsxs("div", { className: "min-h-screen bg-[#F8F8F8]", children: [x.jsx(b1, {}), x.jsx("main", { children: x.jsx(Kx, {}) }), x.jsx(hw, {}), x.jsx(pw, {})] }) } const gw = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODgiIGhlaWdodD0iODgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBvcGFjaXR5PSIuMyIgZmlsbD0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIzLjciPjxyZWN0IHg9IjE2IiB5PSIxNiIgd2lkdGg9IjU2IiBoZWlnaHQ9IjU2IiByeD0iNiIvPjxwYXRoIGQ9Im0xNiA1OCAxNi0xOCAzMiAzMiIvPjxjaXJjbGUgY3g9IjUzIiBjeT0iMzUiIHI9IjciLz48L3N2Zz4KCg=="; function _m(t) { const [r, i] = b.useState(!1), s = () => { i(!0) }, { src: l, alt: c, style: u, className: d, ...h } = t; return r ? x.jsx("div", { className: `inline-block bg-gray-100 text-center align-middle ${d ?? ""}`, style: u, children: x.jsx("div", { className: "flex items-center justify-center w-full h-full", children: x.jsx("img", { src: gw, alt: "Error loading image", ...h, "data-original-url": l }) }) }) : x.jsx("img", { src: l, alt: c, className: d, style: u, ...h, onError: s }) } const Om = b.createContext({}); function yw(t) { const r = b.useRef(null); return r.current === null && (r.current = t()), r.current } const ac = typeof window < "u", vw = ac ? b.useLayoutEffect : b.useEffect, lc = b.createContext(null); function uc(t, r) { t.indexOf(r) === -1 && t.push(r) } function cc(t, r) { const i = t.indexOf(r); i > -1 && t.splice(i, 1) } const Cn = (t, r, i) => i > r ? r : i < t ? t : i; let fc = () => { }; const Pn = {}, zm = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t); function Bm(t) { return typeof t == "object" && t !== null } const Um = t => /^0[^.\s]+$/u.test(t); function dc(t) { let r; return () => (r === void 0 && (r = t()), r) } const zt = t => t, xw = (t, r) => i => r(t(i)), To = (...t) => t.reduce(xw), mo = (t, r, i) => { const s = r - t; return s === 0 ? 1 : (i - t) / s }; class hc { constructor() { this.subscriptions = [] } add(r) { return uc(this.subscriptions, r), () => cc(this.subscriptions, r) } notify(r, i, s) { const l = this.subscriptions.length; if (l) if (l === 1) this.subscriptions[0](r, i, s); else for (let c = 0; c < l; c++) { const u = this.subscriptions[c]; u && u(r, i, s) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const an = t => t * 1e3, Ot = t => t / 1e3; function $m(t, r) { return r ? t * (1e3 / r) : 0 } const Wm = (t, r, i) => (((1 - 3 * i + 3 * r) * t + (3 * i - 6 * r)) * t + 3 * r) * t, ww = 1e-7, Sw = 12; function kw(t, r, i, s, l) { let c, u, d = 0; do u = r + (i - r) / 2, c = Wm(u, s, l) - t, c > 0 ? i = u : r = u; while (Math.abs(c) > ww && ++d < Sw); return u } function No(t, r, i, s) { if (t === r && i === s) return zt; const l = c => kw(c, 0, 1, t, i); return c => c === 0 || c === 1 ? c : Wm(l(c), r, s) } const Hm = t => r => r <= .5 ? t(2 * r) / 2 : (2 - t(2 * (1 - r))) / 2, Km = t => r => 1 - t(1 - r), Gm = No(.33, 1.53, .69, .99), pc = Km(Gm), Ym = Hm(pc), Xm = t => (t *= 2) < 1 ? .5 * pc(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))), mc = t => 1 - Math.sin(Math.acos(t)), Qm = Km(mc), qm = Hm(mc), Ew = No(.42, 0, 1, 1), Cw = No(0, 0, .58, 1), Zm = No(.42, 0, .58, 1), Pw = t => Array.isArray(t) && typeof t[0] != "number", Jm = t => Array.isArray(t) && typeof t[0] == "number", Tw = { linear: zt, easeIn: Ew, easeInOut: Zm, easeOut: Cw, circIn: mc, circInOut: qm, circOut: Qm, backIn: pc, backInOut: Ym, backOut: Gm, anticipate: Xm }, Nw = t => typeof t == "string", Bh = t => { if (Jm(t)) { fc(t.length === 4); const [r, i, s, l] = t; return No(r, i, s, l) } else if (Nw(t)) return Tw[t]; return t }, Ws = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"]; function bw(t, r) { let i = new Set, s = new Set, l = !1, c = !1; const u = new WeakSet; let d = { delta: 0, timestamp: 0, isProcessing: !1 }; function h(g) { u.has(g) && (m.schedule(g), t()), g(d) } const m = { schedule: (g, v = !1, w = !1) => { const E = w && l ? i : s; return v && u.add(g), E.has(g) || E.add(g), g }, cancel: g => { s.delete(g), u.delete(g) }, process: g => { if (d = g, l) { c = !0; return } l = !0, [i, s] = [s, i], i.forEach(h), i.clear(), l = !1, c && (c = !1, m.process(g)) } }; return m } const Rw = 40; function eg(t, r) { let i = !1, s = !0; const l = { delta: 0, timestamp: 0, isProcessing: !1 }, c = () => i = !0, u = Ws.reduce((L, U) => (L[U] = bw(c), L), {}), { setup: d, read: h, resolveKeyframes: m, preUpdate: g, update: v, preRender: w, render: k, postRender: E } = u, N = () => { const L = Pn.useManualTiming ? l.timestamp : performance.now(); i = !1, Pn.useManualTiming || (l.delta = s ? 1e3 / 60 : Math.max(Math.min(L - l.timestamp, Rw), 1)), l.timestamp = L, l.isProcessing = !0, d.process(l), h.process(l), m.process(l), g.process(l), v.process(l), w.process(l), k.process(l), E.process(l), l.isProcessing = !1, i && r && (s = !1, t(N)) }, C = () => { i = !0, s = !0, l.isProcessing || t(N) }; return { schedule: Ws.reduce((L, U) => { const O = u[U]; return L[U] = (H, K = !1, I = !1) => (i || C(), O.schedule(H, K, I)), L }, {}), cancel: L => { for (let U = 0; U < Ws.length; U++)u[Ws[U]].cancel(L) }, state: l, steps: u } } const { schedule: Ie, cancel: Yn, state: st, steps: cu } = eg(typeof requestAnimationFrame < "u" ? requestAnimationFrame : zt, !0); let qs; function jw() { qs = void 0 } const St = { now: () => (qs === void 0 && St.set(st.isProcessing || Pn.useManualTiming ? st.timestamp : performance.now()), qs), set: t => { qs = t, queueMicrotask(jw) } }, tg = t => r => typeof r == "string" && r.startsWith(t), ng = tg("--"), Aw = tg("var(--"), gc = t => Aw(t) ? Mw.test(t.split("/*")[0].trim()) : !1, Mw = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, oi = { test: t => typeof t == "number", parse: parseFloat, transform: t => t }, go = { ...oi, transform: t => Cn(0, 1, t) }, Hs = { ...oi, default: 1 }, lo = t => Math.round(t * 1e5) / 1e5, yc = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function Lw(t) { return t == null } const Dw = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, vc = (t, r) => i => !!(typeof i == "string" && Dw.test(i) && i.startsWith(t) || r && !Lw(i) && Object.prototype.hasOwnProperty.call(i, r)), rg = (t, r, i) => s => { if (typeof s != "string") return s; const [l, c, u, d] = s.match(yc); return { [t]: parseFloat(l), [r]: parseFloat(c), [i]: parseFloat(u), alpha: d !== void 0 ? parseFloat(d) : 1 } }, Fw = t => Cn(0, 255, t), fu = { ...oi, transform: t => Math.round(Fw(t)) }, gr = { test: vc("rgb", "red"), parse: rg("red", "green", "blue"), transform: ({ red: t, green: r, blue: i, alpha: s = 1 }) => "rgba(" + fu.transform(t) + ", " + fu.transform(r) + ", " + fu.transform(i) + ", " + lo(go.transform(s)) + ")" }; function Vw(t) { let r = "", i = "", s = "", l = ""; return t.length > 5 ? (r = t.substring(1, 3), i = t.substring(3, 5), s = t.substring(5, 7), l = t.substring(7, 9)) : (r = t.substring(1, 2), i = t.substring(2, 3), s = t.substring(3, 4), l = t.substring(4, 5), r += r, i += i, s += s, l += l), { red: parseInt(r, 16), green: parseInt(i, 16), blue: parseInt(s, 16), alpha: l ? parseInt(l, 16) / 255 : 1 } } const ju = { test: vc("#"), parse: Vw, transform: gr.transform }, bo = t => ({ test: r => typeof r == "string" && r.endsWith(t) && r.split(" ").length === 1, parse: parseFloat, transform: r => `${r}${t}` }), Gn = bo("deg"), ln = bo("%"), de = bo("px"), Iw = bo("vh"), _w = bo("vw"), Uh = { ...ln, parse: t => ln.parse(t) / 100, transform: t => ln.transform(t * 100) }, Xr = { test: vc("hsl", "hue"), parse: rg("hue", "saturation", "lightness"), transform: ({ hue: t, saturation: r, lightness: i, alpha: s = 1 }) => "hsla(" + Math.round(t) + ", " + ln.transform(lo(r)) + ", " + ln.transform(lo(i)) + ", " + lo(go.transform(s)) + ")" }, Ye = { test: t => gr.test(t) || ju.test(t) || Xr.test(t), parse: t => gr.test(t) ? gr.parse(t) : Xr.test(t) ? Xr.parse(t) : ju.parse(t), transform: t => typeof t == "string" ? t : t.hasOwnProperty("red") ? gr.transform(t) : Xr.transform(t), getAnimatableNone: t => { const r = Ye.parse(t); return r.alpha = 0, Ye.transform(r) } }, Ow = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function zw(t) { return isNaN(t) && typeof t == "string" && (t.match(yc)?.length || 0) + (t.match(Ow)?.length || 0) > 0 } const ig = "number", og = "color", Bw = "var", Uw = "var(", $h = "${}", $w = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function yo(t) { const r = t.toString(), i = [], s = { color: [], number: [], var: [] }, l = []; let c = 0; const d = r.replace($w, h => (Ye.test(h) ? (s.color.push(c), l.push(og), i.push(Ye.parse(h))) : h.startsWith(Uw) ? (s.var.push(c), l.push(Bw), i.push(h)) : (s.number.push(c), l.push(ig), i.push(parseFloat(h))), ++c, $h)).split($h); return { values: i, split: d, indexes: s, types: l } } function sg(t) { return yo(t).values } function ag(t) { const { split: r, types: i } = yo(t), s = r.length; return l => { let c = ""; for (let u = 0; u < s; u++)if (c += r[u], l[u] !== void 0) { const d = i[u]; d === ig ? c += lo(l[u]) : d === og ? c += Ye.transform(l[u]) : c += l[u] } return c } } const Ww = t => typeof t == "number" ? 0 : Ye.test(t) ? Ye.getAnimatableNone(t) : t; function Hw(t) { const r = sg(t); return ag(t)(r.map(Ww)) } const Xn = { test: zw, parse: sg, createTransformer: ag, getAnimatableNone: Hw }; function du(t, r, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + (r - t) * 6 * i : i < 1 / 2 ? r : i < 2 / 3 ? t + (r - t) * (2 / 3 - i) * 6 : t } function Kw({ hue: t, saturation: r, lightness: i, alpha: s }) { t /= 360, r /= 100, i /= 100; let l = 0, c = 0, u = 0; if (!r) l = c = u = i; else { const d = i < .5 ? i * (1 + r) : i + r - i * r, h = 2 * i - d; l = du(h, d, t + 1 / 3), c = du(h, d, t), u = du(h, d, t - 1 / 3) } return { red: Math.round(l * 255), green: Math.round(c * 255), blue: Math.round(u * 255), alpha: s } } function na(t, r) { return i => i > 0 ? r : t } const ze = (t, r, i) => t + (r - t) * i, hu = (t, r, i) => { const s = t * t, l = i * (r * r - s) + s; return l < 0 ? 0 : Math.sqrt(l) }, Gw = [ju, gr, Xr], Yw = t => Gw.find(r => r.test(t)); function Wh(t) { const r = Yw(t); if (!r) return !1; let i = r.parse(t); return r === Xr && (i = Kw(i)), i } const Hh = (t, r) => { const i = Wh(t), s = Wh(r); if (!i || !s) return na(t, r); const l = { ...i }; return c => (l.red = hu(i.red, s.red, c), l.green = hu(i.green, s.green, c), l.blue = hu(i.blue, s.blue, c), l.alpha = ze(i.alpha, s.alpha, c), gr.transform(l)) }, Au = new Set(["none", "hidden"]); function Xw(t, r) { return Au.has(t) ? i => i <= 0 ? t : r : i => i >= 1 ? r : t } function Qw(t, r) { return i => ze(t, r, i) } function xc(t) { return typeof t == "number" ? Qw : typeof t == "string" ? gc(t) ? na : Ye.test(t) ? Hh : Jw : Array.isArray(t) ? lg : typeof t == "object" ? Ye.test(t) ? Hh : qw : na } function lg(t, r) { const i = [...t], s = i.length, l = t.map((c, u) => xc(c)(c, r[u])); return c => { for (let u = 0; u < s; u++)i[u] = l[u](c); return i } } function qw(t, r) { const i = { ...t, ...r }, s = {}; for (const l in i) t[l] !== void 0 && r[l] !== void 0 && (s[l] = xc(t[l])(t[l], r[l])); return l => { for (const c in s) i[c] = s[c](l); return i } } function Zw(t, r) { const i = [], s = { color: 0, var: 0, number: 0 }; for (let l = 0; l < r.values.length; l++) { const c = r.types[l], u = t.indexes[c][s[c]], d = t.values[u] ?? 0; i[l] = d, s[c]++ } return i } const Jw = (t, r) => { const i = Xn.createTransformer(r), s = yo(t), l = yo(r); return s.indexes.var.length === l.indexes.var.length && s.indexes.color.length === l.indexes.color.length && s.indexes.number.length >= l.indexes.number.length ? Au.has(t) && !l.values.length || Au.has(r) && !s.values.length ? Xw(t, r) : To(lg(Zw(s, l), l.values), i) : na(t, r) }; function ug(t, r, i) { return typeof t == "number" && typeof r == "number" && typeof i == "number" ? ze(t, r, i) : xc(t)(t, r) } const eS = t => { const r = ({ timestamp: i }) => t(i); return { start: (i = !0) => Ie.update(r, i), stop: () => Yn(r), now: () => st.isProcessing ? st.timestamp : St.now() } }, cg = (t, r, i = 10) => { let s = ""; const l = Math.max(Math.round(r / i), 2); for (let c = 0; c < l; c++)s += Math.round(t(c / (l - 1)) * 1e4) / 1e4 + ", "; return `linear(${s.substring(0, s.length - 2)})` }, ra = 2e4; function wc(t) { let r = 0; const i = 50; let s = t.next(r); for (; !s.done && r < ra;)r += i, s = t.next(r); return r >= ra ? 1 / 0 : r } function tS(t, r = 100, i) { const s = i({ ...t, keyframes: [0, r] }), l = Math.min(wc(s), ra); return { type: "keyframes", ease: c => s.next(l * c).value / r, duration: Ot(l) } } const nS = 5; function fg(t, r, i) { const s = Math.max(r - nS, 0); return $m(i - t(s), r - s) } const We = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, pu = .001; function rS({ duration: t = We.duration, bounce: r = We.bounce, velocity: i = We.velocity, mass: s = We.mass }) { let l, c, u = 1 - r; u = Cn(We.minDamping, We.maxDamping, u), t = Cn(We.minDuration, We.maxDuration, Ot(t)), u < 1 ? (l = m => { const g = m * u, v = g * t, w = g - i, k = Mu(m, u), E = Math.exp(-v); return pu - w / k * E }, c = m => { const v = m * u * t, w = v * i + i, k = Math.pow(u, 2) * Math.pow(m, 2) * t, E = Math.exp(-v), N = Mu(Math.pow(m, 2), u); return (-l(m) + pu > 0 ? -1 : 1) * ((w - k) * E) / N }) : (l = m => { const g = Math.exp(-m * t), v = (m - i) * t + 1; return -pu + g * v }, c = m => { const g = Math.exp(-m * t), v = (i - m) * (t * t); return g * v }); const d = 5 / t, h = oS(l, c, d); if (t = an(t), isNaN(h)) return { stiffness: We.stiffness, damping: We.damping, duration: t }; { const m = Math.pow(h, 2) * s; return { stiffness: m, damping: u * 2 * Math.sqrt(s * m), duration: t } } } const iS = 12; function oS(t, r, i) { let s = i; for (let l = 1; l < iS; l++)s = s - t(s) / r(s); return s } function Mu(t, r) { return t * Math.sqrt(1 - r * r) } const sS = ["duration", "bounce"], aS = ["stiffness", "damping", "mass"]; function Kh(t, r) { return r.some(i => t[i] !== void 0) } function lS(t) { let r = { velocity: We.velocity, stiffness: We.stiffness, damping: We.damping, mass: We.mass, isResolvedFromDuration: !1, ...t }; if (!Kh(t, aS) && Kh(t, sS)) if (t.visualDuration) { const i = t.visualDuration, s = 2 * Math.PI / (i * 1.2), l = s * s, c = 2 * Cn(.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(l); r = { ...r, mass: We.mass, stiffness: l, damping: c } } else { const i = rS(t); r = { ...r, ...i, mass: We.mass }, r.isResolvedFromDuration = !0 } return r } function ia(t = We.visualDuration, r = We.bounce) { const i = typeof t != "object" ? { visualDuration: t, keyframes: [0, 1], bounce: r } : t; let { restSpeed: s, restDelta: l } = i; const c = i.keyframes[0], u = i.keyframes[i.keyframes.length - 1], d = { done: !1, value: c }, { stiffness: h, damping: m, mass: g, duration: v, velocity: w, isResolvedFromDuration: k } = lS({ ...i, velocity: -Ot(i.velocity || 0) }), E = w || 0, N = m / (2 * Math.sqrt(h * g)), C = u - c, P = Ot(Math.sqrt(h / g)), A = Math.abs(C) < 5; s || (s = A ? We.restSpeed.granular : We.restSpeed.default), l || (l = A ? We.restDelta.granular : We.restDelta.default); let L; if (N < 1) { const O = Mu(P, N); L = H => { const K = Math.exp(-N * P * H); return u - K * ((E + N * P * C) / O * Math.sin(O * H) + C * Math.cos(O * H)) } } else if (N === 1) L = O => u - Math.exp(-P * O) * (C + (E + P * C) * O); else { const O = P * Math.sqrt(N * N - 1); L = H => { const K = Math.exp(-N * P * H), I = Math.min(O * H, 300); return u - K * ((E + N * P * C) * Math.sinh(I) + O * C * Math.cosh(I)) / O } } const U = { calculatedDuration: k && v || null, next: O => { const H = L(O); if (k) d.done = O >= v; else { let K = O === 0 ? E : 0; N < 1 && (K = O === 0 ? an(E) : fg(L, O, H)); const I = Math.abs(K) <= s, Q = Math.abs(u - H) <= l; d.done = I && Q } return d.value = d.done ? u : H, d }, toString: () => { const O = Math.min(wc(U), ra), H = cg(K => U.next(O * K).value, O, 30); return O + "ms " + H }, toTransition: () => { } }; return U } ia.applyToOptions = t => { const r = tS(t, 100, ia); return t.ease = r.ease, t.duration = an(r.duration), t.type = "keyframes", t }; function Lu({ keyframes: t, velocity: r = 0, power: i = .8, timeConstant: s = 325, bounceDamping: l = 10, bounceStiffness: c = 500, modifyTarget: u, min: d, max: h, restDelta: m = .5, restSpeed: g }) { const v = t[0], w = { done: !1, value: v }, k = I => d !== void 0 && I < d || h !== void 0 && I > h, E = I => d === void 0 ? h : h === void 0 || Math.abs(d - I) < Math.abs(h - I) ? d : h; let N = i * r; const C = v + N, P = u === void 0 ? C : u(C); P !== C && (N = P - v); const A = I => -N * Math.exp(-I / s), L = I => P + A(I), U = I => { const Q = A(I), le = L(I); w.done = Math.abs(Q) <= m, w.value = w.done ? P : le }; let O, H; const K = I => { k(w.value) && (O = I, H = ia({ keyframes: [w.value, E(w.value)], velocity: fg(L, I, w.value), damping: l, stiffness: c, restDelta: m, restSpeed: g })) }; return K(0), { calculatedDuration: null, next: I => { let Q = !1; return !H && O === void 0 && (Q = !0, U(I), K(I)), O !== void 0 && I >= O ? H.next(I - O) : (!Q && U(I), w) } } } function uS(t, r, i) { const s = [], l = i || Pn.mix || ug, c = t.length - 1; for (let u = 0; u < c; u++) { let d = l(t[u], t[u + 1]); if (r) { const h = Array.isArray(r) ? r[u] || zt : r; d = To(h, d) } s.push(d) } return s } function cS(t, r, { clamp: i = !0, ease: s, mixer: l } = {}) { const c = t.length; if (fc(c === r.length), c === 1) return () => r[0]; if (c === 2 && r[0] === r[1]) return () => r[1]; const u = t[0] === t[1]; t[0] > t[c - 1] && (t = [...t].reverse(), r = [...r].reverse()); const d = uS(r, s, l), h = d.length, m = g => { if (u && g < t[0]) return r[0]; let v = 0; if (h > 1) for (; v < t.length - 2 && !(g < t[v + 1]); v++); const w = mo(t[v], t[v + 1], g); return d[v](w) }; return i ? g => m(Cn(t[0], t[c - 1], g)) : m } function fS(t, r) { const i = t[t.length - 1]; for (let s = 1; s <= r; s++) { const l = mo(0, r, s); t.push(ze(i, 1, l)) } } function dS(t) { const r = [0]; return fS(r, t.length - 1), r } function hS(t, r) { return t.map(i => i * r) } function pS(t, r) { return t.map(() => r || Zm).splice(0, t.length - 1) } function uo({ duration: t = 300, keyframes: r, times: i, ease: s = "easeInOut" }) { const l = Pw(s) ? s.map(Bh) : Bh(s), c = { done: !1, value: r[0] }, u = hS(i && i.length === r.length ? i : dS(r), t), d = cS(u, r, { ease: Array.isArray(l) ? l : pS(r, l) }); return { calculatedDuration: t, next: h => (c.value = d(h), c.done = h >= t, c) } } const mS = t => t !== null; function Sc(t, { repeat: r, repeatType: i = "loop" }, s, l = 1) { const c = t.filter(mS), d = l < 0 || r && i !== "loop" && r % 2 === 1 ? 0 : c.length - 1; return !d || s === void 0 ? c[d] : s } const gS = { decay: Lu, inertia: Lu, tween: uo, keyframes: uo, spring: ia }; function dg(t) { typeof t.type == "string" && (t.type = gS[t.type]) } class kc { constructor() { this.updateFinished() } get finished() { return this._finished } updateFinished() { this._finished = new Promise(r => { this.resolve = r }) } notifyFinished() { this.resolve() } then(r, i) { return this.finished.then(r, i) } } const yS = t => t / 100; class Ec extends kc { constructor(r) { super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => { const { motionValue: i } = this.options; i && i.updatedAt !== St.now() && this.tick(St.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.()) }, this.options = r, this.initAnimation(), this.play(), r.autoplay === !1 && this.pause() } initAnimation() { const { options: r } = this; dg(r); const { type: i = uo, repeat: s = 0, repeatDelay: l = 0, repeatType: c, velocity: u = 0 } = r; let { keyframes: d } = r; const h = i || uo; h !== uo && typeof d[0] != "number" && (this.mixKeyframes = To(yS, ug(d[0], d[1])), d = [0, 100]); const m = h({ ...r, keyframes: d }); c === "mirror" && (this.mirroredGenerator = h({ ...r, keyframes: [...d].reverse(), velocity: -u })), m.calculatedDuration === null && (m.calculatedDuration = wc(m)); const { calculatedDuration: g } = m; this.calculatedDuration = g, this.resolvedDuration = g + l, this.totalDuration = this.resolvedDuration * (s + 1) - l, this.generator = m } updateTime(r) { const i = Math.round(r - this.startTime) * this.playbackSpeed; this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = i } tick(r, i = !1) { const { generator: s, totalDuration: l, mixKeyframes: c, mirroredGenerator: u, resolvedDuration: d, calculatedDuration: h } = this; if (this.startTime === null) return s.next(0); const { delay: m = 0, keyframes: g, repeat: v, repeatType: w, repeatDelay: k, type: E, onUpdate: N, finalKeyframe: C } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, r) : this.speed < 0 && (this.startTime = Math.min(r - l / this.speed, this.startTime)), i ? this.currentTime = r : this.updateTime(r); const P = this.currentTime - m * (this.playbackSpeed >= 0 ? 1 : -1), A = this.playbackSpeed >= 0 ? P < 0 : P > l; this.currentTime = Math.max(P, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = l); let L = this.currentTime, U = s; if (v) { const I = Math.min(this.currentTime, l) / d; let Q = Math.floor(I), le = I % 1; !le && I >= 1 && (le = 1), le === 1 && Q--, Q = Math.min(Q, v + 1), !!(Q % 2) && (w === "reverse" ? (le = 1 - le, k && (le -= k / d)) : w === "mirror" && (U = u)), L = Cn(0, 1, le) * d } const O = A ? { done: !1, value: g[0] } : U.next(L); c && (O.value = c(O.value)); let { done: H } = O; !A && h !== null && (H = this.playbackSpeed >= 0 ? this.currentTime >= l : this.currentTime <= 0); const K = this.holdTime === null && (this.state === "finished" || this.state === "running" && H); return K && E !== Lu && (O.value = Sc(g, this.options, C, this.speed)), N && N(O.value), K && this.finish(), O } then(r, i) { return this.finished.then(r, i) } get duration() { return Ot(this.calculatedDuration) } get iterationDuration() { const { delay: r = 0 } = this.options || {}; return this.duration + Ot(r) } get time() { return Ot(this.currentTime) } set time(r) { r = an(r), this.currentTime = r, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = r : this.driver && (this.startTime = this.driver.now() - r / this.playbackSpeed), this.driver?.start(!1) } get speed() { return this.playbackSpeed } set speed(r) { this.updateTime(St.now()); const i = this.playbackSpeed !== r; this.playbackSpeed = r, i && (this.time = Ot(this.currentTime)) } play() { if (this.isStopped) return; const { driver: r = eS, startTime: i } = this.options; this.driver || (this.driver = r(l => this.tick(l))), this.options.onPlay?.(); const s = this.driver.now(); this.state === "finished" ? (this.updateFinished(), this.startTime = s) : this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime || (this.startTime = i ?? s), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start() } pause() { this.state = "paused", this.updateTime(St.now()), this.holdTime = this.currentTime } complete() { this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null } finish() { this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.() } cancel() { this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.() } teardown() { this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(r) { return this.startTime = 0, this.tick(r, !0) } attachTimeline(r) { return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), r.observe(this) } } function vS(t) { for (let r = 1; r < t.length; r++)t[r] ?? (t[r] = t[r - 1]) } const yr = t => t * 180 / Math.PI, Du = t => { const r = yr(Math.atan2(t[1], t[0])); return Fu(r) }, xS = { x: 4, y: 5, translateX: 4, translateY: 5, scaleX: 0, scaleY: 3, scale: t => (Math.abs(t[0]) + Math.abs(t[3])) / 2, rotate: Du, rotateZ: Du, skewX: t => yr(Math.atan(t[1])), skewY: t => yr(Math.atan(t[2])), skew: t => (Math.abs(t[1]) + Math.abs(t[2])) / 2 }, Fu = t => (t = t % 360, t < 0 && (t += 360), t), Gh = Du, Yh = t => Math.sqrt(t[0] * t[0] + t[1] * t[1]), Xh = t => Math.sqrt(t[4] * t[4] + t[5] * t[5]), wS = { x: 12, y: 13, z: 14, translateX: 12, translateY: 13, translateZ: 14, scaleX: Yh, scaleY: Xh, scale: t => (Yh(t) + Xh(t)) / 2, rotateX: t => Fu(yr(Math.atan2(t[6], t[5]))), rotateY: t => Fu(yr(Math.atan2(-t[2], t[0]))), rotateZ: Gh, rotate: Gh, skewX: t => yr(Math.atan(t[4])), skewY: t => yr(Math.atan(t[1])), skew: t => (Math.abs(t[1]) + Math.abs(t[4])) / 2 }; function Vu(t) { return t.includes("scale") ? 1 : 0 } function Iu(t, r) { if (!t || t === "none") return Vu(r); const i = t.match(/^matrix3d\(([-\d.e\s,]+)\)$/u); let s, l; if (i) s = wS, l = i; else { const d = t.match(/^matrix\(([-\d.e\s,]+)\)$/u); s = xS, l = d } if (!l) return Vu(r); const c = s[r], u = l[1].split(",").map(kS); return typeof c == "function" ? c(u) : u[c] } const SS = (t, r) => { const { transform: i = "none" } = getComputedStyle(t); return Iu(i, r) }; function kS(t) { return parseFloat(t.trim()) } const si = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], ai = new Set(si), Qh = t => t === oi || t === de, ES = new Set(["x", "y", "z"]), CS = si.filter(t => !ES.has(t)); function PS(t) { const r = []; return CS.forEach(i => { const s = t.getValue(i); s !== void 0 && (r.push([i, s.get()]), s.set(i.startsWith("scale") ? 1 : 0)) }), r } const vr = { width: ({ x: t }, { paddingLeft: r = "0", paddingRight: i = "0" }) => t.max - t.min - parseFloat(r) - parseFloat(i), height: ({ y: t }, { paddingTop: r = "0", paddingBottom: i = "0" }) => t.max - t.min - parseFloat(r) - parseFloat(i), top: (t, { top: r }) => parseFloat(r), left: (t, { left: r }) => parseFloat(r), bottom: ({ y: t }, { top: r }) => parseFloat(r) + (t.max - t.min), right: ({ x: t }, { left: r }) => parseFloat(r) + (t.max - t.min), x: (t, { transform: r }) => Iu(r, "x"), y: (t, { transform: r }) => Iu(r, "y") }; vr.translateX = vr.x; vr.translateY = vr.y; const xr = new Set; let _u = !1, Ou = !1, zu = !1; function hg() { if (Ou) { const t = Array.from(xr).filter(s => s.needsMeasurement), r = new Set(t.map(s => s.element)), i = new Map; r.forEach(s => { const l = PS(s); l.length && (i.set(s, l), s.render()) }), t.forEach(s => s.measureInitialState()), r.forEach(s => { s.render(); const l = i.get(s); l && l.forEach(([c, u]) => { s.getValue(c)?.set(u) }) }), t.forEach(s => s.measureEndState()), t.forEach(s => { s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY) }) } Ou = !1, _u = !1, xr.forEach(t => t.complete(zu)), xr.clear() } function pg() { xr.forEach(t => { t.readKeyframes(), t.needsMeasurement && (Ou = !0) }) } function TS() { zu = !0, pg(), hg(), zu = !1 } class Cc { constructor(r, i, s, l, c, u = !1) { this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...r], this.onComplete = i, this.name = s, this.motionValue = l, this.element = c, this.isAsync = u } scheduleResolve() { this.state = "scheduled", this.isAsync ? (xr.add(this), _u || (_u = !0, Ie.read(pg), Ie.resolveKeyframes(hg))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: r, name: i, element: s, motionValue: l } = this; if (r[0] === null) { const c = l?.get(), u = r[r.length - 1]; if (c !== void 0) r[0] = c; else if (s && i) { const d = s.readValue(i, u); d != null && (r[0] = d) } r[0] === void 0 && (r[0] = u), l && c === void 0 && l.set(r[0]) } vS(r) } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete(r = !1) { this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, r), xr.delete(this) } cancel() { this.state === "scheduled" && (xr.delete(this), this.state = "pending") } resume() { this.state === "pending" && this.scheduleResolve() } } const NS = t => t.startsWith("--"); function bS(t, r, i) { NS(r) ? t.style.setProperty(r, i) : t.style[r] = i } const RS = dc(() => window.ScrollTimeline !== void 0), jS = {}; function AS(t, r) { const i = dc(t); return () => jS[r] ?? i() } const mg = AS(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), so = ([t, r, i, s]) => `cubic-bezier(${t}, ${r}, ${i}, ${s})`, qh = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: so([0, .65, .55, 1]), circOut: so([.55, 0, 1, .45]), backIn: so([.31, .01, .66, -.59]), backOut: so([.33, 1.53, .69, .99]) }; function gg(t, r) { if (t) return typeof t == "function" ? mg() ? cg(t, r) : "ease-out" : Jm(t) ? so(t) : Array.isArray(t) ? t.map(i => gg(i, r) || qh.easeOut) : qh[t] } function MS(t, r, i, { delay: s = 0, duration: l = 300, repeat: c = 0, repeatType: u = "loop", ease: d = "easeOut", times: h } = {}, m = void 0) { const g = { [r]: i }; h && (g.offset = h); const v = gg(d, l); Array.isArray(v) && (g.easing = v); const w = { delay: s, duration: l, easing: Array.isArray(v) ? "linear" : v, fill: "both", iterations: c + 1, direction: u === "reverse" ? "alternate" : "normal" }; return m && (w.pseudoElement = m), t.animate(g, w) } function yg(t) { return typeof t == "function" && "applyToOptions" in t } function LS({ type: t, ...r }) { return yg(t) && mg() ? t.applyToOptions(r) : (r.duration ?? (r.duration = 300), r.ease ?? (r.ease = "easeOut"), r) } class DS extends kc { constructor(r) { if (super(), this.finishedTime = null, this.isStopped = !1, !r) return; const { element: i, name: s, keyframes: l, pseudoElement: c, allowFlatten: u = !1, finalKeyframe: d, onComplete: h } = r; this.isPseudoElement = !!c, this.allowFlatten = u, this.options = r, fc(typeof r.type != "string"); const m = LS(r); this.animation = MS(i, s, l, m, c), m.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => { if (this.finishedTime = this.time, !c) { const g = Sc(l, this.options, d, this.speed); this.updateMotionValue ? this.updateMotionValue(g) : bS(i, s, g), this.animation.cancel() } h?.(), this.notifyFinished() } } play() { this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished()) } pause() { this.animation.pause() } complete() { this.animation.finish?.() } cancel() { try { this.animation.cancel() } catch { } } stop() { if (this.isStopped) return; this.isStopped = !0; const { state: r } = this; r === "idle" || r === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel()) } commitStyles() { this.isPseudoElement || this.animation.commitStyles?.() } get duration() { const r = this.animation.effect?.getComputedTiming?.().duration || 0; return Ot(Number(r)) } get iterationDuration() { const { delay: r = 0 } = this.options || {}; return this.duration + Ot(r) } get time() { return Ot(Number(this.animation.currentTime) || 0) } set time(r) { this.finishedTime = null, this.animation.currentTime = an(r) } get speed() { return this.animation.playbackRate } set speed(r) { r < 0 && (this.finishedTime = null), this.animation.playbackRate = r } get state() { return this.finishedTime !== null ? "finished" : this.animation.playState } get startTime() { return Number(this.animation.startTime) } set startTime(r) { this.animation.startTime = r } attachTimeline({ timeline: r, observe: i }) { return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, r && RS() ? (this.animation.timeline = r, zt) : i(this) } } const vg = { anticipate: Xm, backInOut: Ym, circInOut: qm }; function FS(t) { return t in vg } function VS(t) { typeof t.ease == "string" && FS(t.ease) && (t.ease = vg[t.ease]) } const Zh = 10; class IS extends DS { constructor(r) { VS(r), dg(r), super(r), r.startTime && (this.startTime = r.startTime), this.options = r } updateMotionValue(r) { const { motionValue: i, onUpdate: s, onComplete: l, element: c, ...u } = this.options; if (!i) return; if (r !== void 0) { i.set(r); return } const d = new Ec({ ...u, autoplay: !1 }), h = an(this.finishedTime ?? this.time); i.setWithVelocity(d.sample(h - Zh).value, d.sample(h).value, Zh), d.stop() } } const Jh = (t, r) => r === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (Xn.test(t) || t === "0") && !t.startsWith("url(")); function _S(t) { const r = t[0]; if (t.length === 1) return !0; for (let i = 0; i < t.length; i++)if (t[i] !== r) return !0 } function OS(t, r, i, s) { const l = t[0]; if (l === null) return !1; if (r === "display" || r === "visibility") return !0; const c = t[t.length - 1], u = Jh(l, r), d = Jh(c, r); return !u || !d ? !1 : _S(t) || (i === "spring" || yg(i)) && s } function Bu(t) { t.duration = 0, t.type = "keyframes" } const zS = new Set(["opacity", "clipPath", "filter", "transform"]), BS = dc(() => Object.hasOwnProperty.call(Element.prototype, "animate")); function US(t) { const { motionValue: r, name: i, repeatDelay: s, repeatType: l, damping: c, type: u } = t; if (!(r?.owner?.current instanceof HTMLElement)) return !1; const { onUpdate: h, transformTemplate: m } = r.owner.getProps(); return BS() && i && zS.has(i) && (i !== "transform" || !m) && !h && !s && l !== "mirror" && c !== 0 && u !== "inertia" } const $S = 40; class WS extends kc { constructor({ autoplay: r = !0, delay: i = 0, type: s = "keyframes", repeat: l = 0, repeatDelay: c = 0, repeatType: u = "loop", keyframes: d, name: h, motionValue: m, element: g, ...v }) { super(), this.stop = () => { this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel() }, this.createdAt = St.now(); const w = { autoplay: r, delay: i, type: s, repeat: l, repeatDelay: c, repeatType: u, name: h, motionValue: m, element: g, ...v }, k = g?.KeyframeResolver || Cc; this.keyframeResolver = new k(d, (E, N, C) => this.onKeyframesResolved(E, N, w, !C), h, m, g), this.keyframeResolver?.scheduleResolve() } onKeyframesResolved(r, i, s, l) { this.keyframeResolver = void 0; const { name: c, type: u, velocity: d, delay: h, isHandoff: m, onUpdate: g } = s; this.resolvedAt = St.now(), OS(r, c, u, d) || ((Pn.instantAnimations || !h) && g?.(Sc(r, s, i)), r[0] = r[r.length - 1], Bu(s), s.repeat = 0); const w = { startTime: l ? this.resolvedAt ? this.resolvedAt - this.createdAt > $S ? this.resolvedAt : this.createdAt : this.createdAt : void 0, finalKeyframe: i, ...s, keyframes: r }, k = !m && US(w) ? new IS({ ...w, element: w.motionValue.owner.current }) : new Ec(w); k.finished.then(() => this.notifyFinished()).catch(zt), this.pendingTimeline && (this.stopTimeline = k.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = k } get finished() { return this._animation ? this.animation.finished : this._finished } then(r, i) { return this.finished.finally(r).then(() => { }) } get animation() { return this._animation || (this.keyframeResolver?.resume(), TS()), this._animation } get duration() { return this.animation.duration } get iterationDuration() { return this.animation.iterationDuration } get time() { return this.animation.time } set time(r) { this.animation.time = r } get speed() { return this.animation.speed } get state() { return this.animation.state } set speed(r) { this.animation.speed = r } get startTime() { return this.animation.startTime } attachTimeline(r) { return this._animation ? this.stopTimeline = this.animation.attachTimeline(r) : this.pendingTimeline = r, () => this.stop() } play() { this.animation.play() } pause() { this.animation.pause() } complete() { this.animation.complete() } cancel() { this._animation && this.animation.cancel(), this.keyframeResolver?.cancel() } } const HS = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function KS(t) { const r = HS.exec(t); if (!r) return [,]; const [, i, s, l] = r; return [`--${i ?? s}`, l] } function xg(t, r, i = 1) { const [s, l] = KS(t); if (!s) return; const c = window.getComputedStyle(r).getPropertyValue(s); if (c) { const u = c.trim(); return zm(u) ? parseFloat(u) : u } return gc(l) ? xg(l, r, i + 1) : l } function Pc(t, r) { return t?.[r] ?? t?.default ?? t } const wg = new Set(["width", "height", "top", "left", "right", "bottom", ...si]), GS = { test: t => t === "auto", parse: t => t }, Sg = t => r => r.test(t), kg = [oi, de, ln, Gn, _w, Iw, GS], ep = t => kg.find(Sg(t)); function YS(t) { return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || Um(t) : !0 } const XS = new Set(["brightness", "contrast", "saturate", "opacity"]); function QS(t) { const [r, i] = t.slice(0, -1).split("("); if (r === "drop-shadow") return t; const [s] = i.match(yc) || []; if (!s) return t; const l = i.replace(s, ""); let c = XS.has(r) ? 1 : 0; return s !== i && (c *= 100), r + "(" + c + l + ")" } const qS = /\b([a-z-]*)\(.*?\)/gu, Uu = { ...Xn, getAnimatableNone: t => { const r = t.match(qS); return r ? r.map(QS).join(" ") : t } }, tp = { ...oi, transform: Math.round }, ZS = { rotate: Gn, rotateX: Gn, rotateY: Gn, rotateZ: Gn, scale: Hs, scaleX: Hs, scaleY: Hs, scaleZ: Hs, skew: Gn, skewX: Gn, skewY: Gn, distance: de, translateX: de, translateY: de, translateZ: de, x: de, y: de, z: de, perspective: de, transformPerspective: de, opacity: go, originX: Uh, originY: Uh, originZ: de }, Tc = { borderWidth: de, borderTopWidth: de, borderRightWidth: de, borderBottomWidth: de, borderLeftWidth: de, borderRadius: de, radius: de, borderTopLeftRadius: de, borderTopRightRadius: de, borderBottomRightRadius: de, borderBottomLeftRadius: de, width: de, maxWidth: de, height: de, maxHeight: de, top: de, right: de, bottom: de, left: de, padding: de, paddingTop: de, paddingRight: de, paddingBottom: de, paddingLeft: de, margin: de, marginTop: de, marginRight: de, marginBottom: de, marginLeft: de, backgroundPositionX: de, backgroundPositionY: de, ...ZS, zIndex: tp, fillOpacity: go, strokeOpacity: go, numOctaves: tp }, JS = { ...Tc, color: Ye, backgroundColor: Ye, outlineColor: Ye, fill: Ye, stroke: Ye, borderColor: Ye, borderTopColor: Ye, borderRightColor: Ye, borderBottomColor: Ye, borderLeftColor: Ye, filter: Uu, WebkitFilter: Uu }, Eg = t => JS[t]; function Cg(t, r) { let i = Eg(t); return i !== Uu && (i = Xn), i.getAnimatableNone ? i.getAnimatableNone(r) : void 0 } const ek = new Set(["auto", "none", "0"]); function tk(t, r, i) { let s = 0, l; for (; s < t.length && !l;) { const c = t[s]; typeof c == "string" && !ek.has(c) && yo(c).values.length && (l = t[s]), s++ } if (l && i) for (const c of r) t[c] = Cg(i, l) } class nk extends Cc { constructor(r, i, s, l, c) { super(r, i, s, l, c, !0) } readKeyframes() { const { unresolvedKeyframes: r, element: i, name: s } = this; if (!i || !i.current) return; super.readKeyframes(); for (let h = 0; h < r.length; h++) { let m = r[h]; if (typeof m == "string" && (m = m.trim(), gc(m))) { const g = xg(m, i.current); g !== void 0 && (r[h] = g), h === r.length - 1 && (this.finalKeyframe = m) } } if (this.resolveNoneKeyframes(), !wg.has(s) || r.length !== 2) return; const [l, c] = r, u = ep(l), d = ep(c); if (u !== d) if (Qh(u) && Qh(d)) for (let h = 0; h < r.length; h++) { const m = r[h]; typeof m == "string" && (r[h] = parseFloat(m)) } else vr[s] && (this.needsMeasurement = !0) } resolveNoneKeyframes() { const { unresolvedKeyframes: r, name: i } = this, s = []; for (let l = 0; l < r.length; l++)(r[l] === null || YS(r[l])) && s.push(l); s.length && tk(r, s, i) } measureInitialState() { const { element: r, unresolvedKeyframes: i, name: s } = this; if (!r || !r.current) return; s === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = vr[s](r.measureViewportBox(), window.getComputedStyle(r.current)), i[0] = this.measuredOrigin; const l = i[i.length - 1]; l !== void 0 && r.getValue(s, l).jump(l, !1) } measureEndState() { const { element: r, name: i, unresolvedKeyframes: s } = this; if (!r || !r.current) return; const l = r.getValue(i); l && l.jump(this.measuredOrigin, !1); const c = s.length - 1, u = s[c]; s[c] = vr[i](r.measureViewportBox(), window.getComputedStyle(r.current)), u !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = u), this.removedTransforms?.length && this.removedTransforms.forEach(([d, h]) => { r.getValue(d).set(h) }), this.resolveNoneKeyframes() } } function rk(t, r, i) { if (t instanceof EventTarget) return [t]; if (typeof t == "string") { let s = document; const l = i?.[t] ?? s.querySelectorAll(t); return l ? Array.from(l) : [] } return Array.from(t) } const Pg = (t, r) => r && typeof t == "number" ? r.transform(t) : t; function ik(t) { return Bm(t) && "offsetHeight" in t } const np = 30, ok = t => !isNaN(parseFloat(t)); class sk { constructor(r, i = {}) { this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = s => { const l = St.now(); if (this.updatedAt !== l && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(s), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents)) for (const c of this.dependents) c.dirty() }, this.hasAnimated = !1, this.setCurrent(r), this.owner = i.owner } setCurrent(r) { this.current = r, this.updatedAt = St.now(), this.canTrackVelocity === null && r !== void 0 && (this.canTrackVelocity = ok(this.current)) } setPrevFrameValue(r = this.current) { this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt } onChange(r) { return this.on("change", r) } on(r, i) { this.events[r] || (this.events[r] = new hc); const s = this.events[r].add(i); return r === "change" ? () => { s(), Ie.read(() => { this.events.change.getSize() || this.stop() }) } : s } clearListeners() { for (const r in this.events) this.events[r].clear() } attach(r, i) { this.passiveEffect = r, this.stopPassiveEffect = i } set(r) { this.passiveEffect ? this.passiveEffect(r, this.updateAndNotify) : this.updateAndNotify(r) } setWithVelocity(r, i, s) { this.set(i), this.prev = void 0, this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt - s } jump(r, i = !0) { this.updateAndNotify(r), this.prev = r, this.prevUpdatedAt = this.prevFrameValue = void 0, i && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } dirty() { this.events.change?.notify(this.current) } addDependent(r) { this.dependents || (this.dependents = new Set), this.dependents.add(r) } removeDependent(r) { this.dependents && this.dependents.delete(r) } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const r = St.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || r - this.updatedAt > np) return 0; const i = Math.min(this.updatedAt - this.prevUpdatedAt, np); return $m(parseFloat(this.current) - parseFloat(this.prevFrameValue), i) } start(r) { return this.stop(), new Promise(i => { this.hasAnimated = !0, this.animation = r(i), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function ti(t, r) { return new sk(t, r) } const { schedule: Nc } = eg(queueMicrotask, !1), Qt = { x: !1, y: !1 }; function Tg() { return Qt.x || Qt.y } function ak(t) { return t === "x" || t === "y" ? Qt[t] ? null : (Qt[t] = !0, () => { Qt[t] = !1 }) : Qt.x || Qt.y ? null : (Qt.x = Qt.y = !0, () => { Qt.x = Qt.y = !1 }) } function Ng(t, r) { const i = rk(t), s = new AbortController, l = { passive: !0, ...r, signal: s.signal }; return [i, l, () => s.abort()] } function rp(t) { return !(t.pointerType === "touch" || Tg()) } function lk(t, r, i = {}) { const [s, l, c] = Ng(t, i), u = d => { if (!rp(d)) return; const { target: h } = d, m = r(h, d); if (typeof m != "function" || !h) return; const g = v => { rp(v) && (m(v), h.removeEventListener("pointerleave", g)) }; h.addEventListener("pointerleave", g, l) }; return s.forEach(d => { d.addEventListener("pointerenter", u, l) }), c } const bg = (t, r) => r ? t === r ? !0 : bg(t, r.parentElement) : !1, bc = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1, uk = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function ck(t) { return uk.has(t.tagName) || t.tabIndex !== -1 } const Zs = new WeakSet; function ip(t) { return r => { r.key === "Enter" && t(r) } } function mu(t, r) { t.dispatchEvent(new PointerEvent("pointer" + r, { isPrimary: !0, bubbles: !0 })) } const fk = (t, r) => { const i = t.currentTarget; if (!i) return; const s = ip(() => { if (Zs.has(i)) return; mu(i, "down"); const l = ip(() => { mu(i, "up") }), c = () => mu(i, "cancel"); i.addEventListener("keyup", l, r), i.addEventListener("blur", c, r) }); i.addEventListener("keydown", s, r), i.addEventListener("blur", () => i.removeEventListener("keydown", s), r) }; function op(t) { return bc(t) && !Tg() } function dk(t, r, i = {}) { const [s, l, c] = Ng(t, i), u = d => { const h = d.currentTarget; if (!op(d)) return; Zs.add(h); const m = r(h, d), g = (k, E) => { window.removeEventListener("pointerup", v), window.removeEventListener("pointercancel", w), Zs.has(h) && Zs.delete(h), op(k) && typeof m == "function" && m(k, { success: E }) }, v = k => { g(k, h === window || h === document || i.useGlobalTarget || bg(h, k.target)) }, w = k => { g(k, !1) }; window.addEventListener("pointerup", v, l), window.addEventListener("pointercancel", w, l) }; return s.forEach(d => { (i.useGlobalTarget ? window : d).addEventListener("pointerdown", u, l), ik(d) && (d.addEventListener("focus", m => fk(m, l)), !ck(d) && !d.hasAttribute("tabindex") && (d.tabIndex = 0)) }), c } function Rg(t) { return Bm(t) && "ownerSVGElement" in t } function hk(t) { return Rg(t) && t.tagName === "svg" } const ft = t => !!(t && t.getVelocity), pk = [...kg, Ye, Xn], mk = t => pk.find(Sg(t)), jg = b.createContext({ transformPagePoint: t => t, isStatic: !1, reducedMotion: "never" }); function gk(t = !0) { const r = b.useContext(lc); if (r === null) return [!0, null]; const { isPresent: i, onExitComplete: s, register: l } = r, c = b.useId(); b.useEffect(() => { if (t) return l(c) }, [t]); const u = b.useCallback(() => t && s && s(c), [c, s, t]); return !i && s ? [!1, u] : [!0] } const Ag = b.createContext({ strict: !1 }), sp = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, ni = {}; for (const t in sp) ni[t] = { isEnabled: r => sp[t].some(i => !!r[i]) }; function yk(t) { for (const r in t) ni[r] = { ...ni[r], ...t[r] } } const vk = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function oa(t) { return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || vk.has(t) } let Mg = t => !oa(t); function xk(t) { typeof t == "function" && (Mg = r => r.startsWith("on") ? !oa(r) : t(r)) } try { xk(require("@emotion/is-prop-valid").default) } catch { } function wk(t, r, i) { const s = {}; for (const l in t) l === "values" && typeof t.values == "object" || (Mg(l) || i === !0 && oa(l) || !r && !oa(l) || t.draggable && l.startsWith("onDrag")) && (s[l] = t[l]); return s } const pa = b.createContext({}); function ma(t) { return t !== null && typeof t == "object" && typeof t.start == "function" } function vo(t) { return typeof t == "string" || Array.isArray(t) } const Rc = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], jc = ["initial", ...Rc]; function ga(t) { return ma(t.animate) || jc.some(r => vo(t[r])) } function Lg(t) { return !!(ga(t) || t.variants) } function Sk(t, r) { if (ga(t)) { const { initial: i, animate: s } = t; return { initial: i === !1 || vo(i) ? i : void 0, animate: vo(s) ? s : void 0 } } return t.inherit !== !1 ? r : {} } function kk(t) { const { initial: r, animate: i } = Sk(t, b.useContext(pa)); return b.useMemo(() => ({ initial: r, animate: i }), [ap(r), ap(i)]) } function ap(t) { return Array.isArray(t) ? t.join(" ") : t } function lp(t, r) { return r.max === r.min ? 0 : t / (r.max - r.min) * 100 } const io = { correct: (t, r) => { if (!r.target) return t; if (typeof t == "string") if (de.test(t)) t = parseFloat(t); else return t; const i = lp(t, r.target.x), s = lp(t, r.target.y); return `${i}% ${s}%` } }, Ek = { correct: (t, { treeScale: r, projectionDelta: i }) => { const s = t, l = Xn.parse(t); if (l.length > 5) return s; const c = Xn.createTransformer(t), u = typeof l[0] != "number" ? 1 : 0, d = i.x.scale * r.x, h = i.y.scale * r.y; l[0 + u] /= d, l[1 + u] /= h; const m = ze(d, h, .5); return typeof l[2 + u] == "number" && (l[2 + u] /= m), typeof l[3 + u] == "number" && (l[3 + u] /= m), c(l) } }, $u = { borderRadius: { ...io, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: io, borderTopRightRadius: io, borderBottomLeftRadius: io, borderBottomRightRadius: io, boxShadow: Ek }; function Dg(t, { layout: r, layoutId: i }) { return ai.has(t) || t.startsWith("origin") || (r || i !== void 0) && (!!$u[t] || t === "opacity") } const Ck = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, Pk = si.length; function Tk(t, r, i) { let s = "", l = !0; for (let c = 0; c < Pk; c++) { const u = si[c], d = t[u]; if (d === void 0) continue; let h = !0; if (typeof d == "number" ? h = d === (u.startsWith("scale") ? 1 : 0) : h = parseFloat(d) === 0, !h || i) { const m = Pg(d, Tc[u]); if (!h) { l = !1; const g = Ck[u] || u; s += `${g}(${m}) ` } i && (r[u] = m) } } return s = s.trim(), i ? s = i(r, l ? "" : s) : l && (s = "none"), s } function Ac(t, r, i) { const { style: s, vars: l, transformOrigin: c } = t; let u = !1, d = !1; for (const h in r) { const m = r[h]; if (ai.has(h)) { u = !0; continue } else if (ng(h)) { l[h] = m; continue } else { const g = Pg(m, Tc[h]); h.startsWith("origin") ? (d = !0, c[h] = g) : s[h] = g } } if (r.transform || (u || i ? s.transform = Tk(r, t.transform, i) : s.transform && (s.transform = "none")), d) { const { originX: h = "50%", originY: m = "50%", originZ: g = 0 } = c; s.transformOrigin = `${h} ${m} ${g}` } } const Mc = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function Fg(t, r, i) { for (const s in r) !ft(r[s]) && !Dg(s, i) && (t[s] = r[s]) } function Nk({ transformTemplate: t }, r) { return b.useMemo(() => { const i = Mc(); return Ac(i, r, t), Object.assign({}, i.vars, i.style) }, [r]) } function bk(t, r) { const i = t.style || {}, s = {}; return Fg(s, i, t), Object.assign(s, Nk(t, r)), s } function Rk(t, r) { const i = {}, s = bk(t, r); return t.drag && t.dragListener !== !1 && (i.draggable = !1, s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = "none", s.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (i.tabIndex = 0), i.style = s, i } const jk = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, Ak = { offset: "strokeDashoffset", array: "strokeDasharray" }; function Mk(t, r, i = 1, s = 0, l = !0) { t.pathLength = 1; const c = l ? jk : Ak; t[c.offset] = de.transform(-s); const u = de.transform(r), d = de.transform(i); t[c.array] = `${u} ${d}` } function Vg(t, { attrX: r, attrY: i, attrScale: s, pathLength: l, pathSpacing: c = 1, pathOffset: u = 0, ...d }, h, m, g) { if (Ac(t, d, m), h) { t.style.viewBox && (t.attrs.viewBox = t.style.viewBox); return } t.attrs = t.style, t.style = {}; const { attrs: v, style: w } = t; v.transform && (w.transform = v.transform, delete v.transform), (w.transform || v.transformOrigin) && (w.transformOrigin = v.transformOrigin ?? "50% 50%", delete v.transformOrigin), w.transform && (w.transformBox = g?.transformBox ?? "fill-box", delete v.transformBox), r !== void 0 && (v.x = r), i !== void 0 && (v.y = i), s !== void 0 && (v.scale = s), l !== void 0 && Mk(v, l, c, u, !1) } const Ig = () => ({ ...Mc(), attrs: {} }), _g = t => typeof t == "string" && t.toLowerCase() === "svg"; function Lk(t, r, i, s) { const l = b.useMemo(() => { const c = Ig(); return Vg(c, r, _g(s), t.transformTemplate, t.style), { ...c.attrs, style: { ...c.style } } }, [r]); if (t.style) { const c = {}; Fg(c, t.style, t), l.style = { ...c, ...l.style } } return l } const Dk = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Lc(t) { return typeof t != "string" || t.includes("-") ? !1 : !!(Dk.indexOf(t) > -1 || /[A-Z]/u.test(t)) } function Fk(t, r, i, { latestValues: s }, l, c = !1) { const d = (Lc(t) ? Lk : Rk)(r, s, l, t), h = wk(r, typeof t == "string", c), m = t !== b.Fragment ? { ...h, ...d, ref: i } : {}, { children: g } = r, v = b.useMemo(() => ft(g) ? g.get() : g, [g]); return b.createElement(t, { ...m, children: v }) } function up(t) { const r = [{}, {}]; return t?.values.forEach((i, s) => { r[0][s] = i.get(), r[1][s] = i.getVelocity() }), r } function Dc(t, r, i, s) { if (typeof r == "function") { const [l, c] = up(s); r = r(i !== void 0 ? i : t.custom, l, c) } if (typeof r == "string" && (r = t.variants && t.variants[r]), typeof r == "function") { const [l, c] = up(s); r = r(i !== void 0 ? i : t.custom, l, c) } return r } function Js(t) { return ft(t) ? t.get() : t } function Vk({ scrapeMotionValuesFromProps: t, createRenderState: r }, i, s, l) { return { latestValues: Ik(i, s, l, t), renderState: r() } } function Ik(t, r, i, s) { const l = {}, c = s(t, {}); for (const w in c) l[w] = Js(c[w]); let { initial: u, animate: d } = t; const h = ga(t), m = Lg(t); r && m && !h && t.inherit !== !1 && (u === void 0 && (u = r.initial), d === void 0 && (d = r.animate)); let g = i ? i.initial === !1 : !1; g = g || u === !1; const v = g ? d : u; if (v && typeof v != "boolean" && !ma(v)) { const w = Array.isArray(v) ? v : [v]; for (let k = 0; k < w.length; k++) { const E = Dc(t, w[k]); if (E) { const { transitionEnd: N, transition: C, ...P } = E; for (const A in P) { let L = P[A]; if (Array.isArray(L)) { const U = g ? L.length - 1 : 0; L = L[U] } L !== null && (l[A] = L) } for (const A in N) l[A] = N[A] } } } return l } const Og = t => (r, i) => { const s = b.useContext(pa), l = b.useContext(lc), c = () => Vk(t, r, s, l); return i ? c() : yw(c) }; function Fc(t, r, i) { const { style: s } = t, l = {}; for (const c in s) (ft(s[c]) || r.style && ft(r.style[c]) || Dg(c, t) || i?.getValue(c)?.liveStyle !== void 0) && (l[c] = s[c]); return l } const _k = Og({ scrapeMotionValuesFromProps: Fc, createRenderState: Mc }); function zg(t, r, i) { const s = Fc(t, r, i); for (const l in t) if (ft(t[l]) || ft(r[l])) { const c = si.indexOf(l) !== -1 ? "attr" + l.charAt(0).toUpperCase() + l.substring(1) : l; s[c] = t[l] } return s } const Ok = Og({ scrapeMotionValuesFromProps: zg, createRenderState: Ig }), zk = Symbol.for("motionComponentSymbol"); function Qr(t) { return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current") } function Bk(t, r, i) { return b.useCallback(s => { s && t.onMount && t.onMount(s), r && (s ? r.mount(s) : r.unmount()), i && (typeof i == "function" ? i(s) : Qr(i) && (i.current = s)) }, [r]) } const Vc = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), Uk = "framerAppearId", Bg = "data-" + Vc(Uk), Ug = b.createContext({}); function $k(t, r, i, s, l) { const { visualElement: c } = b.useContext(pa), u = b.useContext(Ag), d = b.useContext(lc), h = b.useContext(jg).reducedMotion, m = b.useRef(null); s = s || u.renderer, !m.current && s && (m.current = s(t, { visualState: r, parent: c, props: i, presenceContext: d, blockInitialAnimation: d ? d.initial === !1 : !1, reducedMotionConfig: h })); const g = m.current, v = b.useContext(Ug); g && !g.projection && l && (g.type === "html" || g.type === "svg") && Wk(m.current, i, l, v); const w = b.useRef(!1); b.useInsertionEffect(() => { g && w.current && g.update(i, d) }); const k = i[Bg], E = b.useRef(!!k && !window.MotionHandoffIsComplete?.(k) && window.MotionHasOptimisedAnimation?.(k)); return vw(() => { g && (w.current = !0, window.MotionIsMounted = !0, g.updateFeatures(), g.scheduleRenderMicrotask(), E.current && g.animationState && g.animationState.animateChanges()) }), b.useEffect(() => { g && (!E.current && g.animationState && g.animationState.animateChanges(), E.current && (queueMicrotask(() => { window.MotionHandoffMarkAsComplete?.(k) }), E.current = !1), g.enteringChildren = void 0) }), g } function Wk(t, r, i, s) { const { layoutId: l, layout: c, drag: u, dragConstraints: d, layoutScroll: h, layoutRoot: m, layoutCrossfade: g } = r; t.projection = new i(t.latestValues, r["data-framer-portal-id"] ? void 0 : $g(t.parent)), t.projection.setOptions({ layoutId: l, layout: c, alwaysMeasureLayout: !!u || d && Qr(d), visualElement: t, animationType: typeof c == "string" ? c : "both", initialPromotionConfig: s, crossfade: g, layoutScroll: h, layoutRoot: m }) } function $g(t) { if (t) return t.options.allowProjection !== !1 ? t.projection : $g(t.parent) } function gu(t, { forwardMotionProps: r = !1 } = {}, i, s) { i && yk(i); const l = Lc(t) ? Ok : _k; function c(d, h) { let m; const g = { ...b.useContext(jg), ...d, layoutId: Hk(d) }, { isStatic: v } = g, w = kk(d), k = l(d, v); if (!v && ac) { Kk(); const E = Gk(g); m = E.MeasureLayout, w.visualElement = $k(t, k, g, s, E.ProjectionNode) } return x.jsxs(pa.Provider, { value: w, children: [m && w.visualElement ? x.jsx(m, { visualElement: w.visualElement, ...g }) : null, Fk(t, d, Bk(k, w.visualElement, h), k, v, r)] }) } c.displayName = `motion.${typeof t == "string" ? t : `create(${t.displayName ?? t.name ?? ""})`}`; const u = b.forwardRef(c); return u[zk] = t, u } function Hk({ layoutId: t }) { const r = b.useContext(Om).id; return r && t !== void 0 ? r + "-" + t : t } function Kk(t, r) { b.useContext(Ag).strict } function Gk(t) { const { drag: r, layout: i } = ni; if (!r && !i) return {}; const s = { ...r, ...i }; return { MeasureLayout: r?.isEnabled(t) || i?.isEnabled(t) ? s.MeasureLayout : void 0, ProjectionNode: s.ProjectionNode } } function Yk(t, r) { if (typeof Proxy > "u") return gu; const i = new Map, s = (c, u) => gu(c, u, t, r), l = (c, u) => s(c, u); return new Proxy(l, { get: (c, u) => u === "create" ? s : (i.has(u) || i.set(u, gu(u, void 0, t, r)), i.get(u)) }) } function Wg({ top: t, left: r, right: i, bottom: s }) { return { x: { min: r, max: i }, y: { min: t, max: s } } } function Xk({ x: t, y: r }) { return { top: r.min, right: t.max, bottom: r.max, left: t.min } } function Qk(t, r) { if (!r) return t; const i = r({ x: t.left, y: t.top }), s = r({ x: t.right, y: t.bottom }); return { top: i.y, left: i.x, bottom: s.y, right: s.x } } function yu(t) { return t === void 0 || t === 1 } function Wu({ scale: t, scaleX: r, scaleY: i }) { return !yu(t) || !yu(r) || !yu(i) } function mr(t) { return Wu(t) || Hg(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY } function Hg(t) { return cp(t.x) || cp(t.y) } function cp(t) { return t && t !== "0%" } function sa(t, r, i) { const s = t - i, l = r * s; return i + l } function fp(t, r, i, s, l) { return l !== void 0 && (t = sa(t, l, s)), sa(t, i, s) + r } function Hu(t, r = 0, i = 1, s, l) { t.min = fp(t.min, r, i, s, l), t.max = fp(t.max, r, i, s, l) } function Kg(t, { x: r, y: i }) { Hu(t.x, r.translate, r.scale, r.originPoint), Hu(t.y, i.translate, i.scale, i.originPoint) } const dp = .999999999999, hp = 1.0000000000001; function qk(t, r, i, s = !1) { const l = i.length; if (!l) return; r.x = r.y = 1; let c, u; for (let d = 0; d < l; d++) { c = i[d], u = c.projectionDelta; const { visualElement: h } = c.options; h && h.props.style && h.props.style.display === "contents" || (s && c.options.layoutScroll && c.scroll && c !== c.root && Zr(t, { x: -c.scroll.offset.x, y: -c.scroll.offset.y }), u && (r.x *= u.x.scale, r.y *= u.y.scale, Kg(t, u)), s && mr(c.latestValues) && Zr(t, c.latestValues)) } r.x < hp && r.x > dp && (r.x = 1), r.y < hp && r.y > dp && (r.y = 1) } function qr(t, r) { t.min = t.min + r, t.max = t.max + r } function pp(t, r, i, s, l = .5) { const c = ze(t.min, t.max, l); Hu(t, r, i, c, s) } function Zr(t, r) { pp(t.x, r.x, r.scaleX, r.scale, r.originX), pp(t.y, r.y, r.scaleY, r.scale, r.originY) } function Gg(t, r) { return Wg(Qk(t.getBoundingClientRect(), r)) } function Zk(t, r, i) { const s = Gg(t, i), { scroll: l } = r; return l && (qr(s.x, l.offset.x), qr(s.y, l.offset.y)), s } const mp = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Jr = () => ({ x: mp(), y: mp() }), gp = () => ({ min: 0, max: 0 }), Ze = () => ({ x: gp(), y: gp() }), Ku = { current: null }, Yg = { current: !1 }; function Jk() { if (Yg.current = !0, !!ac) if (window.matchMedia) { const t = window.matchMedia("(prefers-reduced-motion)"), r = () => Ku.current = t.matches; t.addEventListener("change", r), r() } else Ku.current = !1 } const e2 = new WeakMap; function t2(t, r, i) { for (const s in r) { const l = r[s], c = i[s]; if (ft(l)) t.addValue(s, l); else if (ft(c)) t.addValue(s, ti(l, { owner: t })); else if (c !== l) if (t.hasValue(s)) { const u = t.getValue(s); u.liveStyle === !0 ? u.jump(l) : u.hasAnimated || u.set(l) } else { const u = t.getStaticValue(s); t.addValue(s, ti(u !== void 0 ? u : l, { owner: t })) } } for (const s in i) r[s] === void 0 && t.removeValue(s); return r } const yp = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class n2 { scrapeMotionValuesFromProps(r, i, s) { return {} } constructor({ parent: r, props: i, presenceContext: s, reducedMotionConfig: l, blockInitialAnimation: c, visualState: u }, d = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = Cc, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const w = St.now(); this.renderScheduledAt < w && (this.renderScheduledAt = w, Ie.render(this.render, !1, !0)) }; const { latestValues: h, renderState: m } = u; this.latestValues = h, this.baseTarget = { ...h }, this.initialValues = i.initial ? { ...h } : {}, this.renderState = m, this.parent = r, this.props = i, this.presenceContext = s, this.depth = r ? r.depth + 1 : 0, this.reducedMotionConfig = l, this.options = d, this.blockInitialAnimation = !!c, this.isControllingVariants = ga(i), this.isVariantNode = Lg(i), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(r && r.current); const { willChange: g, ...v } = this.scrapeMotionValuesFromProps(i, {}, this); for (const w in v) { const k = v[w]; h[w] !== void 0 && ft(k) && k.set(h[w]) } } mount(r) { this.current = r, e2.set(r, this), this.projection && !this.projection.instance && this.projection.mount(r), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((i, s) => this.bindToMotionValue(s, i)), Yg.current || Jk(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Ku.current, this.parent?.addChild(this), this.update(this.props, this.presenceContext) } unmount() { this.projection && this.projection.unmount(), Yn(this.notifyUpdate), Yn(this.render), this.valueSubscriptions.forEach(r => r()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this); for (const r in this.events) this.events[r].clear(); for (const r in this.features) { const i = this.features[r]; i && (i.unmount(), i.isMounted = !1) } this.current = null } addChild(r) { this.children.add(r), this.enteringChildren ?? (this.enteringChildren = new Set), this.enteringChildren.add(r) } removeChild(r) { this.children.delete(r), this.enteringChildren && this.enteringChildren.delete(r) } bindToMotionValue(r, i) { this.valueSubscriptions.has(r) && this.valueSubscriptions.get(r)(); const s = ai.has(r); s && this.onBindTransform && this.onBindTransform(); const l = i.on("change", u => { this.latestValues[r] = u, this.props.onUpdate && Ie.preRender(this.notifyUpdate), s && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender() }); let c; window.MotionCheckAppearSync && (c = window.MotionCheckAppearSync(this, r, i)), this.valueSubscriptions.set(r, () => { l(), c && c(), i.owner && i.stop() }) } sortNodePosition(r) { return !this.current || !this.sortInstanceNodePosition || this.type !== r.type ? 0 : this.sortInstanceNodePosition(this.current, r.current) } updateFeatures() { let r = "animation"; for (r in ni) { const i = ni[r]; if (!i) continue; const { isEnabled: s, Feature: l } = i; if (!this.features[r] && l && s(this.props) && (this.features[r] = new l(this)), this.features[r]) { const c = this.features[r]; c.isMounted ? c.update() : (c.mount(), c.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Ze() } getStaticValue(r) { return this.latestValues[r] } setStaticValue(r, i) { this.latestValues[r] = i } update(r, i) { (r.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = r, this.prevPresenceContext = this.presenceContext, this.presenceContext = i; for (let s = 0; s < yp.length; s++) { const l = yp[s]; this.propEventSubscriptions[l] && (this.propEventSubscriptions[l](), delete this.propEventSubscriptions[l]); const c = "on" + l, u = r[c]; u && (this.propEventSubscriptions[l] = this.on(l, u)) } this.prevMotionValues = t2(this, this.scrapeMotionValuesFromProps(r, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(r) { return this.props.variants ? this.props.variants[r] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(r) { const i = this.getClosestVariantNode(); if (i) return i.variantChildren && i.variantChildren.add(r), () => i.variantChildren.delete(r) } addValue(r, i) { const s = this.values.get(r); i !== s && (s && this.removeValue(r), this.bindToMotionValue(r, i), this.values.set(r, i), this.latestValues[r] = i.get()) } removeValue(r) { this.values.delete(r); const i = this.valueSubscriptions.get(r); i && (i(), this.valueSubscriptions.delete(r)), delete this.latestValues[r], this.removeValueFromRenderState(r, this.renderState) } hasValue(r) { return this.values.has(r) } getValue(r, i) { if (this.props.values && this.props.values[r]) return this.props.values[r]; let s = this.values.get(r); return s === void 0 && i !== void 0 && (s = ti(i === null ? void 0 : i, { owner: this }), this.addValue(r, s)), s } readValue(r, i) { let s = this.latestValues[r] !== void 0 || !this.current ? this.latestValues[r] : this.getBaseTargetFromProps(this.props, r) ?? this.readValueFromInstance(this.current, r, this.options); return s != null && (typeof s == "string" && (zm(s) || Um(s)) ? s = parseFloat(s) : !mk(s) && Xn.test(i) && (s = Cg(r, i)), this.setBaseTarget(r, ft(s) ? s.get() : s)), ft(s) ? s.get() : s } setBaseTarget(r, i) { this.baseTarget[r] = i } getBaseTarget(r) { const { initial: i } = this.props; let s; if (typeof i == "string" || typeof i == "object") { const c = Dc(this.props, i, this.presenceContext?.custom); c && (s = c[r]) } if (i && s !== void 0) return s; const l = this.getBaseTargetFromProps(this.props, r); return l !== void 0 && !ft(l) ? l : this.initialValues[r] !== void 0 && s === void 0 ? void 0 : this.baseTarget[r] } on(r, i) { return this.events[r] || (this.events[r] = new hc), this.events[r].add(i) } notify(r, ...i) { this.events[r] && this.events[r].notify(...i) } scheduleRenderMicrotask() { Nc.render(this.render) } } class Xg extends n2 { constructor() { super(...arguments), this.KeyframeResolver = nk } sortInstanceNodePosition(r, i) { return r.compareDocumentPosition(i) & 2 ? 1 : -1 } getBaseTargetFromProps(r, i) { return r.style ? r.style[i] : void 0 } removeValueFromRenderState(r, { vars: i, style: s }) { delete i[r], delete s[r] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: r } = this.props; ft(r) && (this.childSubscription = r.on("change", i => { this.current && (this.current.textContent = `${i}`) })) } } function Qg(t, { style: r, vars: i }, s, l) { const c = t.style; let u; for (u in r) c[u] = r[u]; l?.applyProjectionStyles(c, s); for (u in i) c.setProperty(u, i[u]) } function r2(t) { return window.getComputedStyle(t) } class i2 extends Xg { constructor() { super(...arguments), this.type = "html", this.renderInstance = Qg } readValueFromInstance(r, i) { if (ai.has(i)) return this.projection?.isProjecting ? Vu(i) : SS(r, i); { const s = r2(r), l = (ng(i) ? s.getPropertyValue(i) : s[i]) || 0; return typeof l == "string" ? l.trim() : l } } measureInstanceViewportBox(r, { transformPagePoint: i }) { return Gg(r, i) } build(r, i, s) { Ac(r, i, s.transformTemplate) } scrapeMotionValuesFromProps(r, i, s) { return Fc(r, i, s) } } const qg = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function o2(t, r, i, s) { Qg(t, r, void 0, s); for (const l in r.attrs) t.setAttribute(qg.has(l) ? l : Vc(l), r.attrs[l]) } class s2 extends Xg { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Ze } getBaseTargetFromProps(r, i) { return r[i] } readValueFromInstance(r, i) { if (ai.has(i)) { const s = Eg(i); return s && s.default || 0 } return i = qg.has(i) ? i : Vc(i), r.getAttribute(i) } scrapeMotionValuesFromProps(r, i, s) { return zg(r, i, s) } build(r, i, s) { Vg(r, i, this.isSVGTag, s.transformTemplate, s.style) } renderInstance(r, i, s, l) { o2(r, i, s, l) } mount(r) { this.isSVGTag = _g(r.tagName), super.mount(r) } } const a2 = (t, r) => Lc(t) ? new s2(r) : new i2(r, { allowProjection: t !== b.Fragment }); function ei(t, r, i) { const s = t.getProps(); return Dc(s, r, i !== void 0 ? i : s.custom, t) } const Gu = t => Array.isArray(t); function l2(t, r, i) { t.hasValue(r) ? t.getValue(r).set(i) : t.addValue(r, ti(i)) } function u2(t) { return Gu(t) ? t[t.length - 1] || 0 : t } function c2(t, r) { const i = ei(t, r); let { transitionEnd: s = {}, transition: l = {}, ...c } = i || {}; c = { ...c, ...s }; for (const u in c) { const d = u2(c[u]); l2(t, u, d) } } function f2(t) { return !!(ft(t) && t.add) } function Yu(t, r) { const i = t.getValue("willChange"); if (f2(i)) return i.add(r); if (!i && Pn.WillChange) { const s = new Pn.WillChange("auto"); t.addValue("willChange", s), s.add(r) } } function Zg(t) { return t.props[Bg] } const d2 = t => t !== null; function h2(t, { repeat: r, repeatType: i = "loop" }, s) { const l = t.filter(d2), c = r && i !== "loop" && r % 2 === 1 ? 0 : l.length - 1; return l[c] } const p2 = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, m2 = t => ({ type: "spring", stiffness: 550, damping: t === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), g2 = { type: "keyframes", duration: .8 }, y2 = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, v2 = (t, { keyframes: r }) => r.length > 2 ? g2 : ai.has(t) ? t.startsWith("scale") ? m2(r[1]) : p2 : y2; function x2({ when: t, delay: r, delayChildren: i, staggerChildren: s, staggerDirection: l, repeat: c, repeatType: u, repeatDelay: d, from: h, elapsed: m, ...g }) { return !!Object.keys(g).length } const Ic = (t, r, i, s = {}, l, c) => u => { const d = Pc(s, t) || {}, h = d.delay || s.delay || 0; let { elapsed: m = 0 } = s; m = m - an(h); const g = { keyframes: Array.isArray(i) ? i : [null, i], ease: "easeOut", velocity: r.getVelocity(), ...d, delay: -m, onUpdate: w => { r.set(w), d.onUpdate && d.onUpdate(w) }, onComplete: () => { u(), d.onComplete && d.onComplete() }, name: t, motionValue: r, element: c ? void 0 : l }; x2(d) || Object.assign(g, v2(t, g)), g.duration && (g.duration = an(g.duration)), g.repeatDelay && (g.repeatDelay = an(g.repeatDelay)), g.from !== void 0 && (g.keyframes[0] = g.from); let v = !1; if ((g.type === !1 || g.duration === 0 && !g.repeatDelay) && (Bu(g), g.delay === 0 && (v = !0)), (Pn.instantAnimations || Pn.skipAnimations) && (v = !0, Bu(g), g.delay = 0), g.allowFlatten = !d.type && !d.ease, v && !c && r.get() !== void 0) { const w = h2(g.keyframes, d); if (w !== void 0) { Ie.update(() => { g.onUpdate(w), g.onComplete() }); return } } return d.isSync ? new Ec(g) : new WS(g) }; function w2({ protectedKeys: t, needsAnimating: r }, i) { const s = t.hasOwnProperty(i) && r[i] !== !0; return r[i] = !1, s } function Jg(t, r, { delay: i = 0, transitionOverride: s, type: l } = {}) { let { transition: c = t.getDefaultTransition(), transitionEnd: u, ...d } = r; s && (c = s); const h = [], m = l && t.animationState && t.animationState.getState()[l]; for (const g in d) { const v = t.getValue(g, t.latestValues[g] ?? null), w = d[g]; if (w === void 0 || m && w2(m, g)) continue; const k = { delay: i, ...Pc(c || {}, g) }, E = v.get(); if (E !== void 0 && !v.isAnimating && !Array.isArray(w) && w === E && !k.velocity) continue; let N = !1; if (window.MotionHandoffAnimation) { const P = Zg(t); if (P) { const A = window.MotionHandoffAnimation(P, g, Ie); A !== null && (k.startTime = A, N = !0) } } Yu(t, g), v.start(Ic(g, v, w, t.shouldReduceMotion && wg.has(g) ? { type: !1 } : k, t, N)); const C = v.animation; C && h.push(C) } return u && Promise.all(h).then(() => { Ie.update(() => { u && c2(t, u) }) }), h } function ey(t, r, i, s = 0, l = 1) { const c = Array.from(t).sort((m, g) => m.sortNodePosition(g)).indexOf(r), u = t.size, d = (u - 1) * s; return typeof i == "function" ? i(c, u) : l === 1 ? c * s : d - c * s } function Xu(t, r, i = {}) { const s = ei(t, r, i.type === "exit" ? t.presenceContext?.custom : void 0); let { transition: l = t.getDefaultTransition() || {} } = s || {}; i.transitionOverride && (l = i.transitionOverride); const c = s ? () => Promise.all(Jg(t, s, i)) : () => Promise.resolve(), u = t.variantChildren && t.variantChildren.size ? (h = 0) => { const { delayChildren: m = 0, staggerChildren: g, staggerDirection: v } = l; return S2(t, r, h, m, g, v, i) } : () => Promise.resolve(), { when: d } = l; if (d) { const [h, m] = d === "beforeChildren" ? [c, u] : [u, c]; return h().then(() => m()) } else return Promise.all([c(), u(i.delay)]) } function S2(t, r, i = 0, s = 0, l = 0, c = 1, u) { const d = []; for (const h of t.variantChildren) h.notify("AnimationStart", r), d.push(Xu(h, r, { ...u, delay: i + (typeof s == "function" ? 0 : s) + ey(t.variantChildren, h, s, l, c) }).then(() => h.notify("AnimationComplete", r))); return Promise.all(d) } function k2(t, r, i = {}) { t.notify("AnimationStart", r); let s; if (Array.isArray(r)) { const l = r.map(c => Xu(t, c, i)); s = Promise.all(l) } else if (typeof r == "string") s = Xu(t, r, i); else { const l = typeof r == "function" ? ei(t, r, i.custom) : r; s = Promise.all(Jg(t, l, i)) } return s.then(() => { t.notify("AnimationComplete", r) }) } function ty(t, r) { if (!Array.isArray(r)) return !1; const i = r.length; if (i !== t.length) return !1; for (let s = 0; s < i; s++)if (r[s] !== t[s]) return !1; return !0 } const E2 = jc.length; function ny(t) { if (!t) return; if (!t.isControllingVariants) { const i = t.parent ? ny(t.parent) || {} : {}; return t.props.initial !== void 0 && (i.initial = t.props.initial), i } const r = {}; for (let i = 0; i < E2; i++) { const s = jc[i], l = t.props[s]; (vo(l) || l === !1) && (r[s] = l) } return r } const C2 = [...Rc].reverse(), P2 = Rc.length; function T2(t) { return r => Promise.all(r.map(({ animation: i, options: s }) => k2(t, i, s))) } function N2(t) { let r = T2(t), i = vp(), s = !0; const l = h => (m, g) => { const v = ei(t, g, h === "exit" ? t.presenceContext?.custom : void 0); if (v) { const { transition: w, transitionEnd: k, ...E } = v; m = { ...m, ...E, ...k } } return m }; function c(h) { r = h(t) } function u(h) { const { props: m } = t, g = ny(t.parent) || {}, v = [], w = new Set; let k = {}, E = 1 / 0; for (let C = 0; C < P2; C++) { const P = C2[C], A = i[P], L = m[P] !== void 0 ? m[P] : g[P], U = vo(L), O = P === h ? A.isActive : null; O === !1 && (E = C); let H = L === g[P] && L !== m[P] && U; if (H && s && t.manuallyAnimateOnMount && (H = !1), A.protectedKeys = { ...k }, !A.isActive && O === null || !L && !A.prevProp || ma(L) || typeof L == "boolean") continue; const K = b2(A.prevProp, L); let I = K || P === h && A.isActive && !H && U || C > E && U, Q = !1; const le = Array.isArray(L) ? L : [L]; let pe = le.reduce(l(P), {}); O === !1 && (pe = {}); const { prevResolvedValues: Se = {} } = A, Re = { ...Se, ...pe }, je = ae => { I = !0, w.has(ae) && (Q = !0, w.delete(ae)), A.needsAnimating[ae] = !0; const V = t.getValue(ae); V && (V.liveStyle = !1) }; for (const ae in Re) { const V = pe[ae], Y = Se[ae]; if (k.hasOwnProperty(ae)) continue; let G = !1; Gu(V) && Gu(Y) ? G = !ty(V, Y) : G = V !== Y, G ? V != null ? je(ae) : w.add(ae) : V !== void 0 && w.has(ae) ? je(ae) : A.protectedKeys[ae] = !0 } A.prevProp = L, A.prevResolvedValues = pe, A.isActive && (k = { ...k, ...pe }), s && t.blockInitialAnimation && (I = !1); const Te = H && K; I && (!Te || Q) && v.push(...le.map(ae => { const V = { type: P }; if (typeof ae == "string" && s && !Te && t.manuallyAnimateOnMount && t.parent) { const { parent: Y } = t, G = ei(Y, ae); if (Y.enteringChildren && G) { const { delayChildren: j } = G.transition || {}; V.delay = ey(Y.enteringChildren, t, j) } } return { animation: ae, options: V } })) } if (w.size) { const C = {}; if (typeof m.initial != "boolean") { const P = ei(t, Array.isArray(m.initial) ? m.initial[0] : m.initial); P && P.transition && (C.transition = P.transition) } w.forEach(P => { const A = t.getBaseTarget(P), L = t.getValue(P); L && (L.liveStyle = !0), C[P] = A ?? null }), v.push({ animation: C }) } let N = !!v.length; return s && (m.initial === !1 || m.initial === m.animate) && !t.manuallyAnimateOnMount && (N = !1), s = !1, N ? r(v) : Promise.resolve() } function d(h, m) { if (i[h].isActive === m) return Promise.resolve(); t.variantChildren?.forEach(v => v.animationState?.setActive(h, m)), i[h].isActive = m; const g = u(h); for (const v in i) i[v].protectedKeys = {}; return g } return { animateChanges: u, setActive: d, setAnimateFunction: c, getState: () => i, reset: () => { i = vp() } } } function b2(t, r) { return typeof r == "string" ? r !== t : Array.isArray(r) ? !ty(r, t) : !1 } function dr(t = !1) { return { isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function vp() { return { animate: dr(!0), whileInView: dr(), whileHover: dr(), whileTap: dr(), whileDrag: dr(), whileFocus: dr(), exit: dr() } } class Qn { constructor(r) { this.isMounted = !1, this.node = r } update() { } } class R2 extends Qn { constructor(r) { super(r), r.animationState || (r.animationState = N2(r)) } updateAnimationControlsSubscription() { const { animate: r } = this.node.getProps(); ma(r) && (this.unmountControls = r.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: r } = this.node.getProps(), { animate: i } = this.node.prevProps || {}; r !== i && this.updateAnimationControlsSubscription() } unmount() { this.node.animationState.reset(), this.unmountControls?.() } } let j2 = 0; class A2 extends Qn { constructor() { super(...arguments), this.id = j2++ } update() { if (!this.node.presenceContext) return; const { isPresent: r, onExitComplete: i } = this.node.presenceContext, { isPresent: s } = this.node.prevPresenceContext || {}; if (!this.node.animationState || r === s) return; const l = this.node.animationState.setActive("exit", !r); i && !r && l.then(() => { i(this.id) }) } mount() { const { register: r, onExitComplete: i } = this.node.presenceContext || {}; i && i(this.id), r && (this.unmount = r(this.id)) } unmount() { } } const M2 = { animation: { Feature: R2 }, exit: { Feature: A2 } }; function xo(t, r, i, s = { passive: !0 }) { return t.addEventListener(r, i, s), () => t.removeEventListener(r, i) } function Ro(t) { return { point: { x: t.pageX, y: t.pageY } } } const L2 = t => r => bc(r) && t(r, Ro(r)); function co(t, r, i, s) { return xo(t, r, L2(i), s) } const ry = 1e-4, D2 = 1 - ry, F2 = 1 + ry, iy = .01, V2 = 0 - iy, I2 = 0 + iy; function pt(t) { return t.max - t.min } function _2(t, r, i) { return Math.abs(t - r) <= i } function xp(t, r, i, s = .5) { t.origin = s, t.originPoint = ze(r.min, r.max, t.origin), t.scale = pt(i) / pt(r), t.translate = ze(i.min, i.max, t.origin) - t.originPoint, (t.scale >= D2 && t.scale <= F2 || isNaN(t.scale)) && (t.scale = 1), (t.translate >= V2 && t.translate <= I2 || isNaN(t.translate)) && (t.translate = 0) } function fo(t, r, i, s) { xp(t.x, r.x, i.x, s ? s.originX : void 0), xp(t.y, r.y, i.y, s ? s.originY : void 0) } function wp(t, r, i) { t.min = i.min + r.min, t.max = t.min + pt(r) } function O2(t, r, i) { wp(t.x, r.x, i.x), wp(t.y, r.y, i.y) } function Sp(t, r, i) { t.min = r.min - i.min, t.max = t.min + pt(r) } function aa(t, r, i) { Sp(t.x, r.x, i.x), Sp(t.y, r.y, i.y) } function _t(t) { return [t("x"), t("y")] } const oy = ({ current: t }) => t ? t.ownerDocument.defaultView : null, kp = (t, r) => Math.abs(t - r); function z2(t, r) { const i = kp(t.x, r.x), s = kp(t.y, r.y); return Math.sqrt(i ** 2 + s ** 2) } class sy { constructor(r, i, { transformPagePoint: s, contextWindow: l = window, dragSnapToOrigin: c = !1, distanceThreshold: u = 3 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const w = xu(this.lastMoveEventInfo, this.history), k = this.startEvent !== null, E = z2(w.offset, { x: 0, y: 0 }) >= this.distanceThreshold; if (!k && !E) return; const { point: N } = w, { timestamp: C } = st; this.history.push({ ...N, timestamp: C }); const { onStart: P, onMove: A } = this.handlers; k || (P && P(this.lastMoveEvent, w), this.startEvent = this.lastMoveEvent), A && A(this.lastMoveEvent, w) }, this.handlePointerMove = (w, k) => { this.lastMoveEvent = w, this.lastMoveEventInfo = vu(k, this.transformPagePoint), Ie.update(this.updatePoint, !0) }, this.handlePointerUp = (w, k) => { this.end(); const { onEnd: E, onSessionEnd: N, resumeAnimation: C } = this.handlers; if (this.dragSnapToOrigin && C && C(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const P = xu(w.type === "pointercancel" ? this.lastMoveEventInfo : vu(k, this.transformPagePoint), this.history); this.startEvent && E && E(w, P), N && N(w, P) }, !bc(r)) return; this.dragSnapToOrigin = c, this.handlers = i, this.transformPagePoint = s, this.distanceThreshold = u, this.contextWindow = l || window; const d = Ro(r), h = vu(d, this.transformPagePoint), { point: m } = h, { timestamp: g } = st; this.history = [{ ...m, timestamp: g }]; const { onSessionStart: v } = i; v && v(r, xu(h, this.history)), this.removeListeners = To(co(this.contextWindow, "pointermove", this.handlePointerMove), co(this.contextWindow, "pointerup", this.handlePointerUp), co(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(r) { this.handlers = r } end() { this.removeListeners && this.removeListeners(), Yn(this.updatePoint) } } function vu(t, r) { return r ? { point: r(t.point) } : t } function Ep(t, r) { return { x: t.x - r.x, y: t.y - r.y } } function xu({ point: t }, r) { return { point: t, delta: Ep(t, ay(r)), offset: Ep(t, B2(r)), velocity: U2(r, .1) } } function B2(t) { return t[0] } function ay(t) { return t[t.length - 1] } function U2(t, r) { if (t.length < 2) return { x: 0, y: 0 }; let i = t.length - 1, s = null; const l = ay(t); for (; i >= 0 && (s = t[i], !(l.timestamp - s.timestamp > an(r)));)i--; if (!s) return { x: 0, y: 0 }; const c = Ot(l.timestamp - s.timestamp); if (c === 0) return { x: 0, y: 0 }; const u = { x: (l.x - s.x) / c, y: (l.y - s.y) / c }; return u.x === 1 / 0 && (u.x = 0), u.y === 1 / 0 && (u.y = 0), u } function $2(t, { min: r, max: i }, s) { return r !== void 0 && t < r ? t = s ? ze(r, t, s.min) : Math.max(t, r) : i !== void 0 && t > i && (t = s ? ze(i, t, s.max) : Math.min(t, i)), t } function Cp(t, r, i) { return { min: r !== void 0 ? t.min + r : void 0, max: i !== void 0 ? t.max + i - (t.max - t.min) : void 0 } } function W2(t, { top: r, left: i, bottom: s, right: l }) { return { x: Cp(t.x, i, l), y: Cp(t.y, r, s) } } function Pp(t, r) { let i = r.min - t.min, s = r.max - t.max; return r.max - r.min < t.max - t.min && ([i, s] = [s, i]), { min: i, max: s } } function H2(t, r) { return { x: Pp(t.x, r.x), y: Pp(t.y, r.y) } } function K2(t, r) { let i = .5; const s = pt(t), l = pt(r); return l > s ? i = mo(r.min, r.max - s, t.min) : s > l && (i = mo(t.min, t.max - l, r.min)), Cn(0, 1, i) } function G2(t, r) { const i = {}; return r.min !== void 0 && (i.min = r.min - t.min), r.max !== void 0 && (i.max = r.max - t.min), i } const Qu = .35; function Y2(t = Qu) { return t === !1 ? t = 0 : t === !0 && (t = Qu), { x: Tp(t, "left", "right"), y: Tp(t, "top", "bottom") } } function Tp(t, r, i) { return { min: Np(t, r), max: Np(t, i) } } function Np(t, r) { return typeof t == "number" ? t : t[r] || 0 } const X2 = new WeakMap; class Q2 { constructor(r) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Ze(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = r } start(r, { snapToCursor: i = !1, distanceThreshold: s } = {}) { const { presenceContext: l } = this.visualElement; if (l && l.isPresent === !1) return; const c = v => { const { dragSnapToOrigin: w } = this.getProps(); w ? this.pauseAnimation() : this.stopAnimation(), i && this.snapToCursor(Ro(v).point) }, u = (v, w) => { const { drag: k, dragPropagation: E, onDragStart: N } = this.getProps(); if (k && !E && (this.openDragLock && this.openDragLock(), this.openDragLock = ak(k), !this.openDragLock)) return; this.latestPointerEvent = v, this.latestPanInfo = w, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), _t(P => { let A = this.getAxisMotionValue(P).get() || 0; if (ln.test(A)) { const { projection: L } = this.visualElement; if (L && L.layout) { const U = L.layout.layoutBox[P]; U && (A = pt(U) * (parseFloat(A) / 100)) } } this.originPoint[P] = A }), N && Ie.postRender(() => N(v, w)), Yu(this.visualElement, "transform"); const { animationState: C } = this.visualElement; C && C.setActive("whileDrag", !0) }, d = (v, w) => { this.latestPointerEvent = v, this.latestPanInfo = w; const { dragPropagation: k, dragDirectionLock: E, onDirectionLock: N, onDrag: C } = this.getProps(); if (!k && !this.openDragLock) return; const { offset: P } = w; if (E && this.currentDirection === null) { this.currentDirection = q2(P), this.currentDirection !== null && N && N(this.currentDirection); return } this.updateAxis("x", w.point, P), this.updateAxis("y", w.point, P), this.visualElement.render(), C && C(v, w) }, h = (v, w) => { this.latestPointerEvent = v, this.latestPanInfo = w, this.stop(v, w), this.latestPointerEvent = null, this.latestPanInfo = null }, m = () => _t(v => this.getAnimationState(v) === "paused" && this.getAxisMotionValue(v).animation?.play()), { dragSnapToOrigin: g } = this.getProps(); this.panSession = new sy(r, { onSessionStart: c, onStart: u, onMove: d, onSessionEnd: h, resumeAnimation: m }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: g, distanceThreshold: s, contextWindow: oy(this.visualElement) }) } stop(r, i) { const s = r || this.latestPointerEvent, l = i || this.latestPanInfo, c = this.isDragging; if (this.cancel(), !c || !l || !s) return; const { velocity: u } = l; this.startAnimation(u); const { onDragEnd: d } = this.getProps(); d && Ie.postRender(() => d(s, l)) } cancel() { this.isDragging = !1; const { projection: r, animationState: i } = this.visualElement; r && (r.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: s } = this.getProps(); !s && this.openDragLock && (this.openDragLock(), this.openDragLock = null), i && i.setActive("whileDrag", !1) } updateAxis(r, i, s) { const { drag: l } = this.getProps(); if (!s || !Ks(r, l, this.currentDirection)) return; const c = this.getAxisMotionValue(r); let u = this.originPoint[r] + s[r]; this.constraints && this.constraints[r] && (u = $2(u, this.constraints[r], this.elastic[r])), c.set(u) } resolveConstraints() { const { dragConstraints: r, dragElastic: i } = this.getProps(), s = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, l = this.constraints; r && Qr(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && s ? this.constraints = W2(s.layoutBox, r) : this.constraints = !1, this.elastic = Y2(i), l !== this.constraints && s && this.constraints && !this.hasMutatedConstraints && _t(c => { this.constraints !== !1 && this.getAxisMotionValue(c) && (this.constraints[c] = G2(s.layoutBox[c], this.constraints[c])) }) } resolveRefConstraints() { const { dragConstraints: r, onMeasureDragConstraints: i } = this.getProps(); if (!r || !Qr(r)) return !1; const s = r.current, { projection: l } = this.visualElement; if (!l || !l.layout) return !1; const c = Zk(s, l.root, this.visualElement.getTransformPagePoint()); let u = H2(l.layout.layoutBox, c); if (i) { const d = i(Xk(u)); this.hasMutatedConstraints = !!d, d && (u = Wg(d)) } return u } startAnimation(r) { const { drag: i, dragMomentum: s, dragElastic: l, dragTransition: c, dragSnapToOrigin: u, onDragTransitionEnd: d } = this.getProps(), h = this.constraints || {}, m = _t(g => { if (!Ks(g, i, this.currentDirection)) return; let v = h && h[g] || {}; u && (v = { min: 0, max: 0 }); const w = l ? 200 : 1e6, k = l ? 40 : 1e7, E = { type: "inertia", velocity: s ? r[g] : 0, bounceStiffness: w, bounceDamping: k, timeConstant: 750, restDelta: 1, restSpeed: 10, ...c, ...v }; return this.startAxisValueAnimation(g, E) }); return Promise.all(m).then(d) } startAxisValueAnimation(r, i) { const s = this.getAxisMotionValue(r); return Yu(this.visualElement, r), s.start(Ic(r, s, 0, i, this.visualElement, !1)) } stopAnimation() { _t(r => this.getAxisMotionValue(r).stop()) } pauseAnimation() { _t(r => this.getAxisMotionValue(r).animation?.pause()) } getAnimationState(r) { return this.getAxisMotionValue(r).animation?.state } getAxisMotionValue(r) { const i = `_drag${r.toUpperCase()}`, s = this.visualElement.getProps(), l = s[i]; return l || this.visualElement.getValue(r, (s.initial ? s.initial[r] : void 0) || 0) } snapToCursor(r) { _t(i => { const { drag: s } = this.getProps(); if (!Ks(i, s, this.currentDirection)) return; const { projection: l } = this.visualElement, c = this.getAxisMotionValue(i); if (l && l.layout) { const { min: u, max: d } = l.layout.layoutBox[i]; c.set(r[i] - ze(u, d, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: r, dragConstraints: i } = this.getProps(), { projection: s } = this.visualElement; if (!Qr(i) || !s || !this.constraints) return; this.stopAnimation(); const l = { x: 0, y: 0 }; _t(u => { const d = this.getAxisMotionValue(u); if (d && this.constraints !== !1) { const h = d.get(); l[u] = K2({ min: h, max: h }, this.constraints[u]) } }); const { transformTemplate: c } = this.visualElement.getProps(); this.visualElement.current.style.transform = c ? c({}, "") : "none", s.root && s.root.updateScroll(), s.updateLayout(), this.resolveConstraints(), _t(u => { if (!Ks(u, r, null)) return; const d = this.getAxisMotionValue(u), { min: h, max: m } = this.constraints[u]; d.set(ze(h, m, l[u])) }) } addListeners() { if (!this.visualElement.current) return; X2.set(this.visualElement, this); const r = this.visualElement.current, i = co(r, "pointerdown", h => { const { drag: m, dragListener: g = !0 } = this.getProps(); m && g && this.start(h) }), s = () => { const { dragConstraints: h } = this.getProps(); Qr(h) && h.current && (this.constraints = this.resolveRefConstraints()) }, { projection: l } = this.visualElement, c = l.addEventListener("measure", s); l && !l.layout && (l.root && l.root.updateScroll(), l.updateLayout()), Ie.read(s); const u = xo(window, "resize", () => this.scalePositionWithinConstraints()), d = l.addEventListener("didUpdate", (({ delta: h, hasLayoutChanged: m }) => { this.isDragging && m && (_t(g => { const v = this.getAxisMotionValue(g); v && (this.originPoint[g] += h[g].translate, v.set(v.get() + h[g].translate)) }), this.visualElement.render()) })); return () => { u(), i(), c(), d && d() } } getProps() { const r = this.visualElement.getProps(), { drag: i = !1, dragDirectionLock: s = !1, dragPropagation: l = !1, dragConstraints: c = !1, dragElastic: u = Qu, dragMomentum: d = !0 } = r; return { ...r, drag: i, dragDirectionLock: s, dragPropagation: l, dragConstraints: c, dragElastic: u, dragMomentum: d } } } function Ks(t, r, i) { return (r === !0 || r === t) && (i === null || i === t) } function q2(t, r = 10) { let i = null; return Math.abs(t.y) > r ? i = "y" : Math.abs(t.x) > r && (i = "x"), i } class Z2 extends Qn { constructor(r) { super(r), this.removeGroupControls = zt, this.removeListeners = zt, this.controls = new Q2(r) } mount() { const { dragControls: r } = this.node.getProps(); r && (this.removeGroupControls = r.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || zt } unmount() { this.removeGroupControls(), this.removeListeners() } } const bp = t => (r, i) => { t && Ie.postRender(() => t(r, i)) }; class J2 extends Qn { constructor() { super(...arguments), this.removePointerDownListener = zt } onPointerDown(r) { this.session = new sy(r, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: oy(this.node) }) } createPanHandlers() { const { onPanSessionStart: r, onPanStart: i, onPan: s, onPanEnd: l } = this.node.getProps(); return { onSessionStart: bp(r), onStart: bp(i), onMove: s, onEnd: (c, u) => { delete this.session, l && Ie.postRender(() => l(c, u)) } } } mount() { this.removePointerDownListener = co(this.node.current, "pointerdown", r => this.onPointerDown(r)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const ea = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; let wu = !1; class eE extends b.Component { componentDidMount() { const { visualElement: r, layoutGroup: i, switchLayoutGroup: s, layoutId: l } = this.props, { projection: c } = r; c && (i.group && i.group.add(c), s && s.register && l && s.register(c), wu && c.root.didUpdate(), c.addEventListener("animationComplete", () => { this.safeToRemove() }), c.setOptions({ ...c.options, onExitComplete: () => this.safeToRemove() })), ea.hasEverUpdated = !0 } getSnapshotBeforeUpdate(r) { const { layoutDependency: i, visualElement: s, drag: l, isPresent: c } = this.props, { projection: u } = s; return u && (u.isPresent = c, wu = !0, l || r.layoutDependency !== i || i === void 0 || r.isPresent !== c ? u.willUpdate() : this.safeToRemove(), r.isPresent !== c && (c ? u.promote() : u.relegate() || Ie.postRender(() => { const d = u.getStack(); (!d || !d.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: r } = this.props.visualElement; r && (r.root.didUpdate(), Nc.postRender(() => { !r.currentAnimation && r.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: r, layoutGroup: i, switchLayoutGroup: s } = this.props, { projection: l } = r; wu = !0, l && (l.scheduleCheckAfterUnmount(), i && i.group && i.group.remove(l), s && s.deregister && s.deregister(l)) } safeToRemove() { const { safeToRemove: r } = this.props; r && r() } render() { return null } } function ly(t) { const [r, i] = gk(), s = b.useContext(Om); return x.jsx(eE, { ...t, layoutGroup: s, switchLayoutGroup: b.useContext(Ug), isPresent: r, safeToRemove: i }) } function tE(t, r, i) { const s = ft(t) ? t : ti(t); return s.start(Ic("", s, r, i)), s.animation } const nE = (t, r) => t.depth - r.depth; class rE { constructor() { this.children = [], this.isDirty = !1 } add(r) { uc(this.children, r), this.isDirty = !0 } remove(r) { cc(this.children, r), this.isDirty = !0 } forEach(r) { this.isDirty && this.children.sort(nE), this.isDirty = !1, this.children.forEach(r) } } function iE(t, r) { const i = St.now(), s = ({ timestamp: l }) => { const c = l - i; c >= r && (Yn(s), t(c - r)) }; return Ie.setup(s, !0), () => Yn(s) } const uy = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], oE = uy.length, Rp = t => typeof t == "string" ? parseFloat(t) : t, jp = t => typeof t == "number" || de.test(t); function sE(t, r, i, s, l, c) { l ? (t.opacity = ze(0, i.opacity ?? 1, aE(s)), t.opacityExit = ze(r.opacity ?? 1, 0, lE(s))) : c && (t.opacity = ze(r.opacity ?? 1, i.opacity ?? 1, s)); for (let u = 0; u < oE; u++) { const d = `border${uy[u]}Radius`; let h = Ap(r, d), m = Ap(i, d); if (h === void 0 && m === void 0) continue; h || (h = 0), m || (m = 0), h === 0 || m === 0 || jp(h) === jp(m) ? (t[d] = Math.max(ze(Rp(h), Rp(m), s), 0), (ln.test(m) || ln.test(h)) && (t[d] += "%")) : t[d] = m } (r.rotate || i.rotate) && (t.rotate = ze(r.rotate || 0, i.rotate || 0, s)) } function Ap(t, r) { return t[r] !== void 0 ? t[r] : t.borderRadius } const aE = cy(0, .5, Qm), lE = cy(.5, .95, zt); function cy(t, r, i) { return s => s < t ? 0 : s > r ? 1 : i(mo(t, r, s)) } function Mp(t, r) { t.min = r.min, t.max = r.max } function Xt(t, r) { Mp(t.x, r.x), Mp(t.y, r.y) } function Lp(t, r) { t.translate = r.translate, t.scale = r.scale, t.originPoint = r.originPoint, t.origin = r.origin } function Dp(t, r, i, s, l) { return t -= r, t = sa(t, 1 / i, s), l !== void 0 && (t = sa(t, 1 / l, s)), t } function uE(t, r = 0, i = 1, s = .5, l, c = t, u = t) { if (ln.test(r) && (r = parseFloat(r), r = ze(u.min, u.max, r / 100) - u.min), typeof r != "number") return; let d = ze(c.min, c.max, s); t === c && (d -= r), t.min = Dp(t.min, r, i, d, l), t.max = Dp(t.max, r, i, d, l) } function Fp(t, r, [i, s, l], c, u) { uE(t, r[i], r[s], r[l], r.scale, c, u) } const cE = ["x", "scaleX", "originX"], fE = ["y", "scaleY", "originY"]; function Vp(t, r, i, s) { Fp(t.x, r, cE, i ? i.x : void 0, s ? s.x : void 0), Fp(t.y, r, fE, i ? i.y : void 0, s ? s.y : void 0) } function Ip(t) { return t.translate === 0 && t.scale === 1 } function fy(t) { return Ip(t.x) && Ip(t.y) } function _p(t, r) { return t.min === r.min && t.max === r.max } function dE(t, r) { return _p(t.x, r.x) && _p(t.y, r.y) } function Op(t, r) { return Math.round(t.min) === Math.round(r.min) && Math.round(t.max) === Math.round(r.max) } function dy(t, r) { return Op(t.x, r.x) && Op(t.y, r.y) } function zp(t) { return pt(t.x) / pt(t.y) } function Bp(t, r) { return t.translate === r.translate && t.scale === r.scale && t.originPoint === r.originPoint } class hE { constructor() { this.members = [] } add(r) { uc(this.members, r), r.scheduleRender() } remove(r) { if (cc(this.members, r), r === this.prevLead && (this.prevLead = void 0), r === this.lead) { const i = this.members[this.members.length - 1]; i && this.promote(i) } } relegate(r) { const i = this.members.findIndex(l => r === l); if (i === 0) return !1; let s; for (let l = i; l >= 0; l--) { const c = this.members[l]; if (c.isPresent !== !1) { s = c; break } } return s ? (this.promote(s), !0) : !1 } promote(r, i) { const s = this.lead; if (r !== s && (this.prevLead = s, this.lead = r, r.show(), s)) { s.instance && s.scheduleRender(), r.scheduleRender(), r.resumeFrom = s, i && (r.resumeFrom.preserveOpacity = !0), s.snapshot && (r.snapshot = s.snapshot, r.snapshot.latestValues = s.animationValues || s.latestValues), r.root && r.root.isUpdating && (r.isLayoutDirty = !0); const { crossfade: l } = r.options; l === !1 && s.hide() } } exitAnimationComplete() { this.members.forEach(r => { const { options: i, resumingFrom: s } = r; i.onExitComplete && i.onExitComplete(), s && s.options.onExitComplete && s.options.onExitComplete() }) } scheduleRender() { this.members.forEach(r => { r.instance && r.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function pE(t, r, i) { let s = ""; const l = t.x.translate / r.x, c = t.y.translate / r.y, u = i?.z || 0; if ((l || c || u) && (s = `translate3d(${l}px, ${c}px, ${u}px) `), (r.x !== 1 || r.y !== 1) && (s += `scale(${1 / r.x}, ${1 / r.y}) `), i) { const { transformPerspective: m, rotate: g, rotateX: v, rotateY: w, skewX: k, skewY: E } = i; m && (s = `perspective(${m}px) ${s}`), g && (s += `rotate(${g}deg) `), v && (s += `rotateX(${v}deg) `), w && (s += `rotateY(${w}deg) `), k && (s += `skewX(${k}deg) `), E && (s += `skewY(${E}deg) `) } const d = t.x.scale * r.x, h = t.y.scale * r.y; return (d !== 1 || h !== 1) && (s += `scale(${d}, ${h})`), s || "none" } const Su = ["", "X", "Y", "Z"], mE = 1e3; let gE = 0; function ku(t, r, i, s) { const { latestValues: l } = r; l[t] && (i[t] = l[t], r.setStaticValue(t, 0), s && (s[t] = 0)) } function hy(t) { if (t.hasCheckedOptimisedAppear = !0, t.root === t) return; const { visualElement: r } = t.options; if (!r) return; const i = Zg(r); if (window.MotionHasOptimisedAnimation(i, "transform")) { const { layout: l, layoutId: c } = t.options; window.MotionCancelOptimisedAnimation(i, "transform", Ie, !(l || c)) } const { parent: s } = t; s && !s.hasCheckedOptimisedAppear && hy(s) } function py({ attachResizeListener: t, defaultParent: r, measureScroll: i, checkIsScrollRoot: s, resetTransform: l }) { return class { constructor(u = {}, d = r?.()) { this.id = gE++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(xE), this.nodes.forEach(EE), this.nodes.forEach(CE), this.nodes.forEach(wE) }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = u, this.root = d ? d.root || d : this, this.path = d ? [...d.path, d] : [], this.parent = d, this.depth = d ? d.depth + 1 : 0; for (let h = 0; h < this.path.length; h++)this.path[h].shouldResetTransform = !0; this.root === this && (this.nodes = new rE) } addEventListener(u, d) { return this.eventHandlers.has(u) || this.eventHandlers.set(u, new hc), this.eventHandlers.get(u).add(d) } notifyListeners(u, ...d) { const h = this.eventHandlers.get(u); h && h.notify(...d) } hasListeners(u) { return this.eventHandlers.has(u) } mount(u) { if (this.instance) return; this.isSVG = Rg(u) && !hk(u), this.instance = u; const { layoutId: d, layout: h, visualElement: m } = this.options; if (m && !m.current && m.mount(u), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (h || d) && (this.isLayoutDirty = !0), t) { let g, v = 0; const w = () => this.root.updateBlockedByResize = !1; Ie.read(() => { v = window.innerWidth }), t(u, () => { const k = window.innerWidth; k !== v && (v = k, this.root.updateBlockedByResize = !0, g && g(), g = iE(w, 250), ea.hasAnimatedSinceResize && (ea.hasAnimatedSinceResize = !1, this.nodes.forEach(Wp))) }) } d && this.root.registerSharedNode(d, this), this.options.animate !== !1 && m && (d || h) && this.addEventListener("didUpdate", ({ delta: g, hasLayoutChanged: v, hasRelativeLayoutChanged: w, layout: k }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const E = this.options.transition || m.getDefaultTransition() || RE, { onLayoutAnimationStart: N, onLayoutAnimationComplete: C } = m.getProps(), P = !this.targetLayout || !dy(this.targetLayout, k), A = !v && w; if (this.options.layoutRoot || this.resumeFrom || A || v && (P || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0); const L = { ...Pc(E, "layout"), onPlay: N, onComplete: C }; (m.shouldReduceMotion || this.options.layoutRoot) && (L.delay = 0, L.type = !1), this.startAnimation(L), this.setAnimationOrigin(g, A) } else v || Wp(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = k }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const u = this.getStack(); u && u.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), Yn(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(PE), this.animationId++) } getTransformTemplate() { const { visualElement: u } = this.options; return u && u.getProps().transformTemplate } willUpdate(u = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && hy(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let g = 0; g < this.path.length; g++) { const v = this.path[g]; v.shouldResetTransform = !0, v.updateScroll("snapshot"), v.options.layoutRoot && v.willUpdate(!1) } const { layoutId: d, layout: h } = this.options; if (d === void 0 && !h) return; const m = this.getTransformTemplate(); this.prevTransformTemplateValue = m ? m(this.latestValues, "") : void 0, this.updateSnapshot(), u && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Up); return } if (this.animationId <= this.animationCommitId) { this.nodes.forEach($p); return } this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(kE), this.nodes.forEach(yE), this.nodes.forEach(vE)) : this.nodes.forEach($p), this.clearAllSnapshots(); const d = St.now(); st.delta = Cn(0, 1e3 / 60, d - st.timestamp), st.timestamp = d, st.isProcessing = !0, cu.update.process(st), cu.preRender.process(st), cu.render.process(st), st.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Nc.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(SE), this.sharedNodes.forEach(TE) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Ie.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Ie.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !pt(this.snapshot.measuredBox.x) && !pt(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let h = 0; h < this.path.length; h++)this.path[h].updateScroll(); const u = this.layout; this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = Ze(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: d } = this.options; d && d.notify("LayoutMeasure", this.layout.layoutBox, u ? u.layoutBox : void 0) } updateScroll(u = "measure") { let d = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === u && (d = !1), d && this.instance) { const h = s(this.instance); this.scroll = { animationId: this.root.animationId, phase: u, isRoot: h, offset: i(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : h } } } resetTransform() { if (!l) return; const u = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, d = this.projectionDelta && !fy(this.projectionDelta), h = this.getTransformTemplate(), m = h ? h(this.latestValues, "") : void 0, g = m !== this.prevTransformTemplateValue; u && this.instance && (d || mr(this.latestValues) || g) && (l(this.instance, m), this.shouldResetTransform = !1, this.scheduleRender()) } measure(u = !0) { const d = this.measurePageBox(); let h = this.removeElementScroll(d); return u && (h = this.removeTransform(h)), jE(h), { animationId: this.root.animationId, measuredBox: d, layoutBox: h, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: u } = this.options; if (!u) return Ze(); const d = u.measureViewportBox(); if (!(this.scroll?.wasRoot || this.path.some(AE))) { const { scroll: m } = this.root; m && (qr(d.x, m.offset.x), qr(d.y, m.offset.y)) } return d } removeElementScroll(u) { const d = Ze(); if (Xt(d, u), this.scroll?.wasRoot) return d; for (let h = 0; h < this.path.length; h++) { const m = this.path[h], { scroll: g, options: v } = m; m !== this.root && g && v.layoutScroll && (g.wasRoot && Xt(d, u), qr(d.x, g.offset.x), qr(d.y, g.offset.y)) } return d } applyTransform(u, d = !1) { const h = Ze(); Xt(h, u); for (let m = 0; m < this.path.length; m++) { const g = this.path[m]; !d && g.options.layoutScroll && g.scroll && g !== g.root && Zr(h, { x: -g.scroll.offset.x, y: -g.scroll.offset.y }), mr(g.latestValues) && Zr(h, g.latestValues) } return mr(this.latestValues) && Zr(h, this.latestValues), h } removeTransform(u) { const d = Ze(); Xt(d, u); for (let h = 0; h < this.path.length; h++) { const m = this.path[h]; if (!m.instance || !mr(m.latestValues)) continue; Wu(m.latestValues) && m.updateSnapshot(); const g = Ze(), v = m.measurePageBox(); Xt(g, v), Vp(d, m.latestValues, m.snapshot ? m.snapshot.layoutBox : void 0, g) } return mr(this.latestValues) && Vp(d, this.latestValues), d } setTargetDelta(u) { this.targetDelta = u, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(u) { this.options = { ...this.options, ...u, crossfade: u.crossfade !== void 0 ? u.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== st.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(u = !1) { const d = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = d.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = d.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = d.isSharedProjectionDirty); const h = !!this.resumingFrom || this !== d; if (!(u || h && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: g, layoutId: v } = this.options; if (!this.layout || !(g || v)) return; this.resolvedRelativeTargetAt = st.timestamp; const w = this.getClosestProjectingParent(); w && this.linkedParentVersion !== w.layoutVersion && !w.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (w && w.layout ? this.createRelativeTarget(w, this.layout.layoutBox, w.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Ze(), this.targetWithTransforms = Ze()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), O2(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Xt(this.target, this.layout.layoutBox), Kg(this.target, this.targetDelta)) : Xt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, w && !!w.resumingFrom == !!this.resumingFrom && !w.options.layoutScroll && w.target && this.animationProgress !== 1 ? this.createRelativeTarget(w, this.target, w.target) : this.relativeParent = this.relativeTarget = void 0)) } getClosestProjectingParent() { if (!(!this.parent || Wu(this.parent.latestValues) || Hg(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } createRelativeTarget(u, d, h) { this.relativeParent = u, this.linkedParentVersion = u.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Ze(), this.relativeTargetOrigin = Ze(), aa(this.relativeTargetOrigin, d, h), Xt(this.relativeTarget, this.relativeTargetOrigin) } removeRelativeTarget() { this.relativeParent = this.relativeTarget = void 0 } calcProjection() { const u = this.getLead(), d = !!this.resumingFrom || this !== u; let h = !0; if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (h = !1), d && (this.isSharedProjectionDirty || this.isTransformDirty) && (h = !1), this.resolvedRelativeTargetAt === st.timestamp && (h = !1), h) return; const { layout: m, layoutId: g } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(m || g)) return; Xt(this.layoutCorrected, this.layout.layoutBox); const v = this.treeScale.x, w = this.treeScale.y; qk(this.layoutCorrected, this.treeScale, this.path, d), u.layout && !u.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (u.target = u.layout.layoutBox, u.targetWithTransforms = Ze()); const { target: k } = u; if (!k) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Lp(this.prevProjectionDelta.x, this.projectionDelta.x), Lp(this.prevProjectionDelta.y, this.projectionDelta.y)), fo(this.projectionDelta, this.layoutCorrected, k, this.latestValues), (this.treeScale.x !== v || this.treeScale.y !== w || !Bp(this.projectionDelta.x, this.prevProjectionDelta.x) || !Bp(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", k)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(u = !0) { if (this.options.visualElement?.scheduleRender(), u) { const d = this.getStack(); d && d.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = Jr(), this.projectionDelta = Jr(), this.projectionDeltaWithTransform = Jr() } setAnimationOrigin(u, d = !1) { const h = this.snapshot, m = h ? h.latestValues : {}, g = { ...this.latestValues }, v = Jr(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !d; const w = Ze(), k = h ? h.source : void 0, E = this.layout ? this.layout.source : void 0, N = k !== E, C = this.getStack(), P = !C || C.members.length <= 1, A = !!(N && !P && this.options.crossfade === !0 && !this.path.some(bE)); this.animationProgress = 0; let L; this.mixTargetDelta = U => { const O = U / 1e3; Hp(v.x, u.x, O), Hp(v.y, u.y, O), this.setTargetDelta(v), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (aa(w, this.layout.layoutBox, this.relativeParent.layout.layoutBox), NE(this.relativeTarget, this.relativeTargetOrigin, w, O), L && dE(this.relativeTarget, L) && (this.isProjectionDirty = !1), L || (L = Ze()), Xt(L, this.relativeTarget)), N && (this.animationValues = g, sE(g, m, this.latestValues, O, A, P)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = O }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(u) { this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (Yn(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Ie.update(() => { ea.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = ti(0)), this.currentAnimation = tE(this.motionValue, [0, 1e3], { ...u, velocity: 0, isSync: !0, onUpdate: d => { this.mixTargetDelta(d), u.onUpdate && u.onUpdate(d) }, onStop: () => { }, onComplete: () => { u.onComplete && u.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const u = this.getStack(); u && u.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(mE), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const u = this.getLead(); let { targetWithTransforms: d, target: h, layout: m, latestValues: g } = u; if (!(!d || !h || !m)) { if (this !== u && this.layout && m && my(this.options.animationType, this.layout.layoutBox, m.layoutBox)) { h = this.target || Ze(); const v = pt(this.layout.layoutBox.x); h.x.min = u.target.x.min, h.x.max = h.x.min + v; const w = pt(this.layout.layoutBox.y); h.y.min = u.target.y.min, h.y.max = h.y.min + w } Xt(d, h), Zr(d, g), fo(this.projectionDeltaWithTransform, this.layoutCorrected, d, g) } } registerSharedNode(u, d) { this.sharedNodes.has(u) || this.sharedNodes.set(u, new hE), this.sharedNodes.get(u).add(d); const m = d.options.initialPromotionConfig; d.promote({ transition: m ? m.transition : void 0, preserveFollowOpacity: m && m.shouldPreserveFollowOpacity ? m.shouldPreserveFollowOpacity(d) : void 0 }) } isLead() { const u = this.getStack(); return u ? u.lead === this : !0 } getLead() { const { layoutId: u } = this.options; return u ? this.getStack()?.lead || this : this } getPrevLead() { const { layoutId: u } = this.options; return u ? this.getStack()?.prevLead : void 0 } getStack() { const { layoutId: u } = this.options; if (u) return this.root.sharedNodes.get(u) } promote({ needsReset: u, transition: d, preserveFollowOpacity: h } = {}) { const m = this.getStack(); m && m.promote(this, h), u && (this.projectionDelta = void 0, this.needsReset = !0), d && this.setOptions({ transition: d }) } relegate() { const u = this.getStack(); return u ? u.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: u } = this.options; if (!u) return; let d = !1; const { latestValues: h } = u; if ((h.z || h.rotate || h.rotateX || h.rotateY || h.rotateZ || h.skewX || h.skewY) && (d = !0), !d) return; const m = {}; h.z && ku("z", u, m, this.animationValues); for (let g = 0; g < Su.length; g++)ku(`rotate${Su[g]}`, u, m, this.animationValues), ku(`skew${Su[g]}`, u, m, this.animationValues); u.render(); for (const g in m) u.setStaticValue(g, m[g]), this.animationValues && (this.animationValues[g] = m[g]); u.scheduleRender() } applyProjectionStyles(u, d) { if (!this.instance || this.isSVG) return; if (!this.isVisible) { u.visibility = "hidden"; return } const h = this.getTransformTemplate(); if (this.needsReset) { this.needsReset = !1, u.visibility = "", u.opacity = "", u.pointerEvents = Js(d?.pointerEvents) || "", u.transform = h ? h(this.latestValues, "") : "none"; return } const m = this.getLead(); if (!this.projectionDelta || !this.layout || !m.target) { this.options.layoutId && (u.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, u.pointerEvents = Js(d?.pointerEvents) || ""), this.hasProjected && !mr(this.latestValues) && (u.transform = h ? h({}, "") : "none", this.hasProjected = !1); return } u.visibility = ""; const g = m.animationValues || m.latestValues; this.applyTransformsToTarget(); let v = pE(this.projectionDeltaWithTransform, this.treeScale, g); h && (v = h(g, v)), u.transform = v; const { x: w, y: k } = this.projectionDelta; u.transformOrigin = `${w.origin * 100}% ${k.origin * 100}% 0`, m.animationValues ? u.opacity = m === this ? g.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : g.opacityExit : u.opacity = m === this ? g.opacity !== void 0 ? g.opacity : "" : g.opacityExit !== void 0 ? g.opacityExit : 0; for (const E in $u) { if (g[E] === void 0) continue; const { correct: N, applyTo: C, isCSSVariable: P } = $u[E], A = v === "none" ? g[E] : N(g[E], m); if (C) { const L = C.length; for (let U = 0; U < L; U++)u[C[U]] = A } else P ? this.options.visualElement.renderState.vars[E] = A : u[E] = A } this.options.layoutId && (u.pointerEvents = m === this ? Js(d?.pointerEvents) || "" : "none") } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(u => u.currentAnimation?.stop()), this.root.nodes.forEach(Up), this.root.sharedNodes.clear() } } } function yE(t) { t.updateLayout() } function vE(t) { const r = t.resumeFrom?.snapshot || t.snapshot; if (t.isLead() && t.layout && r && t.hasListeners("didUpdate")) { const { layoutBox: i, measuredBox: s } = t.layout, { animationType: l } = t.options, c = r.source !== t.layout.source; l === "size" ? _t(g => { const v = c ? r.measuredBox[g] : r.layoutBox[g], w = pt(v); v.min = i[g].min, v.max = v.min + w }) : my(l, r.layoutBox, i) && _t(g => { const v = c ? r.measuredBox[g] : r.layoutBox[g], w = pt(i[g]); v.max = v.min + w, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[g].max = t.relativeTarget[g].min + w) }); const u = Jr(); fo(u, i, r.layoutBox); const d = Jr(); c ? fo(d, t.applyTransform(s, !0), r.measuredBox) : fo(d, i, r.layoutBox); const h = !fy(u); let m = !1; if (!t.resumeFrom) { const g = t.getClosestProjectingParent(); if (g && !g.resumeFrom) { const { snapshot: v, layout: w } = g; if (v && w) { const k = Ze(); aa(k, r.layoutBox, v.layoutBox); const E = Ze(); aa(E, i, w.layoutBox), dy(k, E) || (m = !0), g.options.layoutRoot && (t.relativeTarget = E, t.relativeTargetOrigin = k, t.relativeParent = g) } } } t.notifyListeners("didUpdate", { layout: i, snapshot: r, delta: d, layoutDelta: u, hasLayoutChanged: h, hasRelativeLayoutChanged: m }) } else if (t.isLead()) { const { onExitComplete: i } = t.options; i && i() } t.options.transition = void 0 } function xE(t) { t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty)) } function wE(t) { t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1 } function SE(t) { t.clearSnapshot() } function Up(t) { t.clearMeasurements() } function $p(t) { t.isLayoutDirty = !1 } function kE(t) { const { visualElement: r } = t.options; r && r.getProps().onBeforeLayoutMeasure && r.notify("BeforeLayoutMeasure"), t.resetTransform() } function Wp(t) { t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0 } function EE(t) { t.resolveTargetDelta() } function CE(t) { t.calcProjection() } function PE(t) { t.resetSkewAndRotation() } function TE(t) { t.removeLeadSnapshot() } function Hp(t, r, i) { t.translate = ze(r.translate, 0, i), t.scale = ze(r.scale, 1, i), t.origin = r.origin, t.originPoint = r.originPoint } function Kp(t, r, i, s) { t.min = ze(r.min, i.min, s), t.max = ze(r.max, i.max, s) } function NE(t, r, i, s) { Kp(t.x, r.x, i.x, s), Kp(t.y, r.y, i.y, s) } function bE(t) { return t.animationValues && t.animationValues.opacityExit !== void 0 } const RE = { duration: .45, ease: [.4, 0, .1, 1] }, Gp = t => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), Yp = Gp("applewebkit/") && !Gp("chrome/") ? Math.round : zt; function Xp(t) { t.min = Yp(t.min), t.max = Yp(t.max) } function jE(t) { Xp(t.x), Xp(t.y) } function my(t, r, i) { return t === "position" || t === "preserve-aspect" && !_2(zp(r), zp(i), .2) } function AE(t) { return t !== t.root && t.scroll?.wasRoot } const ME = py({ attachResizeListener: (t, r) => xo(t, "resize", r), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Eu = { current: void 0 }, gy = py({ measureScroll: t => ({ x: t.scrollLeft, y: t.scrollTop }), defaultParent: () => { if (!Eu.current) { const t = new ME({}); t.mount(window), t.setOptions({ layoutScroll: !0 }), Eu.current = t } return Eu.current }, resetTransform: (t, r) => { t.style.transform = r !== void 0 ? r : "none" }, checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed" }), LE = { pan: { Feature: J2 }, drag: { Feature: Z2, ProjectionNode: gy, MeasureLayout: ly } }; function Qp(t, r, i) { const { props: s } = t; t.animationState && s.whileHover && t.animationState.setActive("whileHover", i === "Start"); const l = "onHover" + i, c = s[l]; c && Ie.postRender(() => c(r, Ro(r))) } class DE extends Qn { mount() { const { current: r } = this.node; r && (this.unmount = lk(r, (i, s) => (Qp(this.node, s, "Start"), l => Qp(this.node, l, "End")))) } unmount() { } } class FE extends Qn { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let r = !1; try { r = this.node.current.matches(":focus-visible") } catch { r = !0 } !r || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = To(xo(this.node.current, "focus", () => this.onFocus()), xo(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function qp(t, r, i) { const { props: s } = t; if (t.current instanceof HTMLButtonElement && t.current.disabled) return; t.animationState && s.whileTap && t.animationState.setActive("whileTap", i === "Start"); const l = "onTap" + (i === "End" ? "" : i), c = s[l]; c && Ie.postRender(() => c(r, Ro(r))) } class VE extends Qn { mount() { const { current: r } = this.node; r && (this.unmount = dk(r, (i, s) => (qp(this.node, s, "Start"), (l, { success: c }) => qp(this.node, l, c ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } const qu = new WeakMap, Cu = new WeakMap, IE = t => { const r = qu.get(t.target); r && r(t) }, _E = t => { t.forEach(IE) }; function OE({ root: t, ...r }) { const i = t || document; Cu.has(i) || Cu.set(i, {}); const s = Cu.get(i), l = JSON.stringify(r); return s[l] || (s[l] = new IntersectionObserver(_E, { root: t, ...r })), s[l] } function zE(t, r, i) { const s = OE(r); return qu.set(t, i), s.observe(t), () => { qu.delete(t), s.unobserve(t) } } const BE = { some: 0, all: 1 }; class UE extends Qn { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: r = {} } = this.node.getProps(), { root: i, margin: s, amount: l = "some", once: c } = r, u = { root: i ? i.current : void 0, rootMargin: s, threshold: typeof l == "number" ? l : BE[l] }, d = h => { const { isIntersecting: m } = h; if (this.isInView === m || (this.isInView = m, c && !m && this.hasEnteredView)) return; m && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", m); const { onViewportEnter: g, onViewportLeave: v } = this.node.getProps(), w = m ? g : v; w && w(h) }; return zE(this.node.current, u, d) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: r, prevProps: i } = this.node;["amount", "margin", "root"].some($E(r, i)) && this.startObserver() } unmount() { } } function $E({ viewport: t = {} }, { viewport: r = {} } = {}) { return i => t[i] !== r[i] } const WE = { inView: { Feature: UE }, tap: { Feature: VE }, focus: { Feature: FE }, hover: { Feature: DE } }, HE = { layout: { ProjectionNode: gy, MeasureLayout: ly } }, KE = { ...M2, ...WE, ...LE, ...HE }, ye = Yk(KE, a2); function GE() { return x.jsxs("section", { id: "home", className: "relative overflow-hidden bg-white", children: [x.jsx(ye.div, { className: "shape orb-3d top-16 right-10 w-64 h-64 opacity-20", animate: { y: [0, -20, 0], rotate: [0, 10, 0] }, transition: { duration: 8, repeat: 1 / 0, ease: "easeInOut" } }), x.jsx(ye.div, { className: "shape cube-3d bottom-24 left-10 w-52 h-52 opacity-15", animate: { y: [0, 15, 0], rotate: [0, -8, 0] }, transition: { duration: 10, repeat: 1 / 0, ease: "easeInOut" } }), x.jsx(ye.div, { className: "shape ring-3d top-1/2 left-1/2 w-80 h-80 -translate-x-1/2 -translate-y-1/2 opacity-10", animate: { rotate: 360 }, transition: { duration: 30, repeat: 1 / 0, ease: "linear" } }), x.jsx("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-20 lg:py-32", children: x.jsxs("div", { className: "grid lg:grid-cols-2 gap-12 items-center", children: [x.jsxs(ye.div, { className: "space-y-8", initial: { opacity: 0, x: -50 }, animate: { opacity: 1, x: 0 }, transition: { duration: .8 }, children: [x.jsxs(ye.div, { className: "inline-flex items-center gap-2 bg-white px-4 py-2 rounded-full shadow-sm", initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: .2, duration: .6 }, children: [x.jsx(Im, { className: "w-4 h-4 text-[#00E6FF]" }), x.jsx("span", { className: "text-slate-700 text-sm", children: "Digital Solutions for Kerala Businesses" })] }), x.jsxs(ye.h1, { className: "heading-font text-[#0E0E0E] leading-tight", style: { fontSize: "48px" }, initial: { opacity: 0, y: 30 }, animate: { opacity: 1, y: 0 }, transition: { delay: .3, duration: .8 }, children: ["Build Your Business Website in ", x.jsx("span", { className: "text-transparent bg-clip-text bg-gradient-to-r from-[#1E62FF] to-[#00E6FF]", children: "Kerala" }), " with Digital Innovation"] }), x.jsx(ye.p, { className: "text-slate-800 text-lg leading-relaxed body-font", initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: .4, duration: .6 }, children: "Your partner for Web Development, AI Solutions, and Digital Marketing in Kerala. Specializing in growth strategies for the Kerala commercial sector." }), x.jsxs(ye.div, { className: "flex flex-wrap gap-4", initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: .5, duration: .6 }, children: [x.jsxs(qt, { to: "/contact", className: "neon-hover bg-[#1E62FF] text-white px-8 py-4 rounded-xl transition-all flex items-center gap-2 group", children: ["Get Started", x.jsx(D1, { className: "w-5 h-5 group-hover:translate-x-1 transition-transform" })] }), x.jsx(qt, { to: "/pricing", className: "bg-white text-[#1E62FF] px-8 py-4 rounded-xl border-2 border-[#1E62FF] hover:bg-[#1E62FF] hover:text-white transition-all", children: "View Pricing" })] }), x.jsxs(ye.div, { className: "flex flex-wrap gap-8 pt-8", initial: { opacity: 0 }, animate: { opacity: 1 }, transition: { delay: .7, duration: .8 }, children: [x.jsxs(ye.div, { initial: { opacity: 0, scale: .5 }, animate: { opacity: 1, scale: 1 }, transition: { delay: .8, duration: .5 }, children: [x.jsx("div", { className: "text-[#1E62FF]", style: { fontSize: "32px", fontWeight: "700" }, children: "50+" }), x.jsx("div", { className: "text-slate-600 text-sm", children: "Websites Built" })] }), x.jsxs(ye.div, { initial: { opacity: 0, scale: .5 }, animate: { opacity: 1, scale: 1 }, transition: { delay: .9, duration: .5 }, children: [x.jsx("div", { className: "text-[#00E6FF]", style: { fontSize: "32px", fontWeight: "700" }, children: "100%" }), x.jsx("div", { className: "text-slate-600 text-sm", children: "Client Satisfaction" })] }), x.jsxs(ye.div, { initial: { opacity: 0, scale: .5 }, animate: { opacity: 1, scale: 1 }, transition: { delay: 1, duration: .5 }, children: [x.jsx("div", { className: "text-[#0E0E0E]", style: { fontSize: "32px", fontWeight: "700" }, children: "247" }), x.jsx("div", { className: "text-slate-600 text-sm", children: "Support Available" })] })] })] }), x.jsxs(ye.div, { className: "relative", initial: { opacity: 0, x: 50 }, animate: { opacity: 1, x: 0 }, transition: { duration: .8, delay: .2 }, children: [x.jsx(ye.div, { className: "relative rounded-2xl overflow-hidden shadow-2xl ring-1 ring-[#1E62FF22]", whileHover: { scale: 1.02 }, transition: { duration: .3 }, children: x.jsx(_m, { src: "https://images.unsplash.com/photo-1498050108023-c5249f4df085?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixlib=rb-4.0.3&q=85&w=1600", alt: "High-clarity modern website mockup", className: "w-full h-auto" }) }), x.jsxs(ye.div, { className: "absolute -bottom-6 -left-6 bg-white rounded-2xl shadow-xl p-6 max-w-[220px]", initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: .8, duration: .6 }, whileHover: { scale: 1.05, rotate: -2 }, children: [x.jsx("div", { className: "text-[#1E62FF] heading-font", style: { fontSize: "24px" }, children: "Premium Quality" }), x.jsx("p", { className: "text-slate-600 text-sm mt-1", children: "Modern, SEO-ready, mobile-optimized" })] }), x.jsxs(ye.div, { className: "absolute -top-6 -right-6 bg-gradient-to-br from-[#1E62FF] to-[#00E6FF] text-white rounded-2xl shadow-xl p-6 max-w-[200px]", initial: { opacity: 0, y: -20 }, animate: { opacity: 1, y: 0 }, transition: { delay: 1, duration: .6 }, whileHover: { scale: 1.05, rotate: 2 }, children: [x.jsx("div", { className: "heading-font", style: { fontSize: "20px" }, children: "Transparent Pricing" }), x.jsx("p", { className: "text-white text-sm mt-1 opacity-90", children: "Starting 9,999" })] })] })] }) })] }) } const YE = [{ icon: Dm, title: "Web Development Services", description: "Custom, responsive, and secure web solutions built for growth.", features: ["Custom website design and development", "Responsive and mobile-friendly web applications", "E-commerce solutions with secure payment gateways"], color: "#1E62FF" }, { icon: V1, title: "AI-Powered Solutions", description: "Leverage artificial intelligence to automate and optimize your business.", features: ["Intelligent chatbot development for customer support", "Business process automation systems", "AI-driven data analysis and insights"], color: "#00E6FF" }, { icon: cw, title: "Digital Marketing Services", description: "Strategic marketing to boost your visibility in Kerala and beyond.", features: ["Search Engine Optimization (SEO) for Kerala businesses", "Local SEO targeting Ernakulam district and Kochi region", "Pay-per-click (PPC) advertising campaigns", "Social media marketing strategies"], color: "#1E62FF" }, { icon: lw, title: "Lead Generation Services", description: "Targeted strategies to convert traffic into loyal customers.", features: ["Targeted lead generation for Kochi-based businesses", "Conversion optimization for Kerala commercial sector", "Email marketing campaigns", "CRM integration solutions"], color: "#00E6FF" }]; function yy() { const t = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: .1 } } }, r = { hidden: { opacity: 0, y: 30 }, visible: { opacity: 1, y: 0, transition: { duration: .5 } } }; return x.jsx("section", { id: "services", className: "py-20 lg:py-32 bg-white", children: x.jsxs("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: [x.jsxs(ye.div, { className: "text-center max-w-3xl mx-auto mb-16", initial: { opacity: 0, y: -20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, children: [x.jsx("h2", { className: "heading-font text-slate-900 mb-4", children: "Our Services" }), x.jsx("p", { className: "text-slate-600 text-lg", children: "Tailored digital solutions for businesses in Kerala, focusing on Kerala, Ernakulam, Kochi, and Kakkanad." })] }), x.jsx(ye.div, { className: "grid md:grid-cols-2 gap-8", variants: t, initial: "hidden", whileInView: "visible", viewport: { once: !0 }, children: YE.map((i, s) => x.jsxs(ye.div, { className: "neon-hover bg-[#F8FBFF] rounded-2xl p-8 hover:-translate-y-1 group border border-slate-100", variants: r, whileHover: { scale: 1.02, transition: { duration: .2 } }, children: [x.jsx(ye.div, { className: "w-14 h-14 rounded-xl flex items-center justify-center mb-6 text-white shadow-lg", style: { background: `linear-gradient(135deg, ${i.color}, ${i.color}dd)` }, whileHover: { rotate: 5, scale: 1.1 }, children: x.jsx(i.icon, { className: "w-7 h-7" }) }), x.jsx("h3", { className: "text-2xl font-bold text-slate-900 mb-3 group-hover:text-[#1E62FF] transition-colors", children: i.title }), x.jsx("p", { className: "text-slate-600 mb-6 leading-relaxed", children: i.description }), x.jsx("ul", { className: "space-y-3", children: i.features.map((l, c) => x.jsxs("li", { className: "flex items-start gap-3 text-slate-700", children: [x.jsx(z1, { className: "w-5 h-5 text-[#1E62FF] shrink-0 mt-0.5" }), x.jsx("span", { className: "text-sm font-medium", children: l })] }, c)) })] }, s)) })] }) }) } function XE(t, r = []) { let i = []; function s(c, u) { const d = b.createContext(u); d.displayName = c + "Context"; const h = i.length; i = [...i, u]; const m = v => { const { scope: w, children: k, ...E } = v, N = w?.[t]?.[h] || d, C = b.useMemo(() => E, Object.values(E)); return x.jsx(N.Provider, { value: C, children: k }) }; m.displayName = c + "Provider"; function g(v, w) { const k = w?.[t]?.[h] || d, E = b.useContext(k); if (E) return E; if (u !== void 0) return u; throw new Error(`\`${v}\` must be used within \`${c}\``) } return [m, g] } const l = () => { const c = i.map(u => b.createContext(u)); return function (d) { const h = d?.[t] || c; return b.useMemo(() => ({ [`__scope${t}`]: { ...d, [t]: h } }), [d, h]) } }; return l.scopeName = t, [s, QE(l, ...r)] } function QE(...t) { const r = t[0]; if (t.length === 1) return r; const i = () => { const s = t.map(l => ({ useScope: l(), scopeName: l.scopeName })); return function (c) { const u = s.reduce((d, { useScope: h, scopeName: m }) => { const v = h(c)[`__scope${m}`]; return { ...d, ...v } }, {}); return b.useMemo(() => ({ [`__scope${r.scopeName}`]: u }), [u]) } }; return i.scopeName = r.scopeName, i } function Zp(t, r) { if (typeof t == "function") return t(r); t != null && (t.current = r) } function qE(...t) { return r => { let i = !1; const s = t.map(l => { const c = Zp(l, r); return !i && typeof c == "function" && (i = !0), c }); if (i) return () => { for (let l = 0; l < s.length; l++) { const c = s[l]; typeof c == "function" ? c() : Zp(t[l], null) } } } } var ZE = Symbol.for("react.lazy"), la = Y0[" use ".trim().toString()]; function JE(t) { return typeof t == "object" && t !== null && "then" in t } function vy(t) { return t != null && typeof t == "object" && "$$typeof" in t && t.$$typeof === ZE && "_payload" in t && JE(t._payload) } function eC(t) { const r = tC(t), i = b.forwardRef((s, l) => { let { children: c, ...u } = s; vy(c) && typeof la == "function" && (c = la(c._payload)); const d = b.Children.toArray(c), h = d.find(rC); if (h) { const m = h.props.children, g = d.map(v => v === h ? b.Children.count(m) > 1 ? b.Children.only(null) : b.isValidElement(m) ? m.props.children : null : v); return x.jsx(r, { ...u, ref: l, children: b.isValidElement(m) ? b.cloneElement(m, void 0, g) : null }) } return x.jsx(r, { ...u, ref: l, children: c }) }); return i.displayName = `${t}.Slot`, i } function tC(t) { const r = b.forwardRef((i, s) => { let { children: l, ...c } = i; if (vy(l) && typeof la == "function" && (l = la(l._payload)), b.isValidElement(l)) { const u = oC(l), d = iC(c, l.props); return l.type !== b.Fragment && (d.ref = s ? qE(s, u) : u), b.cloneElement(l, d) } return b.Children.count(l) > 1 ? b.Children.only(null) : null }); return r.displayName = `${t}.SlotClone`, r } var nC = Symbol("radix.slottable"); function rC(t) { return b.isValidElement(t) && typeof t.type == "function" && "__radixId" in t.type && t.type.__radixId === nC } function iC(t, r) { const i = { ...r }; for (const s in r) { const l = t[s], c = r[s]; /^on[A-Z]/.test(s) ? l && c ? i[s] = (...d) => { const h = c(...d); return l(...d), h } : l && (i[s] = l) : s === "style" ? i[s] = { ...l, ...c } : s === "className" && (i[s] = [l, c].filter(Boolean).join(" ")) } return { ...t, ...i } } function oC(t) { let r = Object.getOwnPropertyDescriptor(t.props, "ref")?.get, i = r && "isReactWarning" in r && r.isReactWarning; return i ? t.ref : (r = Object.getOwnPropertyDescriptor(t, "ref")?.get, i = r && "isReactWarning" in r && r.isReactWarning, i ? t.props.ref : t.props.ref || t.ref) } var sC = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"], xy = sC.reduce((t, r) => { const i = eC(`Primitive.${r}`), s = b.forwardRef((l, c) => { const { asChild: u, ...d } = l, h = u ? i : r; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), x.jsx(h, { ...d, ref: c }) }); return s.displayName = `Primitive.${r}`, { ...t, [r]: s } }, {}), _c = "Progress", Oc = 100, [aC] = XE(_c), [lC, uC] = aC(_c), wy = b.forwardRef((t, r) => { const { __scopeProgress: i, value: s = null, max: l, getValueLabel: c = cC, ...u } = t; (l || l === 0) && !Jp(l) && console.error(fC(`${l}`, "Progress")); const d = Jp(l) ? l : Oc; s !== null && !em(s, d) && console.error(dC(`${s}`, "Progress")); const h = em(s, d) ? s : null, m = ua(h) ? c(h, d) : void 0; return x.jsx(lC, { scope: i, value: h, max: d, children: x.jsx(xy.div, { "aria-valuemax": d, "aria-valuemin": 0, "aria-valuenow": ua(h) ? h : void 0, "aria-valuetext": m, role: "progressbar", "data-state": Ey(h, d), "data-value": h ?? void 0, "data-max": d, ...u, ref: r }) }) }); wy.displayName = _c; var Sy = "ProgressIndicator", ky = b.forwardRef((t, r) => { const { __scopeProgress: i, ...s } = t, l = uC(Sy, i); return x.jsx(xy.div, { "data-state": Ey(l.value, l.max), "data-value": l.value ?? void 0, "data-max": l.max, ...s, ref: r }) }); ky.displayName = Sy; function cC(t, r) { return `${Math.round(t / r * 100)}%` } function Ey(t, r) { return t == null ? "indeterminate" : t === r ? "complete" : "loading" } function ua(t) { return typeof t == "number" } function Jp(t) { return ua(t) && !isNaN(t) && t > 0 } function em(t, r) { return ua(t) && !isNaN(t) && t <= r && t >= 0 } function fC(t, r) { return `Invalid prop \`max\` of value \`${t}\` supplied to \`${r}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${Oc}\`.` } function dC(t, r) {
  return `Invalid prop \`value\` of value \`${t}\` supplied to \`${r}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${Oc} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`} var hC = wy, pC = ky; function Cy(t) { var r, i, s = ""; if (typeof t == "string" || typeof t == "number") s += t; else if (typeof t == "object") if (Array.isArray(t)) { var l = t.length; for (r = 0; r < l; r++)t[r] && (i = Cy(t[r])) && (s && (s += " "), s += i) } else for (i in t) t[i] && (s && (s += " "), s += i); return s } function mC() { for (var t, r, i = 0, s = "", l = arguments.length; i < l; i++)(t = arguments[i]) && (r = Cy(t)) && (s && (s += " "), s += r); return s } const gC = (t, r) => { const i = new Array(t.length + r.length); for (let s = 0; s < t.length; s++)i[s] = t[s]; for (let s = 0; s < r.length; s++)i[t.length + s] = r[s]; return i }, yC = (t, r) => ({ classGroupId: t, validator: r }), Py = (t = new Map, r = null, i) => ({ nextPart: t, validators: r, classGroupId: i }), ca = "-", tm = [], vC = "arbitrary..", xC = t => { const r = SC(t), { conflictingClassGroups: i, conflictingClassGroupModifiers: s } = t; return { getClassGroupId: u => { if (u.startsWith("[") && u.endsWith("]")) return wC(u); const d = u.split(ca), h = d[0] === "" && d.length > 1 ? 1 : 0; return Ty(d, h, r) }, getConflictingClassGroupIds: (u, d) => { if (d) { const h = s[u], m = i[u]; return h ? m ? gC(m, h) : h : m || tm } return i[u] || tm } } }, Ty = (t, r, i) => { if (t.length - r === 0) return i.classGroupId; const l = t[r], c = i.nextPart.get(l); if (c) { const m = Ty(t, r + 1, c); if (m) return m } const u = i.validators; if (u === null) return; const d = r === 0 ? t.join(ca) : t.slice(r).join(ca), h = u.length; for (let m = 0; m < h; m++) { const g = u[m]; if (g.validator(d)) return g.classGroupId } }, wC = t => t.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => { const r = t.slice(1, -1), i = r.indexOf(":"), s = r.slice(0, i); return s ? vC + s : void 0 })(), SC = t => { const { theme: r, classGroups: i } = t; return kC(i, r) }, kC = (t, r) => { const i = Py(); for (const s in t) { const l = t[s]; zc(l, i, s, r) } return i }, zc = (t, r, i, s) => { const l = t.length; for (let c = 0; c < l; c++) { const u = t[c]; EC(u, r, i, s) } }, EC = (t, r, i, s) => { if (typeof t == "string") { CC(t, r, i); return } if (typeof t == "function") { PC(t, r, i, s); return } TC(t, r, i, s) }, CC = (t, r, i) => { const s = t === "" ? r : Ny(r, t); s.classGroupId = i }, PC = (t, r, i, s) => { if (NC(t)) { zc(t(s), r, i, s); return } r.validators === null && (r.validators = []), r.validators.push(yC(i, t)) }, TC = (t, r, i, s) => { const l = Object.entries(t), c = l.length; for (let u = 0; u < c; u++) { const [d, h] = l[u]; zc(h, Ny(r, d), i, s) } }, Ny = (t, r) => { let i = t; const s = r.split(ca), l = s.length; for (let c = 0; c < l; c++) { const u = s[c]; let d = i.nextPart.get(u); d || (d = Py(), i.nextPart.set(u, d)), i = d } return i }, NC = t => "isThemeGetter" in t && t.isThemeGetter === !0, bC = t => { if (t < 1) return { get: () => { }, set: () => { } }; let r = 0, i = Object.create(null), s = Object.create(null); const l = (c, u) => { i[c] = u, r++, r > t && (r = 0, s = i, i = Object.create(null)) }; return { get(c) { let u = i[c]; if (u !== void 0) return u; if ((u = s[c]) !== void 0) return l(c, u), u }, set(c, u) { c in i ? i[c] = u : l(c, u) } } }, Zu = "!", nm = ":", RC = [], rm = (t, r, i, s, l) => ({ modifiers: t, hasImportantModifier: r, baseClassName: i, maybePostfixModifierPosition: s, isExternal: l }), jC = t => { const { prefix: r, experimentalParseClassName: i } = t; let s = l => { const c = []; let u = 0, d = 0, h = 0, m; const g = l.length; for (let N = 0; N < g; N++) { const C = l[N]; if (u === 0 && d === 0) { if (C === nm) { c.push(l.slice(h, N)), h = N + 1; continue } if (C === "/") { m = N; continue } } C === "[" ? u++ : C === "]" ? u-- : C === "(" ? d++ : C === ")" && d-- } const v = c.length === 0 ? l : l.slice(h); let w = v, k = !1; v.endsWith(Zu) ? (w = v.slice(0, -1), k = !0) : v.startsWith(Zu) && (w = v.slice(1), k = !0); const E = m && m > h ? m - h : void 0; return rm(c, k, w, E) }; if (r) { const l = r + nm, c = s; s = u => u.startsWith(l) ? c(u.slice(l.length)) : rm(RC, !1, u, void 0, !0) } if (i) { const l = s; s = c => i({ className: c, parseClassName: l }) } return s }, AC = t => { const r = new Map; return t.orderSensitiveModifiers.forEach((i, s) => { r.set(i, 1e6 + s) }), i => { const s = []; let l = []; for (let c = 0; c < i.length; c++) { const u = i[c], d = u[0] === "[", h = r.has(u); d || h ? (l.length > 0 && (l.sort(), s.push(...l), l = []), s.push(u)) : l.push(u) } return l.length > 0 && (l.sort(), s.push(...l)), s } }, MC = t => ({ cache: bC(t.cacheSize), parseClassName: jC(t), sortModifiers: AC(t), ...xC(t) }), LC = /\s+/, DC = (t, r) => { const { parseClassName: i, getClassGroupId: s, getConflictingClassGroupIds: l, sortModifiers: c } = r, u = [], d = t.trim().split(LC); let h = ""; for (let m = d.length - 1; m >= 0; m -= 1) { const g = d[m], { isExternal: v, modifiers: w, hasImportantModifier: k, baseClassName: E, maybePostfixModifierPosition: N } = i(g); if (v) { h = g + (h.length > 0 ? " " + h : h); continue } let C = !!N, P = s(C ? E.substring(0, N) : E); if (!P) { if (!C) { h = g + (h.length > 0 ? " " + h : h); continue } if (P = s(E), !P) { h = g + (h.length > 0 ? " " + h : h); continue } C = !1 } const A = w.length === 0 ? "" : w.length === 1 ? w[0] : c(w).join(":"), L = k ? A + Zu : A, U = L + P; if (u.indexOf(U) > -1) continue; u.push(U); const O = l(P, C); for (let H = 0; H < O.length; ++H) { const K = O[H]; u.push(L + K) } h = g + (h.length > 0 ? " " + h : h) } return h }, FC = (...t) => { let r = 0, i, s, l = ""; for (; r < t.length;)(i = t[r++]) && (s = by(i)) && (l && (l += " "), l += s); return l }, by = t => { if (typeof t == "string") return t; let r, i = ""; for (let s = 0; s < t.length; s++)t[s] && (r = by(t[s])) && (i && (i += " "), i += r); return i }, VC = (t, ...r) => { let i, s, l, c; const u = h => { const m = r.reduce((g, v) => v(g), t()); return i = MC(m), s = i.cache.get, l = i.cache.set, c = d, d(h) }, d = h => { const m = s(h); if (m) return m; const g = DC(h, i); return l(h, g), g }; return c = u, (...h) => c(FC(...h)) }, IC = [], qe = t => { const r = i => i[t] || IC; return r.isThemeGetter = !0, r }, Ry = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, jy = /^\((?:(\w[\w-]*):)?(.+)\)$/i, _C = /^\d+\/\d+$/, OC = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, zC = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, BC = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, UC = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, $C = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Yr = t => _C.test(t), xe = t => !!t && !Number.isNaN(Number(t)), Kn = t => !!t && Number.isInteger(Number(t)), Pu = t => t.endsWith("%") && xe(t.slice(0, -1)), Sn = t => OC.test(t), WC = () => !0, HC = t => zC.test(t) && !BC.test(t), Ay = () => !1, KC = t => UC.test(t), GC = t => $C.test(t), YC = t => !ee(t) && !te(t), XC = t => li(t, Dy, Ay), ee = t => Ry.test(t), hr = t => li(t, Fy, HC), Tu = t => li(t, eP, xe), im = t => li(t, My, Ay), QC = t => li(t, Ly, GC), Gs = t => li(t, Vy, KC), te = t => jy.test(t), oo = t => ui(t, Fy), qC = t => ui(t, tP), om = t => ui(t, My), ZC = t => ui(t, Dy), JC = t => ui(t, Ly), Ys = t => ui(t, Vy, !0), li = (t, r, i) => { const s = Ry.exec(t); return s ? s[1] ? r(s[1]) : i(s[2]) : !1 }, ui = (t, r, i = !1) => { const s = jy.exec(t); return s ? s[1] ? r(s[1]) : i : !1 }, My = t => t === "position" || t === "percentage", Ly = t => t === "image" || t === "url", Dy = t => t === "length" || t === "size" || t === "bg-size", Fy = t => t === "length", eP = t => t === "number", tP = t => t === "family-name", Vy = t => t === "shadow", nP = () => { const t = qe("color"), r = qe("font"), i = qe("text"), s = qe("font-weight"), l = qe("tracking"), c = qe("leading"), u = qe("breakpoint"), d = qe("container"), h = qe("spacing"), m = qe("radius"), g = qe("shadow"), v = qe("inset-shadow"), w = qe("text-shadow"), k = qe("drop-shadow"), E = qe("blur"), N = qe("perspective"), C = qe("aspect"), P = qe("ease"), A = qe("animate"), L = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], U = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"], O = () => [...U(), te, ee], H = () => ["auto", "hidden", "clip", "visible", "scroll"], K = () => ["auto", "contain", "none"], I = () => [te, ee, h], Q = () => [Yr, "full", "auto", ...I()], le = () => [Kn, "none", "subgrid", te, ee], pe = () => ["auto", { span: ["full", Kn, te, ee] }, Kn, te, ee], Se = () => [Kn, "auto", te, ee], Re = () => ["auto", "min", "max", "fr", te, ee], je = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], Te = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], ke = () => ["auto", ...I()], ae = () => [Yr, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...I()], V = () => [t, te, ee], Y = () => [...U(), om, im, { position: [te, ee] }], G = () => ["no-repeat", { repeat: ["", "x", "y", "space", "round"] }], j = () => ["auto", "cover", "contain", ZC, XC, { size: [te, ee] }], _ = () => [Pu, oo, hr], ne = () => ["", "none", "full", m, te, ee], ie = () => ["", xe, oo, hr], me = () => ["solid", "dashed", "dotted", "double"], ge = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], se = () => [xe, Pu, om, im], fe = () => ["", "none", E, te, ee], ve = () => ["none", xe, te, ee], Ne = () => ["none", xe, te, ee], Ce = () => [xe, te, ee], Z = () => [Yr, "full", ...I()]; return { cacheSize: 500, theme: { animate: ["spin", "ping", "pulse", "bounce"], aspect: ["video"], blur: [Sn], breakpoint: [Sn], color: [WC], container: [Sn], "drop-shadow": [Sn], ease: ["in", "out", "in-out"], font: [YC], "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"], "inset-shadow": [Sn], leading: ["none", "tight", "snug", "normal", "relaxed", "loose"], perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"], radius: [Sn], shadow: [Sn], spacing: ["px", xe], text: [Sn], "text-shadow": [Sn], tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"] }, classGroups: { aspect: [{ aspect: ["auto", "square", Yr, ee, te, C] }], container: ["container"], columns: [{ columns: [xe, ee, te, d] }], "break-after": [{ "break-after": L() }], "break-before": [{ "break-before": L() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], sr: ["sr-only", "not-sr-only"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: O() }], overflow: [{ overflow: H() }], "overflow-x": [{ "overflow-x": H() }], "overflow-y": [{ "overflow-y": H() }], overscroll: [{ overscroll: K() }], "overscroll-x": [{ "overscroll-x": K() }], "overscroll-y": [{ "overscroll-y": K() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: Q() }], "inset-x": [{ "inset-x": Q() }], "inset-y": [{ "inset-y": Q() }], start: [{ start: Q() }], end: [{ end: Q() }], top: [{ top: Q() }], right: [{ right: Q() }], bottom: [{ bottom: Q() }], left: [{ left: Q() }], visibility: ["visible", "invisible", "collapse"], z: [{ z: [Kn, "auto", te, ee] }], basis: [{ basis: [Yr, "full", "auto", d, ...I()] }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["nowrap", "wrap", "wrap-reverse"] }], flex: [{ flex: [xe, Yr, "auto", "initial", "none", ee] }], grow: [{ grow: ["", xe, te, ee] }], shrink: [{ shrink: ["", xe, te, ee] }], order: [{ order: [Kn, "first", "last", "none", te, ee] }], "grid-cols": [{ "grid-cols": le() }], "col-start-end": [{ col: pe() }], "col-start": [{ "col-start": Se() }], "col-end": [{ "col-end": Se() }], "grid-rows": [{ "grid-rows": le() }], "row-start-end": [{ row: pe() }], "row-start": [{ "row-start": Se() }], "row-end": [{ "row-end": Se() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": Re() }], "auto-rows": [{ "auto-rows": Re() }], gap: [{ gap: I() }], "gap-x": [{ "gap-x": I() }], "gap-y": [{ "gap-y": I() }], "justify-content": [{ justify: [...je(), "normal"] }], "justify-items": [{ "justify-items": [...Te(), "normal"] }], "justify-self": [{ "justify-self": ["auto", ...Te()] }], "align-content": [{ content: ["normal", ...je()] }], "align-items": [{ items: [...Te(), { baseline: ["", "last"] }] }], "align-self": [{ self: ["auto", ...Te(), { baseline: ["", "last"] }] }], "place-content": [{ "place-content": je() }], "place-items": [{ "place-items": [...Te(), "baseline"] }], "place-self": [{ "place-self": ["auto", ...Te()] }], p: [{ p: I() }], px: [{ px: I() }], py: [{ py: I() }], ps: [{ ps: I() }], pe: [{ pe: I() }], pt: [{ pt: I() }], pr: [{ pr: I() }], pb: [{ pb: I() }], pl: [{ pl: I() }], m: [{ m: ke() }], mx: [{ mx: ke() }], my: [{ my: ke() }], ms: [{ ms: ke() }], me: [{ me: ke() }], mt: [{ mt: ke() }], mr: [{ mr: ke() }], mb: [{ mb: ke() }], ml: [{ ml: ke() }], "space-x": [{ "space-x": I() }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": I() }], "space-y-reverse": ["space-y-reverse"], size: [{ size: ae() }], w: [{ w: [d, "screen", ...ae()] }], "min-w": [{ "min-w": [d, "screen", "none", ...ae()] }], "max-w": [{ "max-w": [d, "screen", "none", "prose", { screen: [u] }, ...ae()] }], h: [{ h: ["screen", "lh", ...ae()] }], "min-h": [{ "min-h": ["screen", "lh", "none", ...ae()] }], "max-h": [{ "max-h": ["screen", "lh", ...ae()] }], "font-size": [{ text: ["base", i, oo, hr] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: [s, te, Tu] }], "font-stretch": [{ "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", Pu, ee] }], "font-family": [{ font: [qC, ee, r] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: [l, te, ee] }], "line-clamp": [{ "line-clamp": [xe, "none", te, Tu] }], leading: [{ leading: [c, ...I()] }], "list-image": [{ "list-image": ["none", te, ee] }], "list-style-position": [{ list: ["inside", "outside"] }], "list-style-type": [{ list: ["disc", "decimal", "none", te, ee] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "placeholder-color": [{ placeholder: V() }], "text-color": [{ text: V() }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...me(), "wavy"] }], "text-decoration-thickness": [{ decoration: [xe, "from-font", "auto", te, hr] }], "text-decoration-color": [{ decoration: V() }], "underline-offset": [{ "underline-offset": [xe, "auto", te, ee] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: I() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", te, ee] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], wrap: [{ wrap: ["break-word", "anywhere", "normal"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", te, ee] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: Y() }], "bg-repeat": [{ bg: G() }], "bg-size": [{ bg: j() }], "bg-image": [{ bg: ["none", { linear: [{ to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, Kn, te, ee], radial: ["", te, ee], conic: [Kn, te, ee] }, JC, QC] }], "bg-color": [{ bg: V() }], "gradient-from-pos": [{ from: _() }], "gradient-via-pos": [{ via: _() }], "gradient-to-pos": [{ to: _() }], "gradient-from": [{ from: V() }], "gradient-via": [{ via: V() }], "gradient-to": [{ to: V() }], rounded: [{ rounded: ne() }], "rounded-s": [{ "rounded-s": ne() }], "rounded-e": [{ "rounded-e": ne() }], "rounded-t": [{ "rounded-t": ne() }], "rounded-r": [{ "rounded-r": ne() }], "rounded-b": [{ "rounded-b": ne() }], "rounded-l": [{ "rounded-l": ne() }], "rounded-ss": [{ "rounded-ss": ne() }], "rounded-se": [{ "rounded-se": ne() }], "rounded-ee": [{ "rounded-ee": ne() }], "rounded-es": [{ "rounded-es": ne() }], "rounded-tl": [{ "rounded-tl": ne() }], "rounded-tr": [{ "rounded-tr": ne() }], "rounded-br": [{ "rounded-br": ne() }], "rounded-bl": [{ "rounded-bl": ne() }], "border-w": [{ border: ie() }], "border-w-x": [{ "border-x": ie() }], "border-w-y": [{ "border-y": ie() }], "border-w-s": [{ "border-s": ie() }], "border-w-e": [{ "border-e": ie() }], "border-w-t": [{ "border-t": ie() }], "border-w-r": [{ "border-r": ie() }], "border-w-b": [{ "border-b": ie() }], "border-w-l": [{ "border-l": ie() }], "divide-x": [{ "divide-x": ie() }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": ie() }], "divide-y-reverse": ["divide-y-reverse"], "border-style": [{ border: [...me(), "hidden", "none"] }], "divide-style": [{ divide: [...me(), "hidden", "none"] }], "border-color": [{ border: V() }], "border-color-x": [{ "border-x": V() }], "border-color-y": [{ "border-y": V() }], "border-color-s": [{ "border-s": V() }], "border-color-e": [{ "border-e": V() }], "border-color-t": [{ "border-t": V() }], "border-color-r": [{ "border-r": V() }], "border-color-b": [{ "border-b": V() }], "border-color-l": [{ "border-l": V() }], "divide-color": [{ divide: V() }], "outline-style": [{ outline: [...me(), "none", "hidden"] }], "outline-offset": [{ "outline-offset": [xe, te, ee] }], "outline-w": [{ outline: ["", xe, oo, hr] }], "outline-color": [{ outline: V() }], shadow: [{ shadow: ["", "none", g, Ys, Gs] }], "shadow-color": [{ shadow: V() }], "inset-shadow": [{ "inset-shadow": ["none", v, Ys, Gs] }], "inset-shadow-color": [{ "inset-shadow": V() }], "ring-w": [{ ring: ie() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: V() }], "ring-offset-w": [{ "ring-offset": [xe, hr] }], "ring-offset-color": [{ "ring-offset": V() }], "inset-ring-w": [{ "inset-ring": ie() }], "inset-ring-color": [{ "inset-ring": V() }], "text-shadow": [{ "text-shadow": ["none", w, Ys, Gs] }], "text-shadow-color": [{ "text-shadow": V() }], opacity: [{ opacity: [xe, te, ee] }], "mix-blend": [{ "mix-blend": [...ge(), "plus-darker", "plus-lighter"] }], "bg-blend": [{ "bg-blend": ge() }], "mask-clip": [{ "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"] }, "mask-no-clip"], "mask-composite": [{ mask: ["add", "subtract", "intersect", "exclude"] }], "mask-image-linear-pos": [{ "mask-linear": [xe] }], "mask-image-linear-from-pos": [{ "mask-linear-from": se() }], "mask-image-linear-to-pos": [{ "mask-linear-to": se() }], "mask-image-linear-from-color": [{ "mask-linear-from": V() }], "mask-image-linear-to-color": [{ "mask-linear-to": V() }], "mask-image-t-from-pos": [{ "mask-t-from": se() }], "mask-image-t-to-pos": [{ "mask-t-to": se() }], "mask-image-t-from-color": [{ "mask-t-from": V() }], "mask-image-t-to-color": [{ "mask-t-to": V() }], "mask-image-r-from-pos": [{ "mask-r-from": se() }], "mask-image-r-to-pos": [{ "mask-r-to": se() }], "mask-image-r-from-color": [{ "mask-r-from": V() }], "mask-image-r-to-color": [{ "mask-r-to": V() }], "mask-image-b-from-pos": [{ "mask-b-from": se() }], "mask-image-b-to-pos": [{ "mask-b-to": se() }], "mask-image-b-from-color": [{ "mask-b-from": V() }], "mask-image-b-to-color": [{ "mask-b-to": V() }], "mask-image-l-from-pos": [{ "mask-l-from": se() }], "mask-image-l-to-pos": [{ "mask-l-to": se() }], "mask-image-l-from-color": [{ "mask-l-from": V() }], "mask-image-l-to-color": [{ "mask-l-to": V() }], "mask-image-x-from-pos": [{ "mask-x-from": se() }], "mask-image-x-to-pos": [{ "mask-x-to": se() }], "mask-image-x-from-color": [{ "mask-x-from": V() }], "mask-image-x-to-color": [{ "mask-x-to": V() }], "mask-image-y-from-pos": [{ "mask-y-from": se() }], "mask-image-y-to-pos": [{ "mask-y-to": se() }], "mask-image-y-from-color": [{ "mask-y-from": V() }], "mask-image-y-to-color": [{ "mask-y-to": V() }], "mask-image-radial": [{ "mask-radial": [te, ee] }], "mask-image-radial-from-pos": [{ "mask-radial-from": se() }], "mask-image-radial-to-pos": [{ "mask-radial-to": se() }], "mask-image-radial-from-color": [{ "mask-radial-from": V() }], "mask-image-radial-to-color": [{ "mask-radial-to": V() }], "mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }], "mask-image-radial-size": [{ "mask-radial": [{ closest: ["side", "corner"], farthest: ["side", "corner"] }] }], "mask-image-radial-pos": [{ "mask-radial-at": U() }], "mask-image-conic-pos": [{ "mask-conic": [xe] }], "mask-image-conic-from-pos": [{ "mask-conic-from": se() }], "mask-image-conic-to-pos": [{ "mask-conic-to": se() }], "mask-image-conic-from-color": [{ "mask-conic-from": V() }], "mask-image-conic-to-color": [{ "mask-conic-to": V() }], "mask-mode": [{ mask: ["alpha", "luminance", "match"] }], "mask-origin": [{ "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"] }], "mask-position": [{ mask: Y() }], "mask-repeat": [{ mask: G() }], "mask-size": [{ mask: j() }], "mask-type": [{ "mask-type": ["alpha", "luminance"] }], "mask-image": [{ mask: ["none", te, ee] }], filter: [{ filter: ["", "none", te, ee] }], blur: [{ blur: fe() }], brightness: [{ brightness: [xe, te, ee] }], contrast: [{ contrast: [xe, te, ee] }], "drop-shadow": [{ "drop-shadow": ["", "none", k, Ys, Gs] }], "drop-shadow-color": [{ "drop-shadow": V() }], grayscale: [{ grayscale: ["", xe, te, ee] }], "hue-rotate": [{ "hue-rotate": [xe, te, ee] }], invert: [{ invert: ["", xe, te, ee] }], saturate: [{ saturate: [xe, te, ee] }], sepia: [{ sepia: ["", xe, te, ee] }], "backdrop-filter": [{ "backdrop-filter": ["", "none", te, ee] }], "backdrop-blur": [{ "backdrop-blur": fe() }], "backdrop-brightness": [{ "backdrop-brightness": [xe, te, ee] }], "backdrop-contrast": [{ "backdrop-contrast": [xe, te, ee] }], "backdrop-grayscale": [{ "backdrop-grayscale": ["", xe, te, ee] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [xe, te, ee] }], "backdrop-invert": [{ "backdrop-invert": ["", xe, te, ee] }], "backdrop-opacity": [{ "backdrop-opacity": [xe, te, ee] }], "backdrop-saturate": [{ "backdrop-saturate": [xe, te, ee] }], "backdrop-sepia": [{ "backdrop-sepia": ["", xe, te, ee] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": I() }], "border-spacing-x": [{ "border-spacing-x": I() }], "border-spacing-y": [{ "border-spacing-y": I() }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", te, ee] }], "transition-behavior": [{ transition: ["normal", "discrete"] }], duration: [{ duration: [xe, "initial", te, ee] }], ease: [{ ease: ["linear", "initial", P, te, ee] }], delay: [{ delay: [xe, te, ee] }], animate: [{ animate: ["none", A, te, ee] }], backface: [{ backface: ["hidden", "visible"] }], perspective: [{ perspective: [N, te, ee] }], "perspective-origin": [{ "perspective-origin": O() }], rotate: [{ rotate: ve() }], "rotate-x": [{ "rotate-x": ve() }], "rotate-y": [{ "rotate-y": ve() }], "rotate-z": [{ "rotate-z": ve() }], scale: [{ scale: Ne() }], "scale-x": [{ "scale-x": Ne() }], "scale-y": [{ "scale-y": Ne() }], "scale-z": [{ "scale-z": Ne() }], "scale-3d": ["scale-3d"], skew: [{ skew: Ce() }], "skew-x": [{ "skew-x": Ce() }], "skew-y": [{ "skew-y": Ce() }], transform: [{ transform: [te, ee, "", "none", "gpu", "cpu"] }], "transform-origin": [{ origin: O() }], "transform-style": [{ transform: ["3d", "flat"] }], translate: [{ translate: Z() }], "translate-x": [{ "translate-x": Z() }], "translate-y": [{ "translate-y": Z() }], "translate-z": [{ "translate-z": Z() }], "translate-none": ["translate-none"], accent: [{ accent: V() }], appearance: [{ appearance: ["none", "auto"] }], "caret-color": [{ caret: V() }], "color-scheme": [{ scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", te, ee] }], "field-sizing": [{ "field-sizing": ["fixed", "content"] }], "pointer-events": [{ "pointer-events": ["auto", "none"] }], resize: [{ resize: ["none", "", "y", "x"] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": I() }], "scroll-mx": [{ "scroll-mx": I() }], "scroll-my": [{ "scroll-my": I() }], "scroll-ms": [{ "scroll-ms": I() }], "scroll-me": [{ "scroll-me": I() }], "scroll-mt": [{ "scroll-mt": I() }], "scroll-mr": [{ "scroll-mr": I() }], "scroll-mb": [{ "scroll-mb": I() }], "scroll-ml": [{ "scroll-ml": I() }], "scroll-p": [{ "scroll-p": I() }], "scroll-px": [{ "scroll-px": I() }], "scroll-py": [{ "scroll-py": I() }], "scroll-ps": [{ "scroll-ps": I() }], "scroll-pe": [{ "scroll-pe": I() }], "scroll-pt": [{ "scroll-pt": I() }], "scroll-pr": [{ "scroll-pr": I() }], "scroll-pb": [{ "scroll-pb": I() }], "scroll-pl": [{ "scroll-pl": I() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", te, ee] }], fill: [{ fill: ["none", ...V()] }], "stroke-w": [{ stroke: [xe, oo, hr, Tu] }], stroke: [{ stroke: ["none", ...V()] }], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], translate: ["translate-x", "translate-y", "translate-none"], "translate-none": ["translate", "translate-x", "translate-y", "translate-z"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] }, orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"] } }, rP = VC(nP); function iP(...t) { return rP(mC(t)) } function Nu({ className: t, value: r, ...i }) { return x.jsx(hC, { "data-slot": "progress", className: iP("bg-primary/20 relative h-2 w-full overflow-hidden rounded-full", t), ...i, children: x.jsx(pC, { "data-slot": "progress-indicator", className: "bg-primary h-full w-full flex-1 transition-all", style: { transform: `translateX(-${100 - (r || 0)}%)` } }) }) } const oP = [{ icon: dw, title: "Fast Delivery", description: "Get your website online quickly with our efficient workflows and proven templates.", color: "#1E64F0" }, { icon: U1, title: "Affordable Pricing", description: "Perfect for small businesses and startups. Get a professional website without breaking the bank.", color: "#0F7B5F" }, { icon: Im, title: "Professional Templates", description: "Based on high-converting UI/UX patterns from successful brands. Beautiful and functional.", color: "#D8A546" }]; function sP() { const t = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: .2 } } }, r = { hidden: { opacity: 0, y: 30 }, visible: { opacity: 1, y: 0, transition: { duration: .5 } } }; return x.jsx("section", { className: "py-20 lg:py-32 bg-gradient-to-br from-[#F8FBFF] to-white", children: x.jsxs("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: [x.jsxs(ye.div, { className: "text-center max-w-3xl mx-auto mb-16", initial: { opacity: 0, y: -20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, children: [x.jsx("h2", { className: "heading-font text-slate-900 mb-4", children: "Why Choose Us" }), x.jsx("p", { className: "text-slate-600 text-lg", children: "We make it simple for you to succeed online." })] }), x.jsx(ye.div, { className: "grid md:grid-cols-3 gap-8", variants: t, initial: "hidden", whileInView: "visible", viewport: { once: !0 }, children: oP.map((i, s) => x.jsxs(ye.div, { className: "bg-white rounded-2xl p-8 shadow-lg hover:shadow-2xl transition-all duration-300", variants: r, whileHover: { scale: 1.03, y: -5 }, children: [x.jsx(ye.div, { className: "w-16 h-16 rounded-2xl flex items-center justify-center mb-6 shadow-md", style: { background: `linear-gradient(135deg, ${i.color} 0%, ${i.color}dd 100%)` }, whileHover: { rotate: 360, scale: 1.1 }, transition: { duration: .6 }, children: x.jsx(i.icon, { className: "w-8 h-8 text-white" }) }), x.jsx("h3", { className: "text-slate-900 mb-3 heading-font", children: i.title }), x.jsx("p", { className: "text-slate-600 leading-relaxed", children: i.description })] }, s)) }), x.jsx(ye.div, { className: "mt-20 bg-gradient-to-r from-[#1E62FF] to-[#00E6FF] rounded-3xl p-12 text-white", initial: { opacity: 0, y: 40 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: .3, duration: .8 }, children: x.jsxs("div", { className: "grid md:grid-cols-3 gap-8", children: [x.jsxs("div", { className: "text-center", children: [x.jsx("div", { style: { fontSize: "40px", fontWeight: "800" }, children: "50+" }), x.jsx("div", { className: "text-white/90", children: "Projects Completed" }), x.jsx("div", { className: "mt-4", children: x.jsx(Nu, { value: 90, className: "bg-white/20", "aria-label": "Projects Completed Percentage" }) })] }), x.jsxs("div", { className: "text-center", children: [x.jsx("div", { style: { fontSize: "40px", fontWeight: "800" }, children: "100%" }), x.jsx("div", { className: "text-white/90", children: "Client Satisfaction" }), x.jsx("div", { className: "mt-4", children: x.jsx(Nu, { value: 100, className: "bg-white/20", "aria-label": "Client Satisfaction Percentage" }) })] }), x.jsxs("div", { className: "text-center", children: [x.jsx("div", { style: { fontSize: "40px", fontWeight: "800" }, children: "247" }), x.jsx("div", { className: "text-white/90", children: "Support Available" }), x.jsx("div", { className: "mt-4", children: x.jsx(Nu, { value: 100, className: "bg-white/20", "aria-label": "Support Availability" }) })] })] }) })] }) }) } const aP = [{ title: "Vythiri Dew Vista", category: "Luxury Resort", description: "Premium resort booking platform with immersive visuals and seamless experience", image: "https://lh3.googleusercontent.com/p/AF1QipNFRKLsBsYBwve98AtIp3i8YZArTdsykStHfoN5=s680-w680-h510-rw", color: "#D8A546", link: "https://vythiridewvista.com/" }, { title: "Mount Vista", category: "Hospitality & Tourism", description: "Clean, nature-inspired website with elegant design and smooth navigation", image: "https://mountvista.in/static/media/property/mount-vista-chundale-wayanad-resorts-thu50ajr8n.jpeg", color: "#0F7B5F", link: "https://www.mountvista.in/" }, { title: "TravLocus", category: "Travel & Tourism", description: "Modern travel website with youthful design and excellent user experience", image: "https://images.unsplash.com/photo-1721908919568-4003760b6c7d?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixlib=rb-4.0.3&q=85&w=1600", color: "#1E64F0", link: "https://travlocus.in/" }]; function Iy() { const t = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: .15 } } }, r = { hidden: { opacity: 0, y: 40, scale: .9 }, visible: { opacity: 1, y: 0, scale: 1, transition: { duration: .6 } } }; return x.jsx("section", { id: "portfolio", className: "py-20 lg:py-32 bg-white", children: x.jsxs("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: [x.jsxs(ye.div, { className: "text-center max-w-3xl mx-auto mb-16", initial: { opacity: 0, y: -20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, children: [x.jsx("h2", { className: "heading-font text-slate-900 mb-4", children: "Our Portfolio" }), x.jsx("p", { className: "text-slate-600 text-lg", children: "Beautiful websites we've created for businesses like yours." })] }), x.jsx(ye.div, { className: "grid md:grid-cols-2 lg:grid-cols-3 gap-8", variants: t, initial: "hidden", whileInView: "visible", viewport: { once: !0 }, children: aP.map((i, s) => x.jsxs(ye.a, { href: i.link, target: "_blank", rel: "noopener noreferrer", className: "group relative bg-white rounded-2xl overflow-hidden shadow-lg hover:shadow-2xl transition-all duration-300 ring-1 ring-[#1E62FF11] hover:ring-[#00E6FF44]", variants: r, whileHover: { y: -8, transition: { duration: .2 } }, children: [x.jsxs("div", { className: "relative h-64 overflow-hidden", children: [x.jsx(ye.div, { whileHover: { scale: 1.1 }, transition: { duration: .5 }, children: x.jsx(_m, { src: i.image, alt: i.title, className: "w-full h-full object-cover", loading: "lazy" }) }), x.jsx(ye.div, { className: "absolute inset-0 bg-gradient-to-t from-slate-900 via-slate-900/50 to-transparent flex items-center justify-center", initial: { opacity: 0 }, whileHover: { opacity: 1 }, transition: { duration: .3 }, children: x.jsxs(ye.div, { className: "bg-white text-slate-800 px-6 py-3 rounded-lg flex items-center gap-2", initial: { y: 20 }, whileHover: { y: 0 }, transition: { duration: .3 }, children: ["View Project", x.jsx(W1, { className: "w-4 h-4" })] }) })] }), x.jsxs("div", { className: "p-6", children: [x.jsx(ye.div, { className: "inline-block px-3 py-1 rounded-full text-xs mb-3", style: { backgroundColor: `${i.color}20`, color: i.color }, whileHover: { scale: 1.1 }, children: i.category }), x.jsx("h3", { className: "text-slate-900 mb-2 heading-font", children: i.title }), x.jsx("p", { className: "text-slate-600 text-sm", children: i.description })] })] }, s)) })] }) }) } const lP = [{ name: "Starter", price: "9,999", description: "Perfect for small businesses getting online fast.", features: ["13 pages", "Responsive design", "Basic SEO", "Contact form"], highlight: !1 }, { name: "Growth", price: "19,999", description: "For startups and professionals who want to scale.", features: ["Up to 6 pages", "Brand theme", "SEO-ready", "Blog / Portfolio"], highlight: !0 }, { name: "Pro", price: "39,999", description: "Premium features for advanced business needs.", features: ["10+ pages", "Advanced SEO", "Analytics setup", "Priority support"], highlight: !1 }]; function _y() { const t = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: .15 } } }, r = { hidden: { opacity: 0, y: 40 }, visible: { opacity: 1, y: 0, transition: { duration: .6 } } }; return x.jsx("section", { id: "pricing", className: "py-20 lg:py-32 bg-white", children: x.jsxs("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: [x.jsxs(ye.div, { className: "text-center max-w-3xl mx-auto mb-16", initial: { opacity: 0, y: -20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, children: [x.jsx("h2", { className: "heading-font text-slate-900 mb-4", children: "Pricing Plans" }), x.jsx("p", { className: "text-slate-600 text-lg", children: "Transparent and simple pricing, tailored for growth." })] }), x.jsx(ye.div, { className: "grid md:grid-cols-3 gap-8", variants: t, initial: "hidden", whileInView: "visible", viewport: { once: !0 }, children: lP.map(i => x.jsxs(ye.div, { className: `neon-hover rounded-2xl p-8 border transition-all ${i.highlight ? "bg-[#F8FBFF] border-[#00E6FF44] shadow-lg" : "bg-[#FAFBFD] border-[#E6EAF2]"} hover:-translate-y-1`, variants: r, whileHover: { scale: i.highlight ? 1.05 : 1.03, y: -8 }, children: [x.jsxs("div", { className: "flex items-baseline justify-between mb-6", children: [x.jsx("h3", { className: "heading-font text-slate-900", children: i.name }), i.highlight && x.jsx("span", { className: "text-xs px-3 py-1 rounded-full bg-[#00E6FF15] text-[#00E6FF]", children: "Popular" })] }), x.jsx("div", { className: "text-[#1E62FF] heading-font", style: { fontSize: "28px" }, children: i.price }), x.jsx("p", { className: "text-slate-600 mt-2", children: i.description }), x.jsx("ul", { className: "mt-6 space-y-3", children: i.features.map(s => x.jsxs("li", { className: "flex items-center gap-3 text-slate-700", children: [x.jsx("span", { className: "w-6 h-6 rounded-md bg-[#1E62FF15] text-[#1E62FF] flex items-center justify-center", children: x.jsx(_1, { className: "w-4 h-4" }) }), s] }, s)) }), x.jsxs(ye.a, { href: "#contact", className: "mt-8 block text-center bg-[#1E62FF] text-white px-6 py-3 rounded-xl", whileHover: { scale: 1.05 }, whileTap: { scale: .95 }, children: ["Choose ", i.name] })] }, i.name)) })] }) }) } function uP(t) { return Object.prototype.toString.call(t) === "[object Object]" } function sm(t) { return uP(t) || Array.isArray(t) } function cP() { return !!(typeof window < "u" && window.document && window.document.createElement) } function Bc(t, r) { const i = Object.keys(t), s = Object.keys(r); if (i.length !== s.length) return !1; const l = JSON.stringify(Object.keys(t.breakpoints || {})), c = JSON.stringify(Object.keys(r.breakpoints || {})); return l !== c ? !1 : i.every(u => { const d = t[u], h = r[u]; return typeof d == "function" ? `${d}` == `${h}` : !sm(d) || !sm(h) ? d === h : Bc(d, h) }) } function am(t) { return t.concat().sort((r, i) => r.name > i.name ? 1 : -1).map(r => r.options) } function fP(t, r) { if (t.length !== r.length) return !1; const i = am(t), s = am(r); return i.every((l, c) => { const u = s[c]; return Bc(l, u) }) } function Uc(t) { return typeof t == "number" } function Ju(t) { return typeof t == "string" } function ya(t) { return typeof t == "boolean" } function lm(t) { return Object.prototype.toString.call(t) === "[object Object]" } function Be(t) { return Math.abs(t) } function $c(t) { return Math.sign(t) } function ho(t, r) { return Be(t - r) } function dP(t, r) { if (t === 0 || r === 0 || Be(t) <= Be(r)) return 0; const i = ho(Be(t), Be(r)); return Be(i / t) } function hP(t) { return Math.round(t * 100) / 100 } function wo(t) { return So(t).map(Number) } function Zt(t) { return t[jo(t)] } function jo(t) { return Math.max(0, t.length - 1) } function Wc(t, r) { return r === jo(t) } function um(t, r = 0) { return Array.from(Array(t), (i, s) => r + s) } function So(t) { return Object.keys(t) } function Oy(t, r) { return [t, r].reduce((i, s) => (So(s).forEach(l => { const c = i[l], u = s[l], d = lm(c) && lm(u); i[l] = d ? Oy(c, u) : u }), i), {}) } function ec(t, r) { return typeof r.MouseEvent < "u" && t instanceof r.MouseEvent } function pP(t, r) { const i = { start: s, center: l, end: c }; function s() { return 0 } function l(h) { return c(h) / 2 } function c(h) { return r - h } function u(h, m) { return Ju(t) ? i[t](h) : t(r, h, m) } return { measure: u } } function ko() { let t = []; function r(l, c, u, d = { passive: !0 }) { let h; if ("addEventListener" in l) l.addEventListener(c, u, d), h = () => l.removeEventListener(c, u, d); else { const m = l; m.addListener(u), h = () => m.removeListener(u) } return t.push(h), s } function i() { t = t.filter(l => l()) } const s = { add: r, clear: i }; return s } function mP(t, r, i, s) { const l = ko(), c = 1e3 / 60; let u = null, d = 0, h = 0; function m() { l.add(t, "visibilitychange", () => { t.hidden && E() }) } function g() { k(), l.clear() } function v(C) { if (!h) return; u || (u = C, i(), i()); const P = C - u; for (u = C, d += P; d >= c;)i(), d -= c; const A = d / c; s(A), h && (h = r.requestAnimationFrame(v)) } function w() { h || (h = r.requestAnimationFrame(v)) } function k() { r.cancelAnimationFrame(h), u = null, d = 0, h = 0 } function E() { u = null, d = 0 } return { init: m, destroy: g, start: w, stop: k, update: i, render: s } } function gP(t, r) { const i = r === "rtl", s = t === "y", l = s ? "y" : "x", c = s ? "x" : "y", u = !s && i ? -1 : 1, d = g(), h = v(); function m(E) { const { height: N, width: C } = E; return s ? N : C } function g() { return s ? "top" : i ? "right" : "left" } function v() { return s ? "bottom" : i ? "left" : "right" } function w(E) { return E * u } return { scroll: l, cross: c, startEdge: d, endEdge: h, measureSize: m, direction: w } } function wr(t = 0, r = 0) { const i = Be(t - r); function s(m) { return m < t } function l(m) { return m > r } function c(m) { return s(m) || l(m) } function u(m) { return c(m) ? s(m) ? t : r : m } function d(m) { return i ? m - i * Math.ceil((m - r) / i) : m } return { length: i, max: r, min: t, constrain: u, reachedAny: c, reachedMax: l, reachedMin: s, removeOffset: d } } function zy(t, r, i) { const { constrain: s } = wr(0, t), l = t + 1; let c = u(r); function u(w) { return i ? Be((l + w) % l) : s(w) } function d() { return c } function h(w) { return c = u(w), v } function m(w) { return g().set(d() + w) } function g() { return zy(t, d(), i) } const v = { get: d, set: h, add: m, clone: g }; return v } function yP(t, r, i, s, l, c, u, d, h, m, g, v, w, k, E, N, C, P, A) { const { cross: L, direction: U } = t, O = ["INPUT", "SELECT", "TEXTAREA"], H = { passive: !1 }, K = ko(), I = ko(), Q = wr(50, 225).constrain(k.measure(20)), le = { mouse: 300, touch: 400 }, pe = { mouse: 500, touch: 600 }, Se = E ? 43 : 25; let Re = !1, je = 0, Te = 0, ke = !1, ae = !1, V = !1, Y = !1; function G(Z) { if (!A) return; function be(et) { (ya(A) || A(Z, et)) && ge(et) } const Fe = r; K.add(Fe, "dragstart", et => et.preventDefault(), H).add(Fe, "touchmove", () => { }, H).add(Fe, "touchend", () => { }).add(Fe, "touchstart", be).add(Fe, "mousedown", be).add(Fe, "touchcancel", fe).add(Fe, "contextmenu", fe).add(Fe, "click", ve, !0) } function j() { K.clear(), I.clear() } function _() { const Z = Y ? i : r; I.add(Z, "touchmove", se, H).add(Z, "touchend", fe).add(Z, "mousemove", se, H).add(Z, "mouseup", fe) } function ne(Z) { const be = Z.nodeName || ""; return O.includes(be) } function ie() { return (E ? pe : le)[Y ? "mouse" : "touch"] } function me(Z, be) { const Fe = v.add($c(Z) * -1), et = g.byDistance(Z, !E).distance; return E || Be(Z) < Q ? et : C && be ? et * .5 : g.byIndex(Fe.get(), 0).distance } function ge(Z) { const be = ec(Z, s); Y = be, V = E && be && !Z.buttons && Re, Re = ho(l.get(), u.get()) >= 2, !(be && Z.button !== 0) && (ne(Z.target) || (ke = !0, c.pointerDown(Z), m.useFriction(0).useDuration(0), l.set(u), _(), je = c.readPoint(Z), Te = c.readPoint(Z, L), w.emit("pointerDown"))) } function se(Z) { if (!ec(Z, s) && Z.touches.length >= 2) return fe(Z); const Fe = c.readPoint(Z), et = c.readPoint(Z, L), kt = ho(Fe, je), Et = ho(et, Te); if (!ae && !Y && (!Z.cancelable || (ae = kt > Et, !ae))) return fe(Z); const en = c.pointerMove(Z); kt > N && (V = !0), m.useFriction(.3).useDuration(.75), d.start(), l.add(U(en)), Z.preventDefault() } function fe(Z) { const Fe = g.byDistance(0, !1).index !== v.get(), et = c.pointerUp(Z) * ie(), kt = me(U(et), Fe), Et = dP(et, kt), en = Se - 10 * Et, Rt = P + Et / 50; ae = !1, ke = !1, I.clear(), m.useDuration(en).useFriction(Rt), h.distance(kt, !E), Y = !1, w.emit("pointerUp") } function ve(Z) { V && (Z.stopPropagation(), Z.preventDefault(), V = !1) } function Ne() { return ke } return { init: G, destroy: j, pointerDown: Ne } } function vP(t, r) { let s, l; function c(v) { return v.timeStamp } function u(v, w) { const E = `client${(w || t.scroll) === "x" ? "X" : "Y"}`; return (ec(v, r) ? v : v.touches[0])[E] } function d(v) { return s = v, l = v, u(v) } function h(v) { const w = u(v) - u(l), k = c(v) - c(s) > 170; return l = v, k && (s = v), w } function m(v) { if (!s || !l) return 0; const w = u(l) - u(s), k = c(v) - c(s), E = c(v) - c(l) > 170, N = w / k; return k && !E && Be(N) > .1 ? N : 0 } return { pointerDown: d, pointerMove: h, pointerUp: m, readPoint: u } } function xP() { function t(i) { const { offsetTop: s, offsetLeft: l, offsetWidth: c, offsetHeight: u } = i; return { top: s, right: l + c, bottom: s + u, left: l, width: c, height: u } } return { measure: t } } function wP(t) { function r(s) { return t * (s / 100) } return { measure: r } } function SP(t, r, i, s, l, c, u) { const d = [t].concat(s); let h, m, g = [], v = !1; function w(C) { return l.measureSize(u.measure(C)) } function k(C) { if (!c) return; m = w(t), g = s.map(w); function P(A) { for (const L of A) { if (v) return; const U = L.target === t, O = s.indexOf(L.target), H = U ? m : g[O], K = w(U ? t : s[O]); if (Be(K - H) >= .5) { C.reInit(), r.emit("resize"); break } } } h = new ResizeObserver(A => { (ya(c) || c(C, A)) && P(A) }), i.requestAnimationFrame(() => { d.forEach(A => h.observe(A)) }) } function E() { v = !0, h && h.disconnect() } return { init: k, destroy: E } } function kP(t, r, i, s, l, c) { let u = 0, d = 0, h = l, m = c, g = t.get(), v = 0; function w() { const H = s.get() - t.get(), K = !h; let I = 0; return K ? (u = 0, i.set(s), t.set(s), I = H) : (i.set(t), u += H / h, u *= m, g += u, t.add(u), I = g - v), d = $c(I), v = g, O } function k() { const H = s.get() - r.get(); return Be(H) < .001 } function E() { return h } function N() { return d } function C() { return u } function P() { return L(l) } function A() { return U(c) } function L(H) { return h = H, O } function U(H) { return m = H, O } const O = { direction: N, duration: E, velocity: C, seek: w, settled: k, useBaseFriction: A, useBaseDuration: P, useFriction: U, useDuration: L }; return O } function EP(t, r, i, s, l) { const c = l.measure(10), u = l.measure(50), d = wr(.1, .99); let h = !1; function m() { return !(h || !t.reachedAny(i.get()) || !t.reachedAny(r.get())) } function g(k) { if (!m()) return; const E = t.reachedMin(r.get()) ? "min" : "max", N = Be(t[E] - r.get()), C = i.get() - r.get(), P = d.constrain(N / u); i.subtract(C * P), !k && Be(C) < c && (i.set(t.constrain(i.get())), s.useDuration(25).useBaseFriction()) } function v(k) { h = !k } return { shouldConstrain: m, constrain: g, toggleActive: v } } function CP(t, r, i, s, l) { const c = wr(-r + t, 0), u = v(), d = g(), h = w(); function m(E, N) { return ho(E, N) <= 1 } function g() { const E = u[0], N = Zt(u), C = u.lastIndexOf(E), P = u.indexOf(N) + 1; return wr(C, P) } function v() { return i.map((E, N) => { const { min: C, max: P } = c, A = c.constrain(E), L = !N, U = Wc(i, N); return L ? P : U || m(C, A) ? C : m(P, A) ? P : A }).map(E => parseFloat(E.toFixed(3))) } function w() { if (r <= t + l) return [c.max]; if (s === "keepSnaps") return u; const { min: E, max: N } = d; return u.slice(E, N) } return { snapsContained: h, scrollContainLimit: d } } function PP(t, r, i) { const s = r[0], l = i ? s - t : Zt(r); return { limit: wr(l, s) } } function TP(t, r, i, s) { const c = r.min + .1, u = r.max + .1, { reachedMin: d, reachedMax: h } = wr(c, u); function m(w) { return w === 1 ? h(i.get()) : w === -1 ? d(i.get()) : !1 } function g(w) { if (!m(w)) return; const k = t * (w * -1); s.forEach(E => E.add(k)) } return { loop: g } } function NP(t) { const { max: r, length: i } = t; function s(c) { const u = c - r; return i ? u / -i : 0 } return { get: s } } function bP(t, r, i, s, l) { const { startEdge: c, endEdge: u } = t, { groupSlides: d } = l, h = v().map(r.measure), m = w(), g = k(); function v() { return d(s).map(N => Zt(N)[u] - N[0][c]).map(Be) } function w() { return s.map(N => i[c] - N[c]).map(N => -Be(N)) } function k() { return d(m).map(N => N[0]).map((N, C) => N + h[C]) } return { snaps: m, snapsAligned: g } } function RP(t, r, i, s, l, c) { const { groupSlides: u } = l, { min: d, max: h } = s, m = g(); function g() { const w = u(c), k = !t || r === "keepSnaps"; return i.length === 1 ? [c] : k ? w : w.slice(d, h).map((E, N, C) => { const P = !N, A = Wc(C, N); if (P) { const L = Zt(C[0]) + 1; return um(L) } if (A) { const L = jo(c) - Zt(C)[0] + 1; return um(L, Zt(C)[0]) } return E }) } return { slideRegistry: m } } function jP(t, r, i, s, l) { const { reachedAny: c, removeOffset: u, constrain: d } = s; function h(E) { return E.concat().sort((N, C) => Be(N) - Be(C))[0] } function m(E) { const N = t ? u(E) : d(E), C = r.map((A, L) => ({ diff: g(A - N, 0), index: L })).sort((A, L) => Be(A.diff) - Be(L.diff)), { index: P } = C[0]; return { index: P, distance: N } } function g(E, N) { const C = [E, E + i, E - i]; if (!t) return E; if (!N) return h(C); const P = C.filter(A => $c(A) === N); return P.length ? h(P) : Zt(C) - i } function v(E, N) { const C = r[E] - l.get(), P = g(C, N); return { index: E, distance: P } } function w(E, N) { const C = l.get() + E, { index: P, distance: A } = m(C), L = !t && c(C); if (!N || L) return { index: P, distance: E }; const U = r[P] - A, O = E + g(U, 0); return { index: P, distance: O } } return { byDistance: w, byIndex: v, shortcut: g } } function AP(t, r, i, s, l, c, u) { function d(v) { const w = v.distance, k = v.index !== r.get(); c.add(w), w && (s.duration() ? t.start() : (t.update(), t.render(1), t.update())), k && (i.set(r.get()), r.set(v.index), u.emit("select")) } function h(v, w) { const k = l.byDistance(v, w); d(k) } function m(v, w) { const k = r.clone().set(v), E = l.byIndex(k.get(), w); d(E) } return { distance: h, index: m } } function MP(t, r, i, s, l, c, u, d) { const h = { passive: !0, capture: !0 }; let m = 0; function g(k) { if (!d) return; function E(N) { if (new Date().getTime() - m > 10) return; u.emit("slideFocusStart"), t.scrollLeft = 0; const A = i.findIndex(L => L.includes(N)); Uc(A) && (l.useDuration(0), s.index(A, 0), u.emit("slideFocus")) } c.add(document, "keydown", v, !1), r.forEach((N, C) => { c.add(N, "focus", P => { (ya(d) || d(k, P)) && E(C) }, h) }) } function v(k) { k.code === "Tab" && (m = new Date().getTime()) } return { init: g } } function ao(t) { let r = t; function i() { return r } function s(h) { r = u(h) } function l(h) { r += u(h) } function c(h) { r -= u(h) } function u(h) { return Uc(h) ? h : h.get() } return { get: i, set: s, add: l, subtract: c } } function By(t, r) { const i = t.scroll === "x" ? u : d, s = r.style; let l = null, c = !1; function u(w) { return `translate3d(${w}px,0px,0px)` } function d(w) { return `translate3d(0px,${w}px,0px)` } function h(w) { if (c) return; const k = hP(t.direction(w)); k !== l && (s.transform = i(k), l = k) } function m(w) { c = !w } function g() { c || (s.transform = "", r.getAttribute("style") || r.removeAttribute("style")) } return { clear: g, to: h, toggleActive: m } } function LP(t, r, i, s, l, c, u, d, h) { const g = wo(l), v = wo(l).reverse(), w = P().concat(A()); function k(K, I) { return K.reduce((Q, le) => Q - l[le], I) } function E(K, I) { return K.reduce((Q, le) => k(Q, I) > 0 ? Q.concat([le]) : Q, []) } function N(K) { return c.map((I, Q) => ({ start: I - s[Q] + .5 + K, end: I + r - .5 + K })) } function C(K, I, Q) { const le = N(I); return K.map(pe => { const Se = Q ? 0 : -i, Re = Q ? i : 0, je = Q ? "end" : "start", Te = le[pe][je]; return { index: pe, loopPoint: Te, slideLocation: ao(-1), translate: By(t, h[pe]), target: () => d.get() > Te ? Se : Re } }) } function P() { const K = u[0], I = E(v, K); return C(I, i, !1) } function A() { const K = r - u[0] - 1, I = E(g, K); return C(I, -i, !0) } function L() { return w.every(({ index: K }) => { const I = g.filter(Q => Q !== K); return k(I, r) <= .1 }) } function U() { w.forEach(K => { const { target: I, translate: Q, slideLocation: le } = K, pe = I(); pe !== le.get() && (Q.to(pe), le.set(pe)) }) } function O() { w.forEach(K => K.translate.clear()) } return { canLoop: L, clear: O, loop: U, loopPoints: w } } function DP(t, r, i) { let s, l = !1; function c(h) { if (!i) return; function m(g) { for (const v of g) if (v.type === "childList") { h.reInit(), r.emit("slidesChanged"); break } } s = new MutationObserver(g => { l || (ya(i) || i(h, g)) && m(g) }), s.observe(t, { childList: !0 }) } function u() { s && s.disconnect(), l = !0 } return { init: c, destroy: u } } function FP(t, r, i, s) { const l = {}; let c = null, u = null, d, h = !1; function m() { d = new IntersectionObserver(E => { h || (E.forEach(N => { const C = r.indexOf(N.target); l[C] = N }), c = null, u = null, i.emit("slidesInView")) }, { root: t.parentElement, threshold: s }), r.forEach(E => d.observe(E)) } function g() { d && d.disconnect(), h = !0 } function v(E) { return So(l).reduce((N, C) => { const P = parseInt(C), { isIntersecting: A } = l[P]; return (E && A || !E && !A) && N.push(P), N }, []) } function w(E = !0) { if (E && c) return c; if (!E && u) return u; const N = v(E); return E && (c = N), E || (u = N), N } return { init: m, destroy: g, get: w } } function VP(t, r, i, s, l, c) { const { measureSize: u, startEdge: d, endEdge: h } = t, m = i[0] && l, g = E(), v = N(), w = i.map(u), k = C(); function E() { if (!m) return 0; const A = i[0]; return Be(r[d] - A[d]) } function N() { if (!m) return 0; const A = c.getComputedStyle(Zt(s)); return parseFloat(A.getPropertyValue(`margin-${h}`)) } function C() { return i.map((A, L, U) => { const O = !L, H = Wc(U, L); return O ? w[L] + g : H ? w[L] + v : U[L + 1][d] - A[d] }).map(Be) } return { slideSizes: w, slideSizesWithGaps: k, startGap: g, endGap: v } } function IP(t, r, i, s, l, c, u, d, h) { const { startEdge: m, endEdge: g, direction: v } = t, w = Uc(i); function k(P, A) { return wo(P).filter(L => L % A === 0).map(L => P.slice(L, L + A)) } function E(P) { return P.length ? wo(P).reduce((A, L, U) => { const O = Zt(A) || 0, H = O === 0, K = L === jo(P), I = l[m] - c[O][m], Q = l[m] - c[L][g], le = !s && H ? v(u) : 0, pe = !s && K ? v(d) : 0, Se = Be(Q - pe - (I + le)); return U && Se > r + h && A.push(L), K && A.push(P.length), A }, []).map((A, L, U) => { const O = Math.max(U[L - 1] || 0); return P.slice(O, A) }) : [] } function N(P) { return w ? k(P, i) : E(P) } return { groupSlides: N } } function _P(t, r, i, s, l, c, u) { const { align: d, axis: h, direction: m, startIndex: g, loop: v, duration: w, dragFree: k, dragThreshold: E, inViewThreshold: N, slidesToScroll: C, skipSnaps: P, containScroll: A, watchResize: L, watchSlides: U, watchDrag: O, watchFocus: H } = c, K = 2, I = xP(), Q = I.measure(r), le = i.map(I.measure), pe = gP(h, m), Se = pe.measureSize(Q), Re = wP(Se), je = pP(d, Se), Te = !v && !!A, ke = v || !!A, { slideSizes: ae, slideSizesWithGaps: V, startGap: Y, endGap: G } = VP(pe, Q, le, i, ke, l), j = IP(pe, Se, C, v, Q, le, Y, G, K), { snaps: _, snapsAligned: ne } = bP(pe, je, Q, le, j), ie = -Zt(_) + Zt(V), { snapsContained: me, scrollContainLimit: ge } = CP(Se, ie, ne, A, K), se = Te ? me : ne, { limit: fe } = PP(ie, se, v), ve = zy(jo(se), g, v), Ne = ve.clone(), Ce = wo(i), Z = ({ dragHandler: At, scrollBody: cn, scrollBounds: di, options: { loop: Zn } }) => { Zn || di.constrain(At.pointerDown()), cn.seek() }, be = ({ scrollBody: At, translate: cn, location: di, offsetLocation: Zn, previousLocation: Mo, scrollLooper: va, slideLooper: hi, dragHandler: pi, animation: mi, eventHandler: Pr, scrollBounds: gi, options: { loop: fn } }, dn) => { const yi = At.settled(), Lo = !gi.shouldConstrain(), vi = fn ? yi : yi && Lo, xi = vi && !pi.pointerDown(); xi && mi.stop(); const Do = di.get() * dn + Mo.get() * (1 - dn); Zn.set(Do), fn && (va.loop(At.direction()), hi.loop()), cn.to(Zn.get()), xi && Pr.emit("settle"), vi || Pr.emit("scroll") }, Fe = mP(s, l, () => Z(Cr), At => be(Cr, At)), et = .68, kt = se[ve.get()], Et = ao(kt), en = ao(kt), Rt = ao(kt), Ct = ao(kt), jt = kP(Et, Rt, en, Ct, w, et), qn = jP(v, se, ie, fe, Ct), Sr = AP(Fe, ve, Ne, jt, qn, Ct, u), ci = NP(fe), fi = ko(), Ao = FP(r, i, u, N), { slideRegistry: kr } = RP(Te, A, se, ge, j, Ce), Er = MP(t, i, kr, Sr, jt, fi, u, H), Cr = { ownerDocument: s, ownerWindow: l, eventHandler: u, containerRect: Q, slideRects: le, animation: Fe, axis: pe, dragHandler: yP(pe, t, s, l, Ct, vP(pe, l), Et, Fe, Sr, jt, qn, ve, u, Re, k, E, P, et, O), eventStore: fi, percentOfView: Re, index: ve, indexPrevious: Ne, limit: fe, location: Et, offsetLocation: Rt, previousLocation: en, options: c, resizeHandler: SP(r, u, l, i, pe, L, I), scrollBody: jt, scrollBounds: EP(fe, Rt, Ct, jt, Re), scrollLooper: TP(ie, fe, Rt, [Et, Rt, en, Ct]), scrollProgress: ci, scrollSnapList: se.map(ci.get), scrollSnaps: se, scrollTarget: qn, scrollTo: Sr, slideLooper: LP(pe, Se, ie, ae, V, _, se, Rt, i), slideFocus: Er, slidesHandler: DP(r, u, U), slidesInView: Ao, slideIndexes: Ce, slideRegistry: kr, slidesToScroll: j, target: Ct, translate: By(pe, r) }; return Cr } function OP() { let t = {}, r; function i(m) { r = m } function s(m) { return t[m] || [] } function l(m) { return s(m).forEach(g => g(r, m)), h } function c(m, g) { return t[m] = s(m).concat([g]), h } function u(m, g) { return t[m] = s(m).filter(v => v !== g), h } function d() { t = {} } const h = { init: i, emit: l, off: u, on: c, clear: d }; return h } const zP = { align: "center", axis: "x", container: null, slides: null, containScroll: "trimSnaps", direction: "ltr", slidesToScroll: 1, inViewThreshold: 0, breakpoints: {}, dragFree: !1, dragThreshold: 10, loop: !1, skipSnaps: !1, duration: 25, startIndex: 0, active: !0, watchDrag: !0, watchResize: !0, watchSlides: !0, watchFocus: !0 }; function BP(t) { function r(c, u) { return Oy(c, u || {}) } function i(c) { const u = c.breakpoints || {}, d = So(u).filter(h => t.matchMedia(h).matches).map(h => u[h]).reduce((h, m) => r(h, m), {}); return r(c, d) } function s(c) { return c.map(u => So(u.breakpoints || {})).reduce((u, d) => u.concat(d), []).map(t.matchMedia) } return { mergeOptions: r, optionsAtMedia: i, optionsMediaQueries: s } } function UP(t) { let r = []; function i(c, u) { return r = u.filter(({ options: d }) => t.optionsAtMedia(d).active !== !1), r.forEach(d => d.init(c, t)), u.reduce((d, h) => Object.assign(d, { [h.name]: h }), {}) } function s() { r = r.filter(c => c.destroy()) } return { init: i, destroy: s } } function fa(t, r, i) { const s = t.ownerDocument, l = s.defaultView, c = BP(l), u = UP(c), d = ko(), h = OP(), { mergeOptions: m, optionsAtMedia: g, optionsMediaQueries: v } = c, { on: w, off: k, emit: E } = h, N = pe; let C = !1, P, A = m(zP, fa.globalOptions), L = m(A), U = [], O, H, K; function I() { const { container: Ce, slides: Z } = L; H = (Ju(Ce) ? t.querySelector(Ce) : Ce) || t.children[0]; const Fe = Ju(Z) ? H.querySelectorAll(Z) : Z; K = [].slice.call(Fe || H.children) } function Q(Ce) { const Z = _P(t, H, K, s, l, Ce, h); if (Ce.loop && !Z.slideLooper.canLoop()) { const be = Object.assign({}, Ce, { loop: !1 }); return Q(be) } return Z } function le(Ce, Z) { C || (A = m(A, Ce), L = g(A), U = Z || U, I(), P = Q(L), v([A, ...U.map(({ options: be }) => be)]).forEach(be => d.add(be, "change", pe)), L.active && (P.translate.to(P.location.get()), P.animation.init(), P.slidesInView.init(), P.slideFocus.init(Ne), P.eventHandler.init(Ne), P.resizeHandler.init(Ne), P.slidesHandler.init(Ne), P.options.loop && P.slideLooper.loop(), H.offsetParent && K.length && P.dragHandler.init(Ne), O = u.init(Ne, U))) } function pe(Ce, Z) { const be = j(); Se(), le(m({ startIndex: be }, Ce), Z), h.emit("reInit") } function Se() { P.dragHandler.destroy(), P.eventStore.clear(), P.translate.clear(), P.slideLooper.clear(), P.resizeHandler.destroy(), P.slidesHandler.destroy(), P.slidesInView.destroy(), P.animation.destroy(), u.destroy(), d.clear() } function Re() { C || (C = !0, d.clear(), Se(), h.emit("destroy"), h.clear()) } function je(Ce, Z, be) { !L.active || C || (P.scrollBody.useBaseFriction().useDuration(Z === !0 ? 0 : L.duration), P.scrollTo.index(Ce, be || 0)) } function Te(Ce) { const Z = P.index.add(1).get(); je(Z, Ce, -1) } function ke(Ce) { const Z = P.index.add(-1).get(); je(Z, Ce, 1) } function ae() { return P.index.add(1).get() !== j() } function V() { return P.index.add(-1).get() !== j() } function Y() { return P.scrollSnapList } function G() { return P.scrollProgress.get(P.offsetLocation.get()) } function j() { return P.index.get() } function _() { return P.indexPrevious.get() } function ne() { return P.slidesInView.get() } function ie() { return P.slidesInView.get(!1) } function me() { return O } function ge() { return P } function se() { return t } function fe() { return H } function ve() { return K } const Ne = { canScrollNext: ae, canScrollPrev: V, containerNode: fe, internalEngine: ge, destroy: Re, off: k, on: w, emit: E, plugins: me, previousScrollSnap: _, reInit: N, rootNode: se, scrollNext: Te, scrollPrev: ke, scrollProgress: G, scrollSnapList: Y, scrollTo: je, selectedScrollSnap: j, slideNodes: ve, slidesInView: ne, slidesNotInView: ie }; return le(r, i), setTimeout(() => h.emit("init"), 0), Ne } fa.globalOptions = void 0; function Hc(t = {}, r = []) { const i = b.useRef(t), s = b.useRef(r), [l, c] = b.useState(), [u, d] = b.useState(), h = b.useCallback(() => { l && l.reInit(i.current, s.current) }, [l]); return b.useEffect(() => { Bc(i.current, t) || (i.current = t, h()) }, [t, h]), b.useEffect(() => { fP(s.current, r) || (s.current = r, h()) }, [r, h]), b.useEffect(() => { if (cP() && u) { fa.globalOptions = Hc.globalOptions; const m = fa(u, i.current, s.current); return c(m), () => m.destroy() } else c(void 0) }, [u, c]), [d, l] } Hc.globalOptions = void 0; const $P = [{ name: "Vythiri Dew Vista", role: "Luxury Resort", quote: "Outstanding work on our resort website! The elegant design perfectly captures the essence of our property. We've seen a significant increase in direct bookings since the launch. The team understood our vision and delivered beyond expectations.", image: "https://a0.muscache.com/im/pictures/user/User/original/8669a38f-d8b8-4ead-8014-5cdb5d8f7ef7.jpeg?im_w=240", website: "https://vythiridewvista.com" }, { name: "Mount Vista", role: "Hospitality & Tourism", quote: "The website they created for us is simply beautiful. Clean, modern design with smooth navigation that our guests love. The booking integration works flawlessly, and the mobile experience is exceptional. Highly recommend their services!", image: "https://a0.muscache.com/im/pictures/user/User/original/8595f36a-3f96-41c0-a861-20fa1648792e.jpeg?im_w=240", website: "https://www.mountvista.in" }, { name: "Sarah Mitchell", role: "Boutique Owner", quote: "Professional, responsive, and creative! They transformed our online presence completely. Our customers find it so easy to browse and shop now. Sales have increased by 40% in just two months!", image: "https://cdn-icons-png.flaticon.com/512/727/727362.png", website: "" }, { name: "Rajesh Kumar", role: "Tech Startup Founder", quote: "Fast turnaround, modern design, and excellent SEO optimization. The site loads incredibly fast and looks amazing on all devices. Best investment we made for our online presence.", image: "	https://cdn-icons-png.flaticon.com/512/657/657052.png", website: "" }]; function WP() { const [t, r] = Hc({ loop: !0, align: "start" }); return b.useEffect(() => { if (!r) return; const i = setInterval(() => { r.scrollNext() }, 3e3); return () => clearInterval(i) }, [r]), x.jsx("section", { className: "py-20 lg:py-32 bg-gradient-to-br from-white to-[#F8FBFF]", children: x.jsxs("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: [x.jsxs(ye.div, { className: "text-center max-w-3xl mx-auto mb-16", initial: { opacity: 0, y: -20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, children: [x.jsx("h2", { className: "heading-font text-slate-900 mb-4", children: "Testimonials" }), x.jsx("p", { className: "text-slate-600 text-lg", children: "Minimal cards with subtle 3D avatars and auto-scroll." })] }), x.jsx("div", { className: "overflow-hidden", ref: t, children: x.jsx("div", { className: "flex gap-6", children: $P.map((i, s) => x.jsxs(ye.div, { className: "min-w-[280px] md:min-w-[360px] bg-white rounded-2xl p-6 shadow-lg ring-1 ring-[#1E62FF11]", whileHover: { scale: 1.03, y: -5 }, transition: { duration: .2 }, children: [x.jsxs("div", { className: "flex items-center gap-4 mb-4", children: [i.image ? x.jsx(ye.img, { src: i.image, alt: i.name, className: "w-12 h-12 rounded-2xl object-cover shadow-lg", whileHover: { scale: 1.1, rotate: 5 }, transition: { duration: .3 } }) : x.jsx(ye.div, { className: "w-12 h-12 rounded-2xl bg-gradient-to-br from-[#1E62FF] to-[#00E6FF] shadow-lg", whileHover: { rotate: 360 }, transition: { duration: .8 } }), x.jsxs("div", { children: [x.jsx("div", { className: "heading-font text-slate-900", style: { fontSize: "16px" }, children: i.name }), x.jsx("div", { className: "text-slate-600 text-sm", children: i.role })] })] }), x.jsxs("p", { className: "text-slate-700", children: ['"', i.quote, '"'] })] }, s)) }) })] }) }) } function Uy() { const [t, r] = b.useState({ name: "", email: "", phone: "", message: "" }), i = s => { s.preventDefault(), console.log("Form submitted:", t) }; return x.jsxs("section", { id: "contact", className: "py-20 lg:py-32 bg-gradient-to-br from-[#F8FBFF] via-white to-[#F0FDFF] relative overflow-hidden", children: [x.jsx("div", { className: "absolute top-10 left-10 w-72 h-72 bg-[#1E64F0] rounded-full opacity-5 blur-3xl" }), x.jsx("div", { className: "absolute bottom-10 right-10 w-96 h-96 bg-[#0F7B5F] rounded-full opacity-5 blur-3xl" }), x.jsxs("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 relative", children: [x.jsxs("div", { className: "text-center max-w-3xl mx-auto mb-16", children: [x.jsx("h2", { className: "heading-font text-slate-900 mb-4", children: "Get In Touch" }), x.jsx("p", { className: "text-slate-600 text-lg", children: "Ready to build your dream website? Let's discuss your project." })] }), x.jsxs("div", { className: "grid lg:grid-cols-2 gap-12", children: [x.jsx("div", { className: "bg-white rounded-2xl p-8 shadow-xl", children: x.jsxs("form", { onSubmit: i, className: "space-y-6", children: [x.jsxs("div", { children: [x.jsx("label", { className: "block text-slate-700 mb-2", children: "Your Name" }), x.jsx("input", { type: "text", value: t.name, onChange: s => r({ ...t, name: s.target.value }), className: "w-full px-4 py-3 rounded-lg border border-slate-300 focus:border-[#1E64F0] focus:outline-none focus:ring-2 focus:ring-[#1E64F0]/20 transition-all", placeholder: "John Doe", required: !0 })] }), x.jsxs("div", { children: [x.jsx("label", { className: "block text-slate-700 mb-2", children: "Email Address" }), x.jsx("input", { type: "email", value: t.email, onChange: s => r({ ...t, email: s.target.value }), className: "w-full px-4 py-3 rounded-lg border border-slate-300 focus:border-[#1E64F0] focus:outline-none focus:ring-2 focus:ring-[#1E64F0]/20 transition-all", placeholder: "john@example.com", required: !0 })] }), x.jsxs("div", { children: [x.jsx("label", { className: "block text-slate-700 mb-2", children: "Phone Number" }), x.jsx("input", { type: "tel", value: t.phone, onChange: s => r({ ...t, phone: s.target.value }), className: "w-full px-4 py-3 rounded-lg border border-slate-300 focus:border-[#1E64F0] focus:outline-none focus:ring-2 focus:ring-[#1E64F0]/20 transition-all", placeholder: "+91 98765 43210" })] }), x.jsxs("div", { children: [x.jsx("label", { className: "block text-slate-700 mb-2", children: "Your Message" }), x.jsx("textarea", { value: t.message, onChange: s => r({ ...t, message: s.target.value }), rows: 4, className: "w-full px-4 py-3 rounded-lg border border-slate-300 focus:border-[#1E64F0] focus:outline-none focus:ring-2 focus:ring-[#1E64F0]/20 transition-all resize-none", placeholder: "Tell us about your project...", required: !0 })] }), x.jsxs("button", { type: "submit", className: "w-full bg-gradient-to-r from-[#1E62FF] to-[#00E6FF] text-white px-8 py-4 rounded-xl hover:shadow-xl transition-all flex items-center justify-center gap-2 group", children: ["Send Message", x.jsx(ow, { className: "w-5 h-5 group-hover:translate-x-1 transition-transform" })] }), x.jsx("a", { href: "tel:6238014370", className: "w-full mt-3 text-center border-2 border-[#1E62FF] text-[#1E62FF] px-8 py-4 rounded-xl hover:bg-[#1E62FF] hover:text-white transition-all", children: "Request a Callback" })] }) }), x.jsxs("div", { className: "space-y-8", children: [x.jsxs("div", { className: "bg-gradient-to-br from-[#1E64F0] to-[#0F7B5F] rounded-2xl p-8 text-white", children: [x.jsx("h3", { className: "heading-font mb-6", children: "Contact Information" }), x.jsxs("div", { className: "space-y-6", children: [x.jsxs("div", { className: "flex items-start gap-4", children: [x.jsx("div", { className: "w-12 h-12 bg-white/20 rounded-lg flex items-center justify-center flex-shrink-0", children: x.jsx(Vm, { className: "w-6 h-6" }) }), x.jsxs("div", { children: [x.jsx("div", { className: "text-sm opacity-90 mb-1", children: "Phone" }), x.jsx("div", { children: "6238014370" }), x.jsx("div", { children: "8304824323" })] })] }), x.jsxs("div", { className: "flex items-start gap-4", children: [x.jsx("div", { className: "w-12 h-12 bg-white/20 rounded-lg flex items-center justify-center flex-shrink-0", children: x.jsx(Fm, { className: "w-6 h-6" }) }), x.jsxs("div", { children: [x.jsx("div", { className: "text-sm opacity-90 mb-1", children: "Email" }), x.jsx("div", { children: "makeasite.in@gmail.com" })] })] }), x.jsxs("div", { className: "flex items-start gap-4", children: [x.jsx("div", { className: "w-12 h-12 bg-white/20 rounded-lg flex items-center justify-center flex-shrink-0", children: x.jsx(ew, { className: "w-6 h-6" }) }), x.jsxs("div", { children: [x.jsx("div", { className: "text-sm opacity-90 mb-1", children: "Website" }), x.jsx("div", { children: "MakeASite.in" })] })] })] })] }), x.jsx("a", { href: "https://wa.me/917306683199", target: "_blank", rel: "noopener noreferrer", className: "bg-[#25D366] rounded-2xl p-8 text-white shadow-xl hover:shadow-2xl transition-all cursor-pointer group block", children: x.jsxs("div", { className: "flex items-center gap-4", children: [x.jsx("div", { className: "w-16 h-16 bg-white/20 rounded-2xl flex items-center justify-center group-hover:scale-110 transition-transform", children: x.jsx(nw, { className: "w-8 h-8" }) }), x.jsxs("div", { children: [x.jsx("h3", { className: "heading-font mb-1", children: "Chat on WhatsApp" }), x.jsx("p", { className: "text-sm opacity-90", children: "Get instant responses to your queries" })] })] }) })] })] })] })] }) } function HP() { return x.jsxs(x.Fragment, { children: [x.jsx(GE, {}), x.jsx(yy, {}), x.jsx(sP, {}), x.jsx(Iy, {}), x.jsx(_y, {}), x.jsx(WP, {}), x.jsx(Uy, {})] }) } function KP() { return x.jsx(v1, { children: x.jsx(Yx, { children: x.jsxs(pr, { path: "/", element: x.jsx(mw, {}), children: [x.jsx(pr, { index: !0, element: x.jsx(HP, {}) }), x.jsx(pr, { path: "services", element: x.jsx(yy, {}) }), x.jsx(pr, { path: "pricing", element: x.jsx(_y, {}) }), x.jsx(pr, { path: "portfolio", element: x.jsx(Iy, {}) }), x.jsx(pr, { path: "contact", element: x.jsx(Uy, {}) })] }) }) }) } K0.createRoot(document.getElementById("root")).render(x.jsx(KP, {}));
